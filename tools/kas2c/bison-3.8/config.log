This file contains any messages produced by compilers while
running configure, to aid debugging if configure makes a mistake.

It was created by GNU Bison configure 3.8, which was
generated by GNU Autoconf 2.71.  Invocation command line was

  $ ./configure

## --------- ##
## Platform. ##
## --------- ##

hostname = DESKTOP-VFIRT1R
uname -m = x86_64
uname -r = 3.4.7-1.x86_64
uname -s = CYGWIN_NT-10.0-19045
uname -v = 2023-06-16 14:04 UTC

/usr/bin/uname -p = unknown
/bin/uname -X     = unknown

/bin/arch              = x86_64
/usr/bin/arch -k       = unknown
/usr/convex/getsysinfo = unknown
/usr/bin/hostinfo      = unknown
/bin/machine           = unknown
/usr/bin/oslevel       = unknown
/bin/universe          = unknown

PATH: /usr/local/bin/
PATH: /usr/bin/
PATH: /cygdrive/c/Program Files (x86)/Intel/oneAPI/tbb/latest/redist/intel64/vc_mt/
PATH: /cygdrive/c/Program Files (x86)/Intel/oneAPI/tbb/latest/redist/ia32/vc_mt/
PATH: /cygdrive/c/Program Files (x86)/Intel/oneAPI/compiler/latest/windows/redist/intel64_win/compiler/
PATH: /cygdrive/c/Program Files (x86)/Intel/oneAPI/compiler/latest/windows/redist/ia32_win/compiler/
PATH: /cygdrive/c/Program Files/Microsoft/jdk-11.0.16.101-hotspot/bin/
PATH: /cygdrive/c/Program Files/Eclipse Adoptium/jdk-17.0.7.7-hotspot/bin/
PATH: /cygdrive/c/Program Files/Common Files/Oracle/Java/javapath/
PATH: /cygdrive/c/Windows/
PATH: /cygdrive/c/Windows/system32/
PATH: /cygdrive/c/Windows/System32/Wbem/
PATH: /cygdrive/c/Windows/System32/WindowsPowerShell/v1.0/
PATH: /cygdrive/c/Windows/System32/OpenSSH/
PATH: /cygdrive/c/Program Files/Oculus/Support/oculus-runtime/
PATH: /cygdrive/c/Program Files/NVIDIA Corporation/NVIDIA NvDLISR/
PATH: /cygdrive/c/Users/noly9/AppData/Local/Android/Sdk/build-tools/28.0.3/
PATH: /cygdrive/c/Program Files/Git/cmd/
PATH: /cygdrive/c/Program Files (x86)/NVIDIA Corporation/PhysX/Common/
PATH: /cygdrive/c/Android/
PATH: /cygdrive/c/Program Files/Microsoft SQL Server/150/Tools/Binn/
PATH: /cygdrive/c/Program Files/Microsoft SQL Server/Client SDK/ODBC/170/Tools/Binn/
PATH: /cygdrive/c/Program Files/dotnet/
PATH: /cygdrive/c/Users/noly9/AppData/Local/Programs/Python/Python310/
PATH: /cygdrive/c/Users/noly9/AppData/Local/Programs/Python/Python310/Scripts/
PATH: /cygdrive/c/Program Files/Mullvad VPN/resources/
PATH: /cygdrive/c/Program Files/AntiMicroX/bin/
PATH: /cygdrive/c/Program Files/Docker/Docker/resources/bin/
PATH: /cygdrive/c/Program Files/Java/jdk-19/bin/
PATH: /cygdrive/c/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/
PATH: /cygdrive/c/Program Files (x86)/Microsoft SQL Server/90/Tools/binn/
PATH: /usr/bin/
PATH: /cygdrive/c/source/homeworld/tools/bin/
PATH: /cygdrive/s/HWCompile/DevStudio/VC/bin/
PATH: /cygdrive/c/Program Files (x86)/Intel/oneAPI/compiler/2023.2.0/windows/bin/intel64_ia32/
PATH: /cygdrive/s/HWCompile/devstudio/sharedide/bin/ide/
PATH: /cygdrive/s/HWCompile/devstudio/sharedide/bin/
PATH: /cygdrive/c/Users/noly9/appdata/local/microsoft/windowsapps/
PATH: /cygdrive/c/platform-tools/
PATH: /cygdrive/c/users/noly9/appdata/local/githubdesktop/bin/
PATH: /cygdrive/c/Users/noly9/.dotnet/tools/
PATH: /cygdrive/c/users/noly9/appdata/local/programs/microsoft vs code/bin/
PATH: /cygdrive/c/Users/noly9/.poetry/bin/
PATH: /cygdrive/c/users/noly9/appdata/local/programs/python/python310/
PATH: /cygdrive/c/Program Files/JetBrains/IntelliJ IDEA Community Edition 2022.3.2/bin/
PATH: /cygdrive/c/source/homeworld/tools/bin/
PATH: /cygdrive/c/source/homeworld/tools/batch/
PATH: /cygdrive/s/HWCompile/devstudio/vc/bin/
PATH: /cygdrive/s/HWCompile/devstudio/common7/


## ----------- ##
## Core tests. ##
## ----------- ##

configure:4719: looking for aux files: config.rpath config.guess config.sub compile missing install-sh
configure:4732:  trying ./build-aux/
configure:4761:   ./build-aux/config.rpath found
configure:4761:   ./build-aux/config.guess found
configure:4761:   ./build-aux/config.sub found
configure:4761:   ./build-aux/compile found
configure:4761:   ./build-aux/missing found
configure:4743:   ./build-aux/install-sh found
configure:4908: checking for a BSD-compatible install
configure:4981: result: /usr/bin/install -c
configure:4992: checking whether build environment is sane
configure:5047: result: yes
configure:5206: checking for a race-free mkdir -p
configure:5250: result: /usr/bin/mkdir -p
configure:5257: checking for gawk
configure:5278: found /usr/bin/gawk
configure:5289: result: gawk
configure:5300: checking whether make sets $(MAKE)
configure:5323: result: yes
configure:5353: checking whether make supports nested variables
configure:5371: result: yes
configure:5505: checking whether make supports nested variables
configure:5523: result: yes
configure:5600: checking for gcc
configure:5621: found /usr/bin/gcc
configure:5632: result: gcc
configure:5985: checking for C compiler version
configure:5994: gcc --version >&5
gcc (GCC) 11.4.0
Copyright (C) 2021 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

configure:6005: $? = 0
configure:5994: gcc -v >&5
Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-pc-cygwin/11/lto-wrapper.exe
Target: x86_64-pc-cygwin
Configured with: /mnt/share/cygpkgs/gcc/gcc.x86_64/src/gcc-11.4.0/configure --srcdir=/mnt/share/cygpkgs/gcc/gcc.x86_64/src/gcc-11.4.0 --prefix=/usr --exec-prefix=/usr --localstatedir=/var --sysconfdir=/etc --docdir=/usr/share/doc/gcc --htmldir=/usr/share/doc/gcc/html -C --build=x86_64-pc-cygwin --host=x86_64-pc-cygwin --target=x86_64-pc-cygwin --without-libiconv-prefix --without-libintl-prefix --libexecdir=/usr/lib --with-gcc-major-version-only --enable-shared --enable-shared-libgcc --enable-static --enable-version-specific-runtime-libs --enable-bootstrap --enable-__cxa_atexit --with-dwarf2 --with-tune=generic --enable-languages=ada,c,c++,d,fortran,lto,objc,obj-c++,jit --enable-graphite --enable-threads=posix --enable-libatomic --enable-libgomp --enable-libquadmath --enable-libquadmath-support --disable-libssp --enable-libada --disable-symvers --disable-multilib --with-gnu-ld --with-gnu-as --with-cloog-include=/usr/include/cloog-isl --without-libiconv-prefix --without-libintl-prefix --with-system-zlib --enable-linker-build-id --with-default-libstdcxx-abi=gcc4-compatible --enable-libstdcxx-filesystem-ts
Thread model: posix
Supported LTO compression algorithms: zlib zstd
gcc version 11.4.0 (GCC) 
configure:6005: $? = 0
configure:5994: gcc -V >&5
gcc: error: unrecognized command-line option '-V'
gcc: fatal error: no input files
compilation terminated.
configure:6005: $? = 1
configure:5994: gcc -qversion >&5
gcc: error: unrecognized command-line option '-qversion'; did you mean '--version'?
gcc: fatal error: no input files
compilation terminated.
configure:6005: $? = 1
configure:5994: gcc -version >&5
gcc: error: unrecognized command-line option '-version'
gcc: fatal error: no input files
compilation terminated.
configure:6005: $? = 1
configure:6025: checking whether the C compiler works
configure:6047: gcc    conftest.c  >&5
configure:6051: $? = 0
configure:6101: result: yes
configure:6104: checking for C compiler default output file name
configure:6106: result: a.exe
configure:6112: checking for suffix of executables
configure:6119: gcc -o conftest.exe    conftest.c  >&5
configure:6123: $? = 0
configure:6146: result: .exe
configure:6168: checking whether we are cross compiling
configure:6176: gcc -o conftest.exe    conftest.c  >&5
configure:6180: $? = 0
configure:6187: ./conftest.exe
configure:6191: $? = 0
configure:6206: result: no
configure:6211: checking for suffix of object files
configure:6234: gcc -c   conftest.c >&5
configure:6238: $? = 0
configure:6260: result: o
configure:6264: checking whether the compiler supports GNU C
configure:6284: gcc -c   conftest.c >&5
configure:6284: $? = 0
configure:6294: result: yes
configure:6305: checking whether gcc accepts -g
configure:6326: gcc -c -g  conftest.c >&5
configure:6326: $? = 0
configure:6370: result: yes
configure:6390: checking for gcc option to enable C11 features
configure:6405: gcc  -c -g -O2  conftest.c >&5
configure:6405: $? = 0
configure:6423: result: none needed
configure:6539: checking whether gcc understands -c and -o together
configure:6562: gcc -c conftest.c -o conftest2.o
configure:6565: $? = 0
configure:6562: gcc -c conftest.c -o conftest2.o
configure:6565: $? = 0
configure:6577: result: yes
configure:6595: checking whether the compiler is clang
configure:6617: gcc -c -g -O2  conftest.c >&5
configure:6617: $? = 0
configure:6626: result: no
configure:6630: checking for compiler option needed when checking for declarations
configure:6663: result: none
configure:6675: checking whether make supports the include directive
configure:6690: make -f confmf.GNU && cat confinc.out
this is the am__doit target
configure:6693: $? = 0
configure:6712: result: yes (GNU style)
configure:6738: checking dependency style of gcc
configure:6850: result: gcc3
configure:6934: checking for g++
configure:6955: found /usr/bin/g++
configure:6966: result: g++
configure:6993: checking for C++ compiler version
configure:7002: g++ --version >&5
g++ (GCC) 11.4.0
Copyright (C) 2021 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

configure:7013: $? = 0
configure:7002: g++ -v >&5
Using built-in specs.
COLLECT_GCC=g++
COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-pc-cygwin/11/lto-wrapper.exe
Target: x86_64-pc-cygwin
Configured with: /mnt/share/cygpkgs/gcc/gcc.x86_64/src/gcc-11.4.0/configure --srcdir=/mnt/share/cygpkgs/gcc/gcc.x86_64/src/gcc-11.4.0 --prefix=/usr --exec-prefix=/usr --localstatedir=/var --sysconfdir=/etc --docdir=/usr/share/doc/gcc --htmldir=/usr/share/doc/gcc/html -C --build=x86_64-pc-cygwin --host=x86_64-pc-cygwin --target=x86_64-pc-cygwin --without-libiconv-prefix --without-libintl-prefix --libexecdir=/usr/lib --with-gcc-major-version-only --enable-shared --enable-shared-libgcc --enable-static --enable-version-specific-runtime-libs --enable-bootstrap --enable-__cxa_atexit --with-dwarf2 --with-tune=generic --enable-languages=ada,c,c++,d,fortran,lto,objc,obj-c++,jit --enable-graphite --enable-threads=posix --enable-libatomic --enable-libgomp --enable-libquadmath --enable-libquadmath-support --disable-libssp --enable-libada --disable-symvers --disable-multilib --with-gnu-ld --with-gnu-as --with-cloog-include=/usr/include/cloog-isl --without-libiconv-prefix --without-libintl-prefix --with-system-zlib --enable-linker-build-id --with-default-libstdcxx-abi=gcc4-compatible --enable-libstdcxx-filesystem-ts
Thread model: posix
Supported LTO compression algorithms: zlib zstd
gcc version 11.4.0 (GCC) 
configure:7013: $? = 0
configure:7002: g++ -V >&5
g++: error: unrecognized command-line option '-V'
g++: fatal error: no input files
compilation terminated.
configure:7013: $? = 1
configure:7002: g++ -qversion >&5
g++: error: unrecognized command-line option '-qversion'; did you mean '--version'?
g++: fatal error: no input files
compilation terminated.
configure:7013: $? = 1
configure:7017: checking whether the compiler supports GNU C++
configure:7037: g++ -c   conftest.cpp >&5
configure:7037: $? = 0
configure:7047: result: yes
configure:7058: checking whether g++ accepts -g
configure:7079: g++ -c -g  conftest.cpp >&5
configure:7079: $? = 0
configure:7123: result: yes
configure:7143: checking for g++ option to enable C++11 features
configure:7158: g++  -c -g -O2  conftest.cpp >&5
conftest.cpp: In function 'int main(int, char**)':
conftest.cpp:178:25: warning: empty parentheses were disambiguated as a function declaration [-Wvexing-parse]
  178 |   cxx11test::delegate d2();
      |                         ^~
conftest.cpp:178:25: note: remove parentheses to default-initialize a variable
  178 |   cxx11test::delegate d2();
      |                         ^~
      |                         --
conftest.cpp:178:25: note: or replace parentheses with braces to value-initialize a variable
configure:7158: $? = 0
configure:7176: result: none needed
configure:7242: checking dependency style of g++
configure:7354: result: gcc3
configure:7376: checking for stdio.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for stdlib.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for string.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for inttypes.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for stdint.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for strings.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for sys/stat.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for sys/types.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for unistd.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for wchar.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for minix/config.h
configure:7376: gcc -c -g -O2  conftest.c >&5
conftest.c:50:10: fatal error: minix/config.h: No such file or directory
   50 | #include <minix/config.h>
      |          ^~~~~~~~~~~~~~~~
compilation terminated.
configure:7376: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "GNU Bison"
| #define PACKAGE_TARNAME "bison"
| #define PACKAGE_VERSION "3.8"
| #define PACKAGE_STRING "GNU Bison 3.8"
| #define PACKAGE_BUGREPORT "bug-bison@gnu.org"
| #define PACKAGE_URL "https://www.gnu.org/software/bison/"
| #define PACKAGE_COPYRIGHT_YEAR 2021
| #define PACKAGE "bison"
| #define VERSION "3.8"
| #define HAVE_STDIO_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| /* end confdefs.h.  */
| #include <stddef.h>
| #ifdef HAVE_STDIO_H
| # include <stdio.h>
| #endif
| #ifdef HAVE_STDLIB_H
| # include <stdlib.h>
| #endif
| #ifdef HAVE_STRING_H
| # include <string.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <minix/config.h>
configure:7376: result: no
configure:7376: checking for locale.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for sys/param.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for sys/socket.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for stdio_ext.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for features.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for getopt.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for sys/cdefs.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for sys/time.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for iconv.h
configure:7376: gcc -c -g -O2  conftest.c >&5
conftest.c:58:10: fatal error: iconv.h: No such file or directory
   58 | #include <iconv.h>
      |          ^~~~~~~~~
compilation terminated.
configure:7376: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "GNU Bison"
| #define PACKAGE_TARNAME "bison"
| #define PACKAGE_VERSION "3.8"
| #define PACKAGE_STRING "GNU Bison 3.8"
| #define PACKAGE_BUGREPORT "bug-bison@gnu.org"
| #define PACKAGE_URL "https://www.gnu.org/software/bison/"
| #define PACKAGE_COPYRIGHT_YEAR 2021
| #define PACKAGE "bison"
| #define VERSION "3.8"
| #define HAVE_STDIO_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_SOCKET_H 1
| #define HAVE_STDIO_EXT_H 1
| #define HAVE_FEATURES_H 1
| #define HAVE_GETOPT_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_TIME_H 1
| /* end confdefs.h.  */
| #include <stddef.h>
| #ifdef HAVE_STDIO_H
| # include <stdio.h>
| #endif
| #ifdef HAVE_STDLIB_H
| # include <stdlib.h>
| #endif
| #ifdef HAVE_STRING_H
| # include <string.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <iconv.h>
configure:7376: result: no
configure:7376: checking for limits.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for crtdefs.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for wctype.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for threads.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for math.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for sys/mman.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for spawn.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for sys/ioctl.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for sys/resource.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for sys/times.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for sys/wait.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for termios.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for dirent.h
configure:7376: gcc -c -g -O2  conftest.c >&5
configure:7376: $? = 0
configure:7376: result: yes
configure:7376: checking for xlocale.h
configure:7376: gcc -c -g -O2  conftest.c >&5
conftest.c:71:10: fatal error: xlocale.h: No such file or directory
   71 | #include <xlocale.h>
      |          ^~~~~~~~~~~
compilation terminated.
configure:7376: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "GNU Bison"
| #define PACKAGE_TARNAME "bison"
| #define PACKAGE_VERSION "3.8"
| #define PACKAGE_STRING "GNU Bison 3.8"
| #define PACKAGE_BUGREPORT "bug-bison@gnu.org"
| #define PACKAGE_URL "https://www.gnu.org/software/bison/"
| #define PACKAGE_COPYRIGHT_YEAR 2021
| #define PACKAGE "bison"
| #define VERSION "3.8"
| #define HAVE_STDIO_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_SOCKET_H 1
| #define HAVE_STDIO_EXT_H 1
| #define HAVE_FEATURES_H 1
| #define HAVE_GETOPT_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_CRTDEFS_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_THREADS_H 1
| #define HAVE_MATH_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_SPAWN_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_TIMES_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_TERMIOS_H 1
| #define HAVE_DIRENT_H 1
| /* end confdefs.h.  */
| #include <stddef.h>
| #ifdef HAVE_STDIO_H
| # include <stdio.h>
| #endif
| #ifdef HAVE_STDLIB_H
| # include <stdlib.h>
| #endif
| #ifdef HAVE_STRING_H
| # include <string.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <xlocale.h>
configure:7376: result: no
configure:7407: checking whether it is safe to define __EXTENSIONS__
configure:7426: gcc -c -g -O2  conftest.c >&5
configure:7426: $? = 0
configure:7434: result: yes
configure:7437: checking whether _XOPEN_SOURCE should be defined
configure:7459: gcc -c -g -O2  conftest.c >&5
configure:7459: $? = 0
configure:7486: result: no
configure:7548: checking build system type
configure:7563: result: x86_64-pc-cygwin
configure:7583: checking host system type
configure:7597: result: x86_64-pc-cygwin
configure:7634: checking how to run the C preprocessor
configure:7660: gcc -E  conftest.c
configure:7660: $? = 0
configure:7675: gcc -E  conftest.c
conftest.c:60:10: fatal error: ac_nonexistent.h: No such file or directory
   60 | #include <ac_nonexistent.h>
      |          ^~~~~~~~~~~~~~~~~~
compilation terminated.
configure:7675: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "GNU Bison"
| #define PACKAGE_TARNAME "bison"
| #define PACKAGE_VERSION "3.8"
| #define PACKAGE_STRING "GNU Bison 3.8"
| #define PACKAGE_BUGREPORT "bug-bison@gnu.org"
| #define PACKAGE_URL "https://www.gnu.org/software/bison/"
| #define PACKAGE_COPYRIGHT_YEAR 2021
| #define PACKAGE "bison"
| #define VERSION "3.8"
| #define HAVE_STDIO_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_SOCKET_H 1
| #define HAVE_STDIO_EXT_H 1
| #define HAVE_FEATURES_H 1
| #define HAVE_GETOPT_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_CRTDEFS_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_THREADS_H 1
| #define HAVE_MATH_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_SPAWN_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_TIMES_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_TERMIOS_H 1
| #define HAVE_DIRENT_H 1
| #define STDC_HEADERS 1
| #define _ALL_SOURCE 1
| #define _DARWIN_C_SOURCE 1
| #define _GNU_SOURCE 1
| #define _HPUX_ALT_XOPEN_SOCKET_API 1
| #define _NETBSD_SOURCE 1
| #define _OPENBSD_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define __STDC_WANT_IEC_60559_ATTRIBS_EXT__ 1
| #define __STDC_WANT_IEC_60559_BFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_DFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_FUNCS_EXT__ 1
| #define __STDC_WANT_IEC_60559_TYPES_EXT__ 1
| #define __STDC_WANT_LIB_EXT2__ 1
| #define __STDC_WANT_MATH_SPEC_FUNCS__ 1
| #define _TANDEM_SOURCE 1
| #define __EXTENSIONS__ 1
| /* end confdefs.h.  */
| #include <ac_nonexistent.h>
configure:7702: result: gcc -E
configure:7716: gcc -E  conftest.c
configure:7716: $? = 0
configure:7731: gcc -E  conftest.c
conftest.c:60:10: fatal error: ac_nonexistent.h: No such file or directory
   60 | #include <ac_nonexistent.h>
      |          ^~~~~~~~~~~~~~~~~~
compilation terminated.
configure:7731: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "GNU Bison"
| #define PACKAGE_TARNAME "bison"
| #define PACKAGE_VERSION "3.8"
| #define PACKAGE_STRING "GNU Bison 3.8"
| #define PACKAGE_BUGREPORT "bug-bison@gnu.org"
| #define PACKAGE_URL "https://www.gnu.org/software/bison/"
| #define PACKAGE_COPYRIGHT_YEAR 2021
| #define PACKAGE "bison"
| #define VERSION "3.8"
| #define HAVE_STDIO_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_SOCKET_H 1
| #define HAVE_STDIO_EXT_H 1
| #define HAVE_FEATURES_H 1
| #define HAVE_GETOPT_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_CRTDEFS_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_THREADS_H 1
| #define HAVE_MATH_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_SPAWN_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_TIMES_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_TERMIOS_H 1
| #define HAVE_DIRENT_H 1
| #define STDC_HEADERS 1
| #define _ALL_SOURCE 1
| #define _DARWIN_C_SOURCE 1
| #define _GNU_SOURCE 1
| #define _HPUX_ALT_XOPEN_SOCKET_API 1
| #define _NETBSD_SOURCE 1
| #define _OPENBSD_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define __STDC_WANT_IEC_60559_ATTRIBS_EXT__ 1
| #define __STDC_WANT_IEC_60559_BFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_DFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_FUNCS_EXT__ 1
| #define __STDC_WANT_IEC_60559_TYPES_EXT__ 1
| #define __STDC_WANT_LIB_EXT2__ 1
| #define __STDC_WANT_MATH_SPEC_FUNCS__ 1
| #define _TANDEM_SOURCE 1
| #define __EXTENSIONS__ 1
| /* end confdefs.h.  */
| #include <ac_nonexistent.h>
configure:7762: checking for grep that handles long lines and -e
configure:7826: result: /usr/bin/grep
configure:7831: checking for egrep
configure:7899: result: /usr/bin/grep -E
configure:7907: checking for Minix Amsterdam compiler
configure:7933: result: no
configure:7995: checking for ar
configure:8016: found /usr/bin/ar
configure:8027: result: ar
configure:8107: checking for ranlib
configure:8128: found /usr/bin/ranlib
configure:8139: result: ranlib
configure:8203: checking for special C compiler options needed for large files
configure:8251: result: no
configure:8257: checking for _FILE_OFFSET_BITS value needed for large files
configure:8283: gcc -c -g -O2  conftest.c >&5
configure:8283: $? = 0
configure:8318: result: no
configure:8993: checking for ld used by gcc
configure:9121: result: /usr/x86_64-pc-cygwin/bin/ld.exe
configure:9128: checking if the linker (/usr/x86_64-pc-cygwin/bin/ld.exe) is GNU ld
configure:9144: result: yes
configure:9152: checking for shared library run path origin
configure:9166: result: done
configure:9188: checking 32-bit host C ABI
configure:9255: gcc -c -g -O2  conftest.c >&5
configure:9255: $? = 0
configure:9451: result: no
configure:9460: checking for ELF binary format
configure:9484: result: no
configure:9536: checking for the common suffixes of directories in the library search path
configure:9605: result: lib,lib,lib
configure:10144: checking for libtextstyle
configure:10167: gcc -o conftest.exe -g -O2   conftest.c  -ltextstyle >&5
conftest.c:60:10: fatal error: textstyle.h: No such file or directory
   60 | #include <textstyle.h>
      |          ^~~~~~~~~~~~~
compilation terminated.
configure:10167: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "GNU Bison"
| #define PACKAGE_TARNAME "bison"
| #define PACKAGE_VERSION "3.8"
| #define PACKAGE_STRING "GNU Bison 3.8"
| #define PACKAGE_BUGREPORT "bug-bison@gnu.org"
| #define PACKAGE_URL "https://www.gnu.org/software/bison/"
| #define PACKAGE_COPYRIGHT_YEAR 2021
| #define PACKAGE "bison"
| #define VERSION "3.8"
| #define HAVE_STDIO_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_SOCKET_H 1
| #define HAVE_STDIO_EXT_H 1
| #define HAVE_FEATURES_H 1
| #define HAVE_GETOPT_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_CRTDEFS_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_THREADS_H 1
| #define HAVE_MATH_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_SPAWN_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_TIMES_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_TERMIOS_H 1
| #define HAVE_DIRENT_H 1
| #define STDC_HEADERS 1
| #define _ALL_SOURCE 1
| #define _DARWIN_C_SOURCE 1
| #define _GNU_SOURCE 1
| #define _HPUX_ALT_XOPEN_SOCKET_API 1
| #define _NETBSD_SOURCE 1
| #define _OPENBSD_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define __STDC_WANT_IEC_60559_ATTRIBS_EXT__ 1
| #define __STDC_WANT_IEC_60559_BFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_DFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_FUNCS_EXT__ 1
| #define __STDC_WANT_IEC_60559_TYPES_EXT__ 1
| #define __STDC_WANT_LIB_EXT2__ 1
| #define __STDC_WANT_MATH_SPEC_FUNCS__ 1
| #define _TANDEM_SOURCE 1
| #define __EXTENSIONS__ 1
| /* end confdefs.h.  */
| #include <textstyle.h>
| int
| main (void)
| {
| styled_ostream_t s = term_styled_ostream_create(1,"",TTYCTL_AUTO,"");
|                ostream_printf(s,"%d",42);
|   ;
|   return 0;
| }
configure:10178: result: no
configure:10204: checking for inline
configure:10221: gcc -c -g -O2  conftest.c >&5
configure:10221: $? = 0
configure:10230: result: inline
configure:10252: checking for tcdrain
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for canonicalize_file_name
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for faccessat
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for realpath
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for lstat
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for readlinkat
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for _set_invalid_parameter_handler
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
/usr/lib/gcc/x86_64-pc-cygwin/11/../../../../x86_64-pc-cygwin/bin/ld: /tmp/cc4DaMDo.o: in function `main':
/cygdrive/c/source/HomeworldSDL/tools/kas2c/bison-3.8/conftest.c:93: undefined reference to `_set_invalid_parameter_handler'
collect2: error: ld returned 1 exit status
configure:10252: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "GNU Bison"
| #define PACKAGE_TARNAME "bison"
| #define PACKAGE_VERSION "3.8"
| #define PACKAGE_STRING "GNU Bison 3.8"
| #define PACKAGE_BUGREPORT "bug-bison@gnu.org"
| #define PACKAGE_URL "https://www.gnu.org/software/bison/"
| #define PACKAGE_COPYRIGHT_YEAR 2021
| #define PACKAGE "bison"
| #define VERSION "3.8"
| #define HAVE_STDIO_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_SOCKET_H 1
| #define HAVE_STDIO_EXT_H 1
| #define HAVE_FEATURES_H 1
| #define HAVE_GETOPT_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_CRTDEFS_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_THREADS_H 1
| #define HAVE_MATH_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_SPAWN_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_TIMES_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_TERMIOS_H 1
| #define HAVE_DIRENT_H 1
| #define STDC_HEADERS 1
| #define _ALL_SOURCE 1
| #define _DARWIN_C_SOURCE 1
| #define _GNU_SOURCE 1
| #define _HPUX_ALT_XOPEN_SOCKET_API 1
| #define _NETBSD_SOURCE 1
| #define _OPENBSD_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define __STDC_WANT_IEC_60559_ATTRIBS_EXT__ 1
| #define __STDC_WANT_IEC_60559_BFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_DFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_FUNCS_EXT__ 1
| #define __STDC_WANT_IEC_60559_TYPES_EXT__ 1
| #define __STDC_WANT_LIB_EXT2__ 1
| #define __STDC_WANT_MATH_SPEC_FUNCS__ 1
| #define _TANDEM_SOURCE 1
| #define __EXTENSIONS__ 1
| #define HAVE_TCDRAIN 1
| #define HAVE_CANONICALIZE_FILE_NAME 1
| #define HAVE_FACCESSAT 1
| #define HAVE_REALPATH 1
| #define HAVE_LSTAT 1
| #define HAVE_READLINKAT 1
| /* end confdefs.h.  */
| /* Define _set_invalid_parameter_handler to an innocuous variant, in case <limits.h> declares _set_invalid_parameter_handler.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define _set_invalid_parameter_handler innocuous__set_invalid_parameter_handler
| 
| /* System header to define __stub macros and hopefully few prototypes,
|    which can conflict with char _set_invalid_parameter_handler (); below.  */
| 
| #include <limits.h>
| #undef _set_invalid_parameter_handler
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char _set_invalid_parameter_handler ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub__set_invalid_parameter_handler || defined __stub____set_invalid_parameter_handler
| choke me
| #endif
| 
| int
| main (void)
| {
| return _set_invalid_parameter_handler ();
|   ;
|   return 0;
| }
configure:10252: result: no
configure:10252: checking for fchdir
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for fcntl
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for symlink
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for ffsl
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
conftest.c:85:6: warning: conflicting types for built-in function 'ffsl'; expected 'int(long int)' [-Wbuiltin-declaration-mismatch]
   85 | char ffsl ();
      |      ^~~~
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for vasnprintf
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for snprintf
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
conftest.c:87:6: warning: conflicting types for built-in function 'snprintf'; expected 'int(char *, long unsigned int,  const char *, ...)' [-Wbuiltin-declaration-mismatch]
   87 | char snprintf ();
      |      ^~~~~~~~
conftest.c:79:1: note: 'snprintf' is declared in header '<stdio.h>'
   78 | #include <limits.h>
   79 | #undef snprintf
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for fsync
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for microuptime
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
/usr/lib/gcc/x86_64-pc-cygwin/11/../../../../x86_64-pc-cygwin/bin/ld: /tmp/cceI4Sfo.o: in function `main':
/cygdrive/c/source/HomeworldSDL/tools/kas2c/bison-3.8/conftest.c:100: undefined reference to `microuptime'
collect2: error: ld returned 1 exit status
configure:10252: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "GNU Bison"
| #define PACKAGE_TARNAME "bison"
| #define PACKAGE_VERSION "3.8"
| #define PACKAGE_STRING "GNU Bison 3.8"
| #define PACKAGE_BUGREPORT "bug-bison@gnu.org"
| #define PACKAGE_URL "https://www.gnu.org/software/bison/"
| #define PACKAGE_COPYRIGHT_YEAR 2021
| #define PACKAGE "bison"
| #define VERSION "3.8"
| #define HAVE_STDIO_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_SOCKET_H 1
| #define HAVE_STDIO_EXT_H 1
| #define HAVE_FEATURES_H 1
| #define HAVE_GETOPT_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_CRTDEFS_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_THREADS_H 1
| #define HAVE_MATH_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_SPAWN_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_TIMES_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_TERMIOS_H 1
| #define HAVE_DIRENT_H 1
| #define STDC_HEADERS 1
| #define _ALL_SOURCE 1
| #define _DARWIN_C_SOURCE 1
| #define _GNU_SOURCE 1
| #define _HPUX_ALT_XOPEN_SOCKET_API 1
| #define _NETBSD_SOURCE 1
| #define _OPENBSD_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define __STDC_WANT_IEC_60559_ATTRIBS_EXT__ 1
| #define __STDC_WANT_IEC_60559_BFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_DFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_FUNCS_EXT__ 1
| #define __STDC_WANT_IEC_60559_TYPES_EXT__ 1
| #define __STDC_WANT_LIB_EXT2__ 1
| #define __STDC_WANT_MATH_SPEC_FUNCS__ 1
| #define _TANDEM_SOURCE 1
| #define __EXTENSIONS__ 1
| #define HAVE_TCDRAIN 1
| #define HAVE_CANONICALIZE_FILE_NAME 1
| #define HAVE_FACCESSAT 1
| #define HAVE_REALPATH 1
| #define HAVE_LSTAT 1
| #define HAVE_READLINKAT 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCNTL 1
| #define HAVE_SYMLINK 1
| #define HAVE_FFSL 1
| #define HAVE_VASNPRINTF 1
| #define HAVE_SNPRINTF 1
| #define HAVE_FSYNC 1
| /* end confdefs.h.  */
| /* Define microuptime to an innocuous variant, in case <limits.h> declares microuptime.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define microuptime innocuous_microuptime
| 
| /* System header to define __stub macros and hopefully few prototypes,
|    which can conflict with char microuptime (); below.  */
| 
| #include <limits.h>
| #undef microuptime
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char microuptime ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_microuptime || defined __stub___microuptime
| choke me
| #endif
| 
| int
| main (void)
| {
| return microuptime ();
|   ;
|   return 0;
| }
configure:10252: result: no
configure:10252: checking for nanouptime
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
/usr/lib/gcc/x86_64-pc-cygwin/11/../../../../x86_64-pc-cygwin/bin/ld: /tmp/ccBeHPNp.o: in function `main':
/cygdrive/c/source/HomeworldSDL/tools/kas2c/bison-3.8/conftest.c:100: undefined reference to `nanouptime'
collect2: error: ld returned 1 exit status
configure:10252: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "GNU Bison"
| #define PACKAGE_TARNAME "bison"
| #define PACKAGE_VERSION "3.8"
| #define PACKAGE_STRING "GNU Bison 3.8"
| #define PACKAGE_BUGREPORT "bug-bison@gnu.org"
| #define PACKAGE_URL "https://www.gnu.org/software/bison/"
| #define PACKAGE_COPYRIGHT_YEAR 2021
| #define PACKAGE "bison"
| #define VERSION "3.8"
| #define HAVE_STDIO_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_SOCKET_H 1
| #define HAVE_STDIO_EXT_H 1
| #define HAVE_FEATURES_H 1
| #define HAVE_GETOPT_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_CRTDEFS_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_THREADS_H 1
| #define HAVE_MATH_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_SPAWN_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_TIMES_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_TERMIOS_H 1
| #define HAVE_DIRENT_H 1
| #define STDC_HEADERS 1
| #define _ALL_SOURCE 1
| #define _DARWIN_C_SOURCE 1
| #define _GNU_SOURCE 1
| #define _HPUX_ALT_XOPEN_SOCKET_API 1
| #define _NETBSD_SOURCE 1
| #define _OPENBSD_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define __STDC_WANT_IEC_60559_ATTRIBS_EXT__ 1
| #define __STDC_WANT_IEC_60559_BFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_DFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_FUNCS_EXT__ 1
| #define __STDC_WANT_IEC_60559_TYPES_EXT__ 1
| #define __STDC_WANT_LIB_EXT2__ 1
| #define __STDC_WANT_MATH_SPEC_FUNCS__ 1
| #define _TANDEM_SOURCE 1
| #define __EXTENSIONS__ 1
| #define HAVE_TCDRAIN 1
| #define HAVE_CANONICALIZE_FILE_NAME 1
| #define HAVE_FACCESSAT 1
| #define HAVE_REALPATH 1
| #define HAVE_LSTAT 1
| #define HAVE_READLINKAT 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCNTL 1
| #define HAVE_SYMLINK 1
| #define HAVE_FFSL 1
| #define HAVE_VASNPRINTF 1
| #define HAVE_SNPRINTF 1
| #define HAVE_FSYNC 1
| /* end confdefs.h.  */
| /* Define nanouptime to an innocuous variant, in case <limits.h> declares nanouptime.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define nanouptime innocuous_nanouptime
| 
| /* System header to define __stub macros and hopefully few prototypes,
|    which can conflict with char nanouptime (); below.  */
| 
| #include <limits.h>
| #undef nanouptime
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char nanouptime ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_nanouptime || defined __stub___nanouptime
| choke me
| #endif
| 
| int
| main (void)
| {
| return nanouptime ();
|   ;
|   return 0;
| }
configure:10252: result: no
configure:10252: checking for getprogname
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for getexecname
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
/usr/lib/gcc/x86_64-pc-cygwin/11/../../../../x86_64-pc-cygwin/bin/ld: /tmp/ccNZMEkq.o: in function `main':
/cygdrive/c/source/HomeworldSDL/tools/kas2c/bison-3.8/conftest.c:101: undefined reference to `getexecname'
collect2: error: ld returned 1 exit status
configure:10252: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "GNU Bison"
| #define PACKAGE_TARNAME "bison"
| #define PACKAGE_VERSION "3.8"
| #define PACKAGE_STRING "GNU Bison 3.8"
| #define PACKAGE_BUGREPORT "bug-bison@gnu.org"
| #define PACKAGE_URL "https://www.gnu.org/software/bison/"
| #define PACKAGE_COPYRIGHT_YEAR 2021
| #define PACKAGE "bison"
| #define VERSION "3.8"
| #define HAVE_STDIO_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_SOCKET_H 1
| #define HAVE_STDIO_EXT_H 1
| #define HAVE_FEATURES_H 1
| #define HAVE_GETOPT_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_CRTDEFS_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_THREADS_H 1
| #define HAVE_MATH_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_SPAWN_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_TIMES_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_TERMIOS_H 1
| #define HAVE_DIRENT_H 1
| #define STDC_HEADERS 1
| #define _ALL_SOURCE 1
| #define _DARWIN_C_SOURCE 1
| #define _GNU_SOURCE 1
| #define _HPUX_ALT_XOPEN_SOCKET_API 1
| #define _NETBSD_SOURCE 1
| #define _OPENBSD_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define __STDC_WANT_IEC_60559_ATTRIBS_EXT__ 1
| #define __STDC_WANT_IEC_60559_BFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_DFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_FUNCS_EXT__ 1
| #define __STDC_WANT_IEC_60559_TYPES_EXT__ 1
| #define __STDC_WANT_LIB_EXT2__ 1
| #define __STDC_WANT_MATH_SPEC_FUNCS__ 1
| #define _TANDEM_SOURCE 1
| #define __EXTENSIONS__ 1
| #define HAVE_TCDRAIN 1
| #define HAVE_CANONICALIZE_FILE_NAME 1
| #define HAVE_FACCESSAT 1
| #define HAVE_REALPATH 1
| #define HAVE_LSTAT 1
| #define HAVE_READLINKAT 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCNTL 1
| #define HAVE_SYMLINK 1
| #define HAVE_FFSL 1
| #define HAVE_VASNPRINTF 1
| #define HAVE_SNPRINTF 1
| #define HAVE_FSYNC 1
| #define HAVE_GETPROGNAME 1
| /* end confdefs.h.  */
| /* Define getexecname to an innocuous variant, in case <limits.h> declares getexecname.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define getexecname innocuous_getexecname
| 
| /* System header to define __stub macros and hopefully few prototypes,
|    which can conflict with char getexecname (); below.  */
| 
| #include <limits.h>
| #undef getexecname
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char getexecname ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_getexecname || defined __stub___getexecname
| choke me
| #endif
| 
| int
| main (void)
| {
| return getexecname ();
|   ;
|   return 0;
| }
configure:10252: result: no
configure:10252: checking for getrusage
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for gettimeofday
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for iswcntrl
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
conftest.c:92:6: warning: conflicting types for built-in function 'iswcntrl'; expected 'int(unsigned int)' [-Wbuiltin-declaration-mismatch]
   92 | char iswcntrl ();
      |      ^~~~~~~~
conftest.c:84:1: note: 'iswcntrl' is declared in header '<wctype.h>'
   83 | #include <limits.h>
   84 | #undef iswcntrl
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for iswblank
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
conftest.c:93:6: warning: conflicting types for built-in function 'iswblank'; expected 'int(unsigned int)' [-Wbuiltin-declaration-mismatch]
   93 | char iswblank ();
      |      ^~~~~~~~
conftest.c:85:1: note: 'iswblank' is declared in header '<wctype.h>'
   84 | #include <limits.h>
   85 | #undef iswblank
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for mbsinit
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for mbrtowc
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for isascii
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
conftest.c:96:6: warning: conflicting types for built-in function 'isascii'; expected 'int(int)' [-Wbuiltin-declaration-mismatch]
   96 | char isascii ();
      |      ^~~~~~~
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for mprotect
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for obstack_printf
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
/usr/lib/gcc/x86_64-pc-cygwin/11/../../../../x86_64-pc-cygwin/bin/ld: /tmp/cc1VAANy.o: in function `main':
/cygdrive/c/source/HomeworldSDL/tools/kas2c/bison-3.8/conftest.c:109: undefined reference to `obstack_printf'
collect2: error: ld returned 1 exit status
configure:10252: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "GNU Bison"
| #define PACKAGE_TARNAME "bison"
| #define PACKAGE_VERSION "3.8"
| #define PACKAGE_STRING "GNU Bison 3.8"
| #define PACKAGE_BUGREPORT "bug-bison@gnu.org"
| #define PACKAGE_URL "https://www.gnu.org/software/bison/"
| #define PACKAGE_COPYRIGHT_YEAR 2021
| #define PACKAGE "bison"
| #define VERSION "3.8"
| #define HAVE_STDIO_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_SOCKET_H 1
| #define HAVE_STDIO_EXT_H 1
| #define HAVE_FEATURES_H 1
| #define HAVE_GETOPT_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_CRTDEFS_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_THREADS_H 1
| #define HAVE_MATH_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_SPAWN_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_TIMES_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_TERMIOS_H 1
| #define HAVE_DIRENT_H 1
| #define STDC_HEADERS 1
| #define _ALL_SOURCE 1
| #define _DARWIN_C_SOURCE 1
| #define _GNU_SOURCE 1
| #define _HPUX_ALT_XOPEN_SOCKET_API 1
| #define _NETBSD_SOURCE 1
| #define _OPENBSD_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define __STDC_WANT_IEC_60559_ATTRIBS_EXT__ 1
| #define __STDC_WANT_IEC_60559_BFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_DFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_FUNCS_EXT__ 1
| #define __STDC_WANT_IEC_60559_TYPES_EXT__ 1
| #define __STDC_WANT_LIB_EXT2__ 1
| #define __STDC_WANT_MATH_SPEC_FUNCS__ 1
| #define _TANDEM_SOURCE 1
| #define __EXTENSIONS__ 1
| #define HAVE_TCDRAIN 1
| #define HAVE_CANONICALIZE_FILE_NAME 1
| #define HAVE_FACCESSAT 1
| #define HAVE_REALPATH 1
| #define HAVE_LSTAT 1
| #define HAVE_READLINKAT 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCNTL 1
| #define HAVE_SYMLINK 1
| #define HAVE_FFSL 1
| #define HAVE_VASNPRINTF 1
| #define HAVE_SNPRINTF 1
| #define HAVE_FSYNC 1
| #define HAVE_GETPROGNAME 1
| #define HAVE_GETRUSAGE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_ISWCNTRL 1
| #define HAVE_ISWBLANK 1
| #define HAVE_MBSINIT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_ISASCII 1
| #define HAVE_MPROTECT 1
| /* end confdefs.h.  */
| /* Define obstack_printf to an innocuous variant, in case <limits.h> declares obstack_printf.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define obstack_printf innocuous_obstack_printf
| 
| /* System header to define __stub macros and hopefully few prototypes,
|    which can conflict with char obstack_printf (); below.  */
| 
| #include <limits.h>
| #undef obstack_printf
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char obstack_printf ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_obstack_printf || defined __stub___obstack_printf
| choke me
| #endif
| 
| int
| main (void)
| {
| return obstack_printf ();
|   ;
|   return 0;
| }
configure:10252: result: no
configure:10252: checking for strerror_r
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for __xpg_strerror_r
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for pipe
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for pipe2
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for posix_spawn_file_actions_addchdir_np
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
/usr/lib/gcc/x86_64-pc-cygwin/11/../../../../x86_64-pc-cygwin/bin/ld: /tmp/ccomAHk4.o: in function `main':
/cygdrive/c/source/HomeworldSDL/tools/kas2c/bison-3.8/conftest.c:113: undefined reference to `posix_spawn_file_actions_addchdir_np'
collect2: error: ld returned 1 exit status
configure:10252: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "GNU Bison"
| #define PACKAGE_TARNAME "bison"
| #define PACKAGE_VERSION "3.8"
| #define PACKAGE_STRING "GNU Bison 3.8"
| #define PACKAGE_BUGREPORT "bug-bison@gnu.org"
| #define PACKAGE_URL "https://www.gnu.org/software/bison/"
| #define PACKAGE_COPYRIGHT_YEAR 2021
| #define PACKAGE "bison"
| #define VERSION "3.8"
| #define HAVE_STDIO_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_SOCKET_H 1
| #define HAVE_STDIO_EXT_H 1
| #define HAVE_FEATURES_H 1
| #define HAVE_GETOPT_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_CRTDEFS_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_THREADS_H 1
| #define HAVE_MATH_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_SPAWN_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_TIMES_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_TERMIOS_H 1
| #define HAVE_DIRENT_H 1
| #define STDC_HEADERS 1
| #define _ALL_SOURCE 1
| #define _DARWIN_C_SOURCE 1
| #define _GNU_SOURCE 1
| #define _HPUX_ALT_XOPEN_SOCKET_API 1
| #define _NETBSD_SOURCE 1
| #define _OPENBSD_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define __STDC_WANT_IEC_60559_ATTRIBS_EXT__ 1
| #define __STDC_WANT_IEC_60559_BFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_DFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_FUNCS_EXT__ 1
| #define __STDC_WANT_IEC_60559_TYPES_EXT__ 1
| #define __STDC_WANT_LIB_EXT2__ 1
| #define __STDC_WANT_MATH_SPEC_FUNCS__ 1
| #define _TANDEM_SOURCE 1
| #define __EXTENSIONS__ 1
| #define HAVE_TCDRAIN 1
| #define HAVE_CANONICALIZE_FILE_NAME 1
| #define HAVE_FACCESSAT 1
| #define HAVE_REALPATH 1
| #define HAVE_LSTAT 1
| #define HAVE_READLINKAT 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCNTL 1
| #define HAVE_SYMLINK 1
| #define HAVE_FFSL 1
| #define HAVE_VASNPRINTF 1
| #define HAVE_SNPRINTF 1
| #define HAVE_FSYNC 1
| #define HAVE_GETPROGNAME 1
| #define HAVE_GETRUSAGE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_ISWCNTRL 1
| #define HAVE_ISWBLANK 1
| #define HAVE_MBSINIT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_ISASCII 1
| #define HAVE_MPROTECT 1
| #define HAVE_STRERROR_R 1
| #define HAVE___XPG_STRERROR_R 1
| #define HAVE_PIPE 1
| #define HAVE_PIPE2 1
| /* end confdefs.h.  */
| /* Define posix_spawn_file_actions_addchdir_np to an innocuous variant, in case <limits.h> declares posix_spawn_file_actions_addchdir_np.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define posix_spawn_file_actions_addchdir_np innocuous_posix_spawn_file_actions_addchdir_np
| 
| /* System header to define __stub macros and hopefully few prototypes,
|    which can conflict with char posix_spawn_file_actions_addchdir_np (); below.  */
| 
| #include <limits.h>
| #undef posix_spawn_file_actions_addchdir_np
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char posix_spawn_file_actions_addchdir_np ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_posix_spawn_file_actions_addchdir_np || defined __stub___posix_spawn_file_actions_addchdir_np
| choke me
| #endif
| 
| int
| main (void)
| {
| return posix_spawn_file_actions_addchdir_np ();
|   ;
|   return 0;
| }
configure:10252: result: no
configure:10252: checking for posix_spawn_file_actions_addchdir
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
/usr/lib/gcc/x86_64-pc-cygwin/11/../../../../x86_64-pc-cygwin/bin/ld: /tmp/ccDNGwnc.o: in function `main':
/cygdrive/c/source/HomeworldSDL/tools/kas2c/bison-3.8/conftest.c:113: undefined reference to `posix_spawn_file_actions_addchdir'
collect2: error: ld returned 1 exit status
configure:10252: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "GNU Bison"
| #define PACKAGE_TARNAME "bison"
| #define PACKAGE_VERSION "3.8"
| #define PACKAGE_STRING "GNU Bison 3.8"
| #define PACKAGE_BUGREPORT "bug-bison@gnu.org"
| #define PACKAGE_URL "https://www.gnu.org/software/bison/"
| #define PACKAGE_COPYRIGHT_YEAR 2021
| #define PACKAGE "bison"
| #define VERSION "3.8"
| #define HAVE_STDIO_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_SOCKET_H 1
| #define HAVE_STDIO_EXT_H 1
| #define HAVE_FEATURES_H 1
| #define HAVE_GETOPT_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_CRTDEFS_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_THREADS_H 1
| #define HAVE_MATH_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_SPAWN_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_TIMES_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_TERMIOS_H 1
| #define HAVE_DIRENT_H 1
| #define STDC_HEADERS 1
| #define _ALL_SOURCE 1
| #define _DARWIN_C_SOURCE 1
| #define _GNU_SOURCE 1
| #define _HPUX_ALT_XOPEN_SOCKET_API 1
| #define _NETBSD_SOURCE 1
| #define _OPENBSD_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define __STDC_WANT_IEC_60559_ATTRIBS_EXT__ 1
| #define __STDC_WANT_IEC_60559_BFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_DFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_FUNCS_EXT__ 1
| #define __STDC_WANT_IEC_60559_TYPES_EXT__ 1
| #define __STDC_WANT_LIB_EXT2__ 1
| #define __STDC_WANT_MATH_SPEC_FUNCS__ 1
| #define _TANDEM_SOURCE 1
| #define __EXTENSIONS__ 1
| #define HAVE_TCDRAIN 1
| #define HAVE_CANONICALIZE_FILE_NAME 1
| #define HAVE_FACCESSAT 1
| #define HAVE_REALPATH 1
| #define HAVE_LSTAT 1
| #define HAVE_READLINKAT 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCNTL 1
| #define HAVE_SYMLINK 1
| #define HAVE_FFSL 1
| #define HAVE_VASNPRINTF 1
| #define HAVE_SNPRINTF 1
| #define HAVE_FSYNC 1
| #define HAVE_GETPROGNAME 1
| #define HAVE_GETRUSAGE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_ISWCNTRL 1
| #define HAVE_ISWBLANK 1
| #define HAVE_MBSINIT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_ISASCII 1
| #define HAVE_MPROTECT 1
| #define HAVE_STRERROR_R 1
| #define HAVE___XPG_STRERROR_R 1
| #define HAVE_PIPE 1
| #define HAVE_PIPE2 1
| /* end confdefs.h.  */
| /* Define posix_spawn_file_actions_addchdir to an innocuous variant, in case <limits.h> declares posix_spawn_file_actions_addchdir.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define posix_spawn_file_actions_addchdir innocuous_posix_spawn_file_actions_addchdir
| 
| /* System header to define __stub macros and hopefully few prototypes,
|    which can conflict with char posix_spawn_file_actions_addchdir (); below.  */
| 
| #include <limits.h>
| #undef posix_spawn_file_actions_addchdir
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char posix_spawn_file_actions_addchdir ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_posix_spawn_file_actions_addchdir || defined __stub___posix_spawn_file_actions_addchdir
| choke me
| #endif
| 
| int
| main (void)
| {
| return posix_spawn_file_actions_addchdir ();
|   ;
|   return 0;
| }
configure:10252: result: no
configure:10252: checking for readlink
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for setenv
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for link
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for sigaction
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for sigaltstack
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for siginterrupt
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for stpncpy
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
conftest.c:108:6: warning: conflicting types for built-in function 'stpncpy'; expected 'char *(char *, const char *, long unsigned int)' [-Wbuiltin-declaration-mismatch]
  108 | char stpncpy ();
      |      ^~~~~~~
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for strndup
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
conftest.c:109:6: warning: conflicting types for built-in function 'strndup'; expected 'char *(const char *, long unsigned int)' [-Wbuiltin-declaration-mismatch]
  109 | char strndup ();
      |      ^~~~~~~
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for wcwidth
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for fdopendir
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for mempcpy
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
conftest.c:112:6: warning: conflicting types for built-in function 'mempcpy'; expected 'void *(void *, const void *, long unsigned int)' [-Wbuiltin-declaration-mismatch]
  112 | char mempcpy ();
      |      ^~~~~~~
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for __fseterr
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
/usr/lib/gcc/x86_64-pc-cygwin/11/../../../../x86_64-pc-cygwin/bin/ld: /tmp/cczMo5UP.o: in function `main':
/cygdrive/c/source/HomeworldSDL/tools/kas2c/bison-3.8/conftest.c:124: undefined reference to `__fseterr'
collect2: error: ld returned 1 exit status
configure:10252: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "GNU Bison"
| #define PACKAGE_TARNAME "bison"
| #define PACKAGE_VERSION "3.8"
| #define PACKAGE_STRING "GNU Bison 3.8"
| #define PACKAGE_BUGREPORT "bug-bison@gnu.org"
| #define PACKAGE_URL "https://www.gnu.org/software/bison/"
| #define PACKAGE_COPYRIGHT_YEAR 2021
| #define PACKAGE "bison"
| #define VERSION "3.8"
| #define HAVE_STDIO_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_SOCKET_H 1
| #define HAVE_STDIO_EXT_H 1
| #define HAVE_FEATURES_H 1
| #define HAVE_GETOPT_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_CRTDEFS_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_THREADS_H 1
| #define HAVE_MATH_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_SPAWN_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_TIMES_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_TERMIOS_H 1
| #define HAVE_DIRENT_H 1
| #define STDC_HEADERS 1
| #define _ALL_SOURCE 1
| #define _DARWIN_C_SOURCE 1
| #define _GNU_SOURCE 1
| #define _HPUX_ALT_XOPEN_SOCKET_API 1
| #define _NETBSD_SOURCE 1
| #define _OPENBSD_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define __STDC_WANT_IEC_60559_ATTRIBS_EXT__ 1
| #define __STDC_WANT_IEC_60559_BFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_DFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_FUNCS_EXT__ 1
| #define __STDC_WANT_IEC_60559_TYPES_EXT__ 1
| #define __STDC_WANT_LIB_EXT2__ 1
| #define __STDC_WANT_MATH_SPEC_FUNCS__ 1
| #define _TANDEM_SOURCE 1
| #define __EXTENSIONS__ 1
| #define HAVE_TCDRAIN 1
| #define HAVE_CANONICALIZE_FILE_NAME 1
| #define HAVE_FACCESSAT 1
| #define HAVE_REALPATH 1
| #define HAVE_LSTAT 1
| #define HAVE_READLINKAT 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCNTL 1
| #define HAVE_SYMLINK 1
| #define HAVE_FFSL 1
| #define HAVE_VASNPRINTF 1
| #define HAVE_SNPRINTF 1
| #define HAVE_FSYNC 1
| #define HAVE_GETPROGNAME 1
| #define HAVE_GETRUSAGE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_ISWCNTRL 1
| #define HAVE_ISWBLANK 1
| #define HAVE_MBSINIT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_ISASCII 1
| #define HAVE_MPROTECT 1
| #define HAVE_STRERROR_R 1
| #define HAVE___XPG_STRERROR_R 1
| #define HAVE_PIPE 1
| #define HAVE_PIPE2 1
| #define HAVE_READLINK 1
| #define HAVE_SETENV 1
| #define HAVE_LINK 1
| #define HAVE_SIGACTION 1
| #define HAVE_SIGALTSTACK 1
| #define HAVE_SIGINTERRUPT 1
| #define HAVE_STPNCPY 1
| #define HAVE_STRNDUP 1
| #define HAVE_WCWIDTH 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_MEMPCPY 1
| /* end confdefs.h.  */
| /* Define __fseterr to an innocuous variant, in case <limits.h> declares __fseterr.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define __fseterr innocuous___fseterr
| 
| /* System header to define __stub macros and hopefully few prototypes,
|    which can conflict with char __fseterr (); below.  */
| 
| #include <limits.h>
| #undef __fseterr
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char __fseterr ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub___fseterr || defined __stub_____fseterr
| choke me
| #endif
| 
| int
| main (void)
| {
| return __fseterr ();
|   ;
|   return 0;
| }
configure:10252: result: no
configure:10252: checking for fstatat
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for getdelim
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for getdtablesize
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for openat
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for catgets
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10252: checking for setlocale
configure:10252: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:10252: $? = 0
configure:10252: result: yes
configure:10290: checking whether pragma GCC diagnostic push works
configure:10313: gcc -c -Wunknown-pragmas -Werror  conftest.c >&5
configure:10313: $? = 0
configure:10322: result: yes
configure:10340: checking whether C++ compiler handles -Werror -Wunknown-warning-option
configure:10360: g++ -o conftest.exe -g -O2  -Werror -Wunknown-warning-option   conftest.cpp  >&5
g++: error: unrecognized command-line option '-Wunknown-warning-option'
configure:10360: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "GNU Bison"
| #define PACKAGE_TARNAME "bison"
| #define PACKAGE_VERSION "3.8"
| #define PACKAGE_STRING "GNU Bison 3.8"
| #define PACKAGE_BUGREPORT "bug-bison@gnu.org"
| #define PACKAGE_URL "https://www.gnu.org/software/bison/"
| #define PACKAGE_COPYRIGHT_YEAR 2021
| #define PACKAGE "bison"
| #define VERSION "3.8"
| #define HAVE_STDIO_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_SOCKET_H 1
| #define HAVE_STDIO_EXT_H 1
| #define HAVE_FEATURES_H 1
| #define HAVE_GETOPT_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_CRTDEFS_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_THREADS_H 1
| #define HAVE_MATH_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_SPAWN_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_TIMES_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_TERMIOS_H 1
| #define HAVE_DIRENT_H 1
| #define STDC_HEADERS 1
| #define _ALL_SOURCE 1
| #define _DARWIN_C_SOURCE 1
| #define _GNU_SOURCE 1
| #define _HPUX_ALT_XOPEN_SOCKET_API 1
| #define _NETBSD_SOURCE 1
| #define _OPENBSD_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define __STDC_WANT_IEC_60559_ATTRIBS_EXT__ 1
| #define __STDC_WANT_IEC_60559_BFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_DFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_FUNCS_EXT__ 1
| #define __STDC_WANT_IEC_60559_TYPES_EXT__ 1
| #define __STDC_WANT_LIB_EXT2__ 1
| #define __STDC_WANT_MATH_SPEC_FUNCS__ 1
| #define _TANDEM_SOURCE 1
| #define __EXTENSIONS__ 1
| #define HAVE_TCDRAIN 1
| #define HAVE_CANONICALIZE_FILE_NAME 1
| #define HAVE_FACCESSAT 1
| #define HAVE_REALPATH 1
| #define HAVE_LSTAT 1
| #define HAVE_READLINKAT 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCNTL 1
| #define HAVE_SYMLINK 1
| #define HAVE_FFSL 1
| #define HAVE_VASNPRINTF 1
| #define HAVE_SNPRINTF 1
| #define HAVE_FSYNC 1
| #define HAVE_GETPROGNAME 1
| #define HAVE_GETRUSAGE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_ISWCNTRL 1
| #define HAVE_ISWBLANK 1
| #define HAVE_MBSINIT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_ISASCII 1
| #define HAVE_MPROTECT 1
| #define HAVE_STRERROR_R 1
| #define HAVE___XPG_STRERROR_R 1
| #define HAVE_PIPE 1
| #define HAVE_PIPE2 1
| #define HAVE_READLINK 1
| #define HAVE_SETENV 1
| #define HAVE_LINK 1
| #define HAVE_SIGACTION 1
| #define HAVE_SIGALTSTACK 1
| #define HAVE_SIGINTERRUPT 1
| #define HAVE_STPNCPY 1
| #define HAVE_STRNDUP 1
| #define HAVE_WCWIDTH 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_MEMPCPY 1
| #define HAVE_FSTATAT 1
| #define HAVE_GETDELIM 1
| #define HAVE_GETDTABLESIZE 1
| #define HAVE_OPENAT 1
| #define HAVE_CATGETS 1
| #define HAVE_SETLOCALE 1
| /* end confdefs.h.  */
| 
| int
| main (void)
| {
| 
|   ;
|   return 0;
| }
configure:10371: result: no
configure:10389: checking whether C++ compiler handles -fno-exceptions
configure:10409: g++ -o conftest.exe -g -O2  -fno-exceptions   conftest.cpp  >&5
configure:10409: $? = 0
configure:10420: result: yes
configure:10438: checking whether C++ compiler accepts -std=c++98
configure:10460: g++ -o conftest.exe -g -O2  -std=c++98   conftest.cpp  >&5
configure:10460: $? = 0
configure:10471: result: yes
configure:10497: checking whether C++ compiler accepts -std=c++03
configure:10520: g++ -o conftest.exe -g -O2  -std=c++03   conftest.cpp  >&5
configure:10520: $? = 0
configure:10531: result: yes
configure:10557: checking whether C++ compiler accepts -std=c++11
configure:10650: g++ -o conftest.exe -g -O2  -std=c++11   conftest.cpp  >&5
configure:10650: $? = 0
configure:10661: result: yes
configure:10687: checking whether C++ compiler accepts -std=c++14
configure:10790: g++ -o conftest.exe -g -O2  -std=c++14   conftest.cpp  >&5
configure:10790: $? = 0
configure:10801: result: yes
configure:10827: checking whether C++ compiler accepts -std=c++17
configure:10937: g++ -o conftest.exe -g -O2  -std=c++17   conftest.cpp  >&5
configure:10937: $? = 0
configure:10948: result: yes
configure:10974: checking whether C++ compiler accepts -std=c++20
configure:11086: g++ -o conftest.exe -g -O2  -std=c++20   conftest.cpp  >&5
configure:11086: $? = 0
configure:11097: result: yes
configure:11123: checking whether C++ compiler accepts -std=c++2b
configure:11237: g++ -o conftest.exe -g -O2  -std=c++2b   conftest.cpp  >&5
configure:11237: $? = 0
configure:11248: result: yes
configure:12107: gcc -c -g -O2  conftest.c >&5
configure:12107: $? = 0
configure:12126: checking whether gcc supports POSIXLY_CORRECT=1
configure:12151: gcc -o conftest.exe -g -O2   conftest.c  >&5
configure:12151: $? = 0
configure:12166: result: yes
configure:12183: checking whether g++ builds executables that work
configure:12220: g++ -c -g -O2  conftest.cpp >&5
configure:12220: $? = 0
configure:12223: g++ -o conftest.exe -g -O2   conftest.o  >&5
configure:12226: $? = 0
configure:12234: ./conftest.exe
configure:12237: $? = 0
configure:12254: result: yes
configure:12278: checking whether g++ supports POSIXLY_CORRECT=1
configure:12303: g++ -o conftest.exe -g -O2   conftest.cpp  >&5
configure:12303: $? = 0
configure:12318: result: yes
configure:12340: checking for dmd
configure:12375: result: no
configure:12387: checking for -g
configure:12422: result: no
configure:12512: checking for Java compiler
configure:12768: found /cygdrive/c/Program Files/Microsoft/jdk-11.0.16.101-hotspot/bin/javac
configure:12919: javac -d . conftest.java
configure:12948: javac -target 1.7 -d . conftest.java
warning: target release 1.7 conflicts with default source release 11
configure:12977: javac -target 1.7 -source 1.7 -d . conftest.java
warning: [options] bootstrap class path not set in conjunction with -source 7
1 warning
configure:13014: result: javac -target 1.7 -source 1.7
configure:13025: checking for Java virtual machine
configure:13116: found /cygdrive/c/Program Files/Microsoft/jdk-11.0.16.101-hotspot/bin/java
configure:13249: result: java
configure:13297: checking for flex
configure:13318: found /cygdrive/c/source/homeworld/tools/bin/flex
configure:13329: result: flex
configure:13342: checking whether lex is flex
configure:13359: flex conftest.l
"conftest.l", line 5: warning, -s option given but default rule can be matched
configure:13363: $? = 0
configure:13371: result: yes
configure:13375: checking whether flex supports --header=FILE
configure:13386: flex --header=conftest.h conftest.l
C:\source\homeworld\tools\bin\flex.exe: unknown flag '-'.  For usage, try
	C:\source\homeworld\tools\bin\flex.exe --help
configure:13390: $? = 1
configure:13398: result: no
configure:13432: flex conftest.l
configure:13436: $? = 0
configure:13438: checking lex output file root
configure:13453: result: lex.yy
configure:13458: checking lex library
configure:13473: gcc -o conftest.exe -g -O2   conftest.c   >&5
/usr/lib/gcc/x86_64-pc-cygwin/11/../../../../x86_64-pc-cygwin/bin/ld: /tmp/ccjWzBt2.o: in function `input':
/cygdrive/c/source/HomeworldSDL/tools/kas2c/bison-3.8/lex.yy.c:1060: undefined reference to `yywrap'
/usr/lib/gcc/x86_64-pc-cygwin/11/../../../../x86_64-pc-cygwin/bin/ld: /tmp/ccjWzBt2.o: in function `yylex':
/cygdrive/c/source/HomeworldSDL/tools/kas2c/bison-3.8/lex.yy.c:737: undefined reference to `yywrap'
/usr/lib/gcc/x86_64-pc-cygwin/11/../../../../x86_64-pc-cygwin/bin/ld: /tmp/ccjWzBt2.o: in function `main':
/cygdrive/c/source/HomeworldSDL/tools/kas2c/bison-3.8/conftest.l:17: undefined reference to `yywrap'
collect2: error: ld returned 1 exit status
configure:13473: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "GNU Bison"
| #define PACKAGE_TARNAME "bison"
| #define PACKAGE_VERSION "3.8"
| #define PACKAGE_STRING "GNU Bison 3.8"
| #define PACKAGE_BUGREPORT "bug-bison@gnu.org"
| #define PACKAGE_URL "https://www.gnu.org/software/bison/"
| #define PACKAGE_COPYRIGHT_YEAR 2021
| #define PACKAGE "bison"
| #define VERSION "3.8"
| #define HAVE_STDIO_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_SOCKET_H 1
| #define HAVE_STDIO_EXT_H 1
| #define HAVE_FEATURES_H 1
| #define HAVE_GETOPT_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_CRTDEFS_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_THREADS_H 1
| #define HAVE_MATH_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_SPAWN_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_TIMES_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_TERMIOS_H 1
| #define HAVE_DIRENT_H 1
| #define STDC_HEADERS 1
| #define _ALL_SOURCE 1
| #define _DARWIN_C_SOURCE 1
| #define _GNU_SOURCE 1
| #define _HPUX_ALT_XOPEN_SOCKET_API 1
| #define _NETBSD_SOURCE 1
| #define _OPENBSD_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define __STDC_WANT_IEC_60559_ATTRIBS_EXT__ 1
| #define __STDC_WANT_IEC_60559_BFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_DFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_FUNCS_EXT__ 1
| #define __STDC_WANT_IEC_60559_TYPES_EXT__ 1
| #define __STDC_WANT_LIB_EXT2__ 1
| #define __STDC_WANT_MATH_SPEC_FUNCS__ 1
| #define _TANDEM_SOURCE 1
| #define __EXTENSIONS__ 1
| #define HAVE_TCDRAIN 1
| #define HAVE_CANONICALIZE_FILE_NAME 1
| #define HAVE_FACCESSAT 1
| #define HAVE_REALPATH 1
| #define HAVE_LSTAT 1
| #define HAVE_READLINKAT 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCNTL 1
| #define HAVE_SYMLINK 1
| #define HAVE_FFSL 1
| #define HAVE_VASNPRINTF 1
| #define HAVE_SNPRINTF 1
| #define HAVE_FSYNC 1
| #define HAVE_GETPROGNAME 1
| #define HAVE_GETRUSAGE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_ISWCNTRL 1
| #define HAVE_ISWBLANK 1
| #define HAVE_MBSINIT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_ISASCII 1
| #define HAVE_MPROTECT 1
| #define HAVE_STRERROR_R 1
| #define HAVE___XPG_STRERROR_R 1
| #define HAVE_PIPE 1
| #define HAVE_PIPE2 1
| #define HAVE_READLINK 1
| #define HAVE_SETENV 1
| #define HAVE_LINK 1
| #define HAVE_SIGACTION 1
| #define HAVE_SIGALTSTACK 1
| #define HAVE_SIGINTERRUPT 1
| #define HAVE_STPNCPY 1
| #define HAVE_STRNDUP 1
| #define HAVE_WCWIDTH 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_MEMPCPY 1
| #define HAVE_FSTATAT 1
| #define HAVE_GETDELIM 1
| #define HAVE_GETDTABLESIZE 1
| #define HAVE_OPENAT 1
| #define HAVE_CATGETS 1
| #define HAVE_SETLOCALE 1
| /* end confdefs.h.  */
| /* A lexical scanner generated by flex */
| 
| /* Scanner skeleton version:
|  * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.85 95/04/24 10:48:47 vern Exp $
|  */
| 
| #define FLEX_SCANNER
| #define YY_FLEX_MAJOR_VERSION 2
| #define YY_FLEX_MINOR_VERSION 5
| 
| #include <stdio.h>
| 
| 
| /* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
| #ifdef c_plusplus
| #ifndef __cplusplus
| #define __cplusplus
| #endif
| #endif
| 
| 
| #ifdef __cplusplus
| 
| #include <stdlib.h>
| #include <unistd.h>
| 
| /* Use prototypes in function declarations. */
| #define YY_USE_PROTOS
| 
| /* The "const" storage-class-modifier is valid. */
| #define YY_USE_CONST
| 
| #else	/* ! __cplusplus */
| 
| #if __STDC__
| 
| #define YY_USE_PROTOS
| #define YY_USE_CONST
| 
| #endif	/* __STDC__ */
| #endif	/* ! __cplusplus */
| 
| #ifdef __TURBOC__
|  #pragma warn -rch
|  #pragma warn -use
| #include <io.h>
| #include <stdlib.h>
| #define YY_USE_CONST
| #define YY_USE_PROTOS
| #endif
| 
| #ifdef YY_USE_CONST
| #define yyconst const
| #else
| #define yyconst
| #endif
| 
| 
| #ifdef YY_USE_PROTOS
| #define YY_PROTO(proto) proto
| #else
| #define YY_PROTO(proto) ()
| #endif
| 
| /* Returned upon end-of-file. */
| #define YY_NULL 0
| 
| /* Promotes a possibly negative, possibly signed char to an unsigned
|  * integer for use as an array index.  If the signed char is negative,
|  * we want to instead treat it as an 8-bit unsigned char, hence the
|  * double cast.
|  */
| #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
| 
| /* Enter a start condition.  This macro really ought to take a parameter,
|  * but we do it the disgusting crufty way forced on us by the ()-less
|  * definition of BEGIN.
|  */
| #define BEGIN yy_start = 1 + 2 *
| 
| /* Translate the current start state into a value that can be later handed
|  * to BEGIN to return to the state.  The YYSTATE alias is for lex
|  * compatibility.
|  */
| #define YY_START ((yy_start - 1) / 2)
| #define YYSTATE YY_START
| 
| /* Action number for EOF rule of a given start state. */
| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
| 
| /* Special action meaning "start processing a new file". */
| #define YY_NEW_FILE yyrestart( yyin )
| 
| #define YY_END_OF_BUFFER_CHAR 0
| 
| /* Size of default input buffer. */
| #define YY_BUF_SIZE 16384
| 
| typedef struct yy_buffer_state *YY_BUFFER_STATE;
| 
| extern int yyleng;
| extern FILE *yyin, *yyout;
| 
| #define EOB_ACT_CONTINUE_SCAN 0
| #define EOB_ACT_END_OF_FILE 1
| #define EOB_ACT_LAST_MATCH 2
| 
| /* The funky do-while in the following #define is used to turn the definition
|  * int a single C statement (which needs a semi-colon terminator).  This
|  * avoids problems with code like:
|  *
|  * 	if ( condition_holds )
|  *		yyless( 5 );
|  *	else
|  *		do_something_else();
|  *
|  * Prior to using the do-while the compiler would get upset at the
|  * "else" because it interpreted the "if" statement as being all
|  * done when it reached the ';' after the yyless() call.
|  */
| 
| /* Return all but the first 'n' matched characters back to the input stream. */
| 
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
| 		*yy_cp = yy_hold_char; \
| 		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
| 		} \
| 	while ( 0 )
| 
| #define unput(c) yyunput( c, yytext_ptr )
| 
| /* The following is because we cannot portably get our hands on size_t
|  * (without autoconf's help, which isn't available because we want
|  * flex-generated scanners to compile on their own).
|  */
| typedef unsigned int yy_size_t;
| 
| 
| struct yy_buffer_state
| 	{
| 	FILE *yy_input_file;
| 
| 	char *yy_ch_buf;		/* input buffer */
| 	char *yy_buf_pos;		/* current position in input buffer */
| 
| 	/* Size of input buffer in bytes, not including room for EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_buf_size;
| 
| 	/* Number of characters read into yy_ch_buf, not including EOB
| 	 * characters.
| 	 */
| 	int yy_n_chars;
| 
| 	/* Whether we "own" the buffer - i.e., we know we created it,
| 	 * and can realloc() it to grow it, and should free() it to
| 	 * delete it.
| 	 */
| 	int yy_is_our_buffer;
| 
| 	/* Whether this is an "interactive" input source; if so, and
| 	 * if we're using stdio for input, then we want to use getc()
| 	 * instead of fread(), to make sure we stop fetching input after
| 	 * each newline.
| 	 */
| 	int yy_is_interactive;
| 
| 	/* Whether we're considered to be at the beginning of a line.
| 	 * If so, '^' rules will be active on the next match, otherwise
| 	 * not.
| 	 */
| 	int yy_at_bol;
| 
| 	/* Whether to try to fill the input buffer when we reach the
| 	 * end of it.
| 	 */
| 	int yy_fill_buffer;
| 
| 	int yy_buffer_status;
| #define YY_BUFFER_NEW 0
| #define YY_BUFFER_NORMAL 1
| 	/* When an EOF's been seen but there's still some text to process
| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
| 	 * shouldn't try reading from the input source any more.  We might
| 	 * still have a bunch of tokens to match, though, because of
| 	 * possible backing-up.
| 	 *
| 	 * When we actually see the EOF, we change the status to "new"
| 	 * (via yyrestart()), so that the user can continue scanning by
| 	 * just pointing yyin at a new input file.
| 	 */
| #define YY_BUFFER_EOF_PENDING 2
| 	};
| 
| static YY_BUFFER_STATE yy_current_buffer = 0;
| 
| /* We provide macros for accessing buffer states in case in the
|  * future we want to put the buffer states in a more general
|  * "scanner state".
|  */
| #define YY_CURRENT_BUFFER yy_current_buffer
| 
| 
| /* yy_hold_char holds the character lost when yytext is formed. */
| static char yy_hold_char;
| 
| static int yy_n_chars;		/* number of characters read into yy_ch_buf */
| 
| 
| int yyleng;
| 
| /* Points to current character in buffer. */
| static char *yy_c_buf_p = (char *) 0;
| static int yy_init = 1;		/* whether we need to initialize */
| static int yy_start = 0;	/* start state number */
| 
| /* Flag which is used to allow yywrap()'s to do buffer switches
|  * instead of setting up a fresh yyin.  A bit of a hack ...
|  */
| static int yy_did_buffer_switch_on_eof;
| 
| void yyrestart YY_PROTO(( FILE *input_file ));
| 
| void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
| void yy_load_buffer_state YY_PROTO(( void ));
| YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
| void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
| void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
| void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
| #define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
| 
| YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
| YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *str ));
| YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
| 
| static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
| static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
| static void yy_flex_free YY_PROTO(( void * ));
| 
| #define yy_new_buffer yy_create_buffer
| 
| #define yy_set_interactive(is_interactive) \
| 	{ \
| 	if ( ! yy_current_buffer ) \
| 		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
| 	yy_current_buffer->yy_is_interactive = is_interactive; \
| 	}
| 
| #define yy_set_bol(at_bol) \
| 	{ \
| 	if ( ! yy_current_buffer ) \
| 		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
| 	yy_current_buffer->yy_at_bol = at_bol; \
| 	}
| 
| #define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
| 
| 
| #define YY_USES_REJECT
| typedef unsigned char YY_CHAR;
| FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
| typedef int yy_state_type;
| extern char *yytext;
| #define yytext_ptr yytext
| 
| static yy_state_type yy_get_previous_state YY_PROTO(( void ));
| static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
| static int yy_get_next_buffer YY_PROTO(( void ));
| static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
| 
| /* Done after the current pattern has been matched and before the
|  * corresponding action - sets up yytext.
|  */
| #define YY_DO_BEFORE_ACTION \
| 	yytext_ptr = yy_bp; \
| 	yytext_ptr -= yy_more_len; \
| 	yyleng = (int) (yy_cp - yytext_ptr); \
| 	yy_hold_char = *yy_cp; \
| 	*yy_cp = '\0'; \
| 	yy_c_buf_p = yy_cp;
| 
| #define YY_NUM_RULES 8
| #define YY_END_OF_BUFFER 9
| static yyconst short int yy_acclist[23] =
|     {   0,
|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,
|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,
|         7,    8
|     } ;
| 
| static yyconst short int yy_accept[14] =
|     {   0,
|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,
|        20,   23,   23
|     } ;
| 
| static yyconst int yy_ec[256] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,
| 
|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| 
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1
|     } ;
| 
| static yyconst int yy_meta[9] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1
|     } ;
| 
| static yyconst short int yy_base[13] =
|     {   0,
|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,
|        10,   10
|     } ;
| 
| static yyconst short int yy_def[13] =
|     {   0,
|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,
|        12,    0
|     } ;
| 
| static yyconst short int yy_nxt[19] =
|     {   0,
|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| static yyconst short int yy_chk[19] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| static yy_state_type yy_state_buf[YY_BUF_SIZE + 2], *yy_state_ptr;
| static char *yy_full_match;
| static int yy_lp;
| #define REJECT \
| { \
| *yy_cp = yy_hold_char; /* undo effects of setting up yytext */ \
| yy_cp = yy_full_match; /* restore poss. backed-over text */ \
| ++yy_lp; \
| goto find_rule; \
| }
| static int yy_more_flag = 0;
| static int yy_more_len = 0;
| #define yymore() (yy_more_flag = 1)
| #define YY_MORE_ADJ yy_more_len
| char *yytext;
| #line 1 "conftest.l"
| #define INITIAL 0
| #line 381 "lex.yy.c"
| 
| /* Macros after this point can all be overridden by user definitions in
|  * section 1.
|  */
| 
| #ifndef YY_SKIP_YYWRAP
| #ifdef __cplusplus
| extern "C" int yywrap YY_PROTO(( void ));
| #else
| extern int yywrap YY_PROTO(( void ));
| #endif
| #endif
| 
| #ifndef YY_NO_UNPUT
| static void yyunput YY_PROTO(( int c, char *buf_ptr ));
| #endif
| 
| #ifndef yytext_ptr
| static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
| #endif
| 
| #ifndef YY_NO_INPUT
| #ifdef __cplusplus
| static int yyinput YY_PROTO(( void ));
| #else
| static int input YY_PROTO(( void ));
| #endif
| #endif
| 
| #if YY_STACK_USED
| static int yy_start_stack_ptr = 0;
| static int yy_start_stack_depth = 0;
| static int *yy_start_stack = 0;
| #ifndef YY_NO_PUSH_STATE
| static void yy_push_state YY_PROTO(( int new_state ));
| #endif
| #ifndef YY_NO_POP_STATE
| static void yy_pop_state YY_PROTO(( void ));
| #endif
| #ifndef YY_NO_TOP_STATE
| static int yy_top_state YY_PROTO(( void ));
| #endif
| 
| #else
| #define YY_NO_PUSH_STATE 1
| #define YY_NO_POP_STATE 1
| #define YY_NO_TOP_STATE 1
| #endif
| 
| #ifdef YY_MALLOC_DECL
| YY_MALLOC_DECL
| #else
| #if __STDC__
| #ifndef __cplusplus
| #include <stdlib.h>
| #endif
| #else
| /* Just try to get by without declaring the routines.  This will fail
|  * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
|  * or sizeof(void*) != sizeof(int).
|  */
| #endif
| #endif
| 
| /* Amount of stuff to slurp up with each read. */
| #ifndef YY_READ_BUF_SIZE
| #define YY_READ_BUF_SIZE 8192
| #endif
| 
| /* Copy whatever the last rule matched to the standard output. */
| 
| #ifndef ECHO
| /* This used to be an fputs(), but since the string might contain NUL's,
|  * we now use fwrite().
|  */
| #define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
| #endif
| 
| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
|  * is returned in "result".
|  */
| #ifndef YY_INPUT
| #define YY_INPUT(buf,result,max_size) \
| 	if ( yy_current_buffer->yy_is_interactive ) \
| 		{ \
| 		int c = '*', n; \
| 		for ( n = 0; n < max_size && \
| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
| 			buf[n] = (char) c; \
| 		if ( c == '\n' ) \
| 			buf[n++] = (char) c; \
| 		if ( c == EOF && ferror( yyin ) ) \
| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 		result = n; \
| 		} \
| 	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
| 		  && ferror( yyin ) ) \
| 		YY_FATAL_ERROR( "input in flex scanner failed" );
| #endif
| 
| /* No semi-colon after return; correct usage is to write "yyterminate();" -
|  * we don't want an extra ';' after the "return" because that will cause
|  * some compilers to complain about unreachable statements.
|  */
| #ifndef yyterminate
| #define yyterminate() return YY_NULL
| #endif
| 
| /* Number of entries by which start-condition stack grows. */
| #ifndef YY_START_STACK_INCR
| #define YY_START_STACK_INCR 25
| #endif
| 
| /* Report a fatal error. */
| #ifndef YY_FATAL_ERROR
| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
| #endif
| 
| /* Default declaration of generated scanner - a define so the user can
|  * easily add parameters.
|  */
| #ifndef YY_DECL
| #define YY_DECL int yylex YY_PROTO(( void ))
| #endif
| 
| /* Code executed at the beginning of each rule, after yytext and yyleng
|  * have been set up.
|  */
| #ifndef YY_USER_ACTION
| #define YY_USER_ACTION
| #endif
| 
| /* Code executed at the end of each rule. */
| #ifndef YY_BREAK
| #define YY_BREAK break;
| #endif
| 
| #define YY_RULE_SETUP \
| 	YY_USER_ACTION
| 
| YY_DECL
| 	{
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp, *yy_bp;
| 	register int yy_act;
| 
| #line 1 "conftest.l"
| 
| #line 530 "lex.yy.c"
| 
| 	if ( yy_init )
| 		{
| 		yy_init = 0;
| 
| #ifdef YY_USER_INIT
| 		YY_USER_INIT;
| #endif
| 
| 		if ( ! yy_start )
| 			yy_start = 1;	/* first start state */
| 
| 		if ( ! yyin )
| 			yyin = stdin;
| 
| 		if ( ! yyout )
| 			yyout = stdout;
| 
| 		if ( ! yy_current_buffer )
| 			yy_current_buffer =
| 				yy_create_buffer( yyin, YY_BUF_SIZE );
| 
| 		yy_load_buffer_state();
| 		}
| 
| 	while ( 1 )		/* loops until end-of-file is reached */
| 		{
| 		yy_more_len = 0;
| 		if ( yy_more_flag )
| 			{
| 			yy_more_len = yyleng;
| 			yy_more_flag = 0;
| 			}
| 		yy_cp = yy_c_buf_p;
| 
| 		/* Support of yytext. */
| 		*yy_cp = yy_hold_char;
| 
| 		/* yy_bp points to the position in yy_ch_buf of the start of
| 		 * the current run.
| 		 */
| 		yy_bp = yy_cp;
| 
| 		yy_current_state = yy_start;
| 		yy_state_ptr = yy_state_buf;
| 		*yy_state_ptr++ = yy_current_state;
| yy_match:
| 		do
| 			{
| 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 				{
| 				yy_current_state = (int) yy_def[yy_current_state];
| 				if ( yy_current_state >= 13 )
| 					yy_c = yy_meta[(unsigned int) yy_c];
| 				}
| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 			*yy_state_ptr++ = yy_current_state;
| 			++yy_cp;
| 			}
| 		while ( yy_base[yy_current_state] != 10 );
| 
| yy_find_action:
| 		yy_current_state = *--yy_state_ptr;
| 		yy_lp = yy_accept[yy_current_state];
| find_rule: /* we branch to this label when backing up */
| 		for ( ; ; ) /* until we find what rule we matched */
| 			{
| 			if ( yy_lp && yy_lp < yy_accept[yy_current_state + 1] )
| 				{
| 				yy_act = yy_acclist[yy_lp];
| 					{
| 					yy_full_match = yy_cp;
| 					break;
| 					}
| 				}
| 			--yy_cp;
| 			yy_current_state = *--yy_state_ptr;
| 			yy_lp = yy_accept[yy_current_state];
| 			}
| 
| 		YY_DO_BEFORE_ACTION;
| 
| 
| do_action:	/* This label is used only to access EOF actions. */
| 
| 
| 		switch ( yy_act )
| 	{ /* beginning of action switch */
| case 1:
| YY_RULE_SETUP
| #line 2 "conftest.l"
| { ECHO; }
| 	YY_BREAK
| case 2:
| YY_RULE_SETUP
| #line 3 "conftest.l"
| { REJECT; }
| 	YY_BREAK
| case 3:
| YY_RULE_SETUP
| #line 4 "conftest.l"
| { yymore (); }
| 	YY_BREAK
| case 4:
| YY_RULE_SETUP
| #line 5 "conftest.l"
| { yyless (1); }
| 	YY_BREAK
| case 5:
| YY_RULE_SETUP
| #line 6 "conftest.l"
| { /* IRIX 6.5 flex 2.5.4 underquotes its yyless argument.  */
|     yyless ((input () != 0)); }
| 	YY_BREAK
| case 6:
| YY_RULE_SETUP
| #line 8 "conftest.l"
| { unput (yytext[0]); }
| 	YY_BREAK
| case 7:
| YY_RULE_SETUP
| #line 9 "conftest.l"
| { BEGIN INITIAL; }
| 	YY_BREAK
| case 8:
| YY_RULE_SETUP
| #line 10 "conftest.l"
| ECHO;
| 	YY_BREAK
| #line 661 "lex.yy.c"
| 			case YY_STATE_EOF(INITIAL):
| 				yyterminate();
| 
| 	case YY_END_OF_BUFFER:
| 		{
| 		/* Amount of text matched not including the EOB char. */
| 		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
| 
| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
| 		*yy_cp = yy_hold_char;
| 
| 		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
| 			{
| 			/* We're scanning a new file or input source.  It's
| 			 * possible that this happened because the user
| 			 * just pointed yyin at a new source and called
| 			 * yylex().  If so, then we have to assure
| 			 * consistency between yy_current_buffer and our
| 			 * globals.  Here is the right place to do so, because
| 			 * this is the first action (other than possibly a
| 			 * back-up) that will match for the new input source.
| 			 */
| 			yy_n_chars = yy_current_buffer->yy_n_chars;
| 			yy_current_buffer->yy_input_file = yyin;
| 			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
| 			}
| 
| 		/* Note that here we test for yy_c_buf_p "<=" to the position
| 		 * of the first EOB in the buffer, since yy_c_buf_p will
| 		 * already have been incremented past the NUL character
| 		 * (since all states make transitions on EOB to the
| 		 * end-of-buffer state).  Contrast this with the test
| 		 * in input().
| 		 */
| 		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
| 			{ /* This was really a NUL. */
| 			yy_state_type yy_next_state;
| 
| 			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
| 
| 			yy_current_state = yy_get_previous_state();
| 
| 			/* Okay, we're now positioned to make the NUL
| 			 * transition.  We couldn't have
| 			 * yy_get_previous_state() go ahead and do it
| 			 * for us because it doesn't know how to deal
| 			 * with the possibility of jamming (and we don't
| 			 * want to build jamming into it because then it
| 			 * will run more slowly).
| 			 */
| 
| 			yy_next_state = yy_try_NUL_trans( yy_current_state );
| 
| 			yy_bp = yytext_ptr + YY_MORE_ADJ;
| 
| 			if ( yy_next_state )
| 				{
| 				/* Consume the NUL. */
| 				yy_cp = ++yy_c_buf_p;
| 				yy_current_state = yy_next_state;
| 				goto yy_match;
| 				}
| 
| 			else
| 				{
| 				yy_cp = yy_c_buf_p;
| 				goto yy_find_action;
| 				}
| 			}
| 
| 		else switch ( yy_get_next_buffer() )
| 			{
| 			case EOB_ACT_END_OF_FILE:
| 				{
| 				yy_did_buffer_switch_on_eof = 0;
| 
| 				if ( yywrap() )
| 					{
| 					/* Note: because we've taken care in
| 					 * yy_get_next_buffer() to have set up
| 					 * yytext, we can now set up
| 					 * yy_c_buf_p so that if some total
| 					 * hoser (like flex itself) wants to
| 					 * call the scanner after we return the
| 					 * YY_NULL, it'll still work - another
| 					 * YY_NULL will get returned.
| 					 */
| 					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
| 
| 					yy_act = YY_STATE_EOF(YY_START);
| 					goto do_action;
| 					}
| 
| 				else
| 					{
| 					if ( ! yy_did_buffer_switch_on_eof )
| 						YY_NEW_FILE;
| 					}
| 				break;
| 				}
| 
| 			case EOB_ACT_CONTINUE_SCAN:
| 				yy_c_buf_p =
| 					yytext_ptr + yy_amount_of_matched_text;
| 
| 				yy_current_state = yy_get_previous_state();
| 
| 				yy_cp = yy_c_buf_p;
| 				yy_bp = yytext_ptr + YY_MORE_ADJ;
| 				goto yy_match;
| 
| 			case EOB_ACT_LAST_MATCH:
| 				yy_c_buf_p =
| 				&yy_current_buffer->yy_ch_buf[yy_n_chars];
| 
| 				yy_current_state = yy_get_previous_state();
| 
| 				yy_cp = yy_c_buf_p;
| 				yy_bp = yytext_ptr + YY_MORE_ADJ;
| 				goto yy_find_action;
| 			}
| 		break;
| 		}
| 
| 	default:
| 		YY_FATAL_ERROR(
| 			"fatal flex scanner internal error--no action found" );
| 	} /* end of action switch */
| 		} /* end of scanning one token */
| 	} /* end of yylex */
| 
| 
| /* yy_get_next_buffer - try to read in a new buffer
|  *
|  * Returns a code representing an action:
|  *	EOB_ACT_LAST_MATCH -
|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
|  *	EOB_ACT_END_OF_FILE - end of file
|  */
| 
| static int yy_get_next_buffer()
| 	{
| 	register char *dest = yy_current_buffer->yy_ch_buf;
| 	register char *source = yytext_ptr;
| 	register int number_to_move, i;
| 	int ret_val;
| 
| 	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
| 		YY_FATAL_ERROR(
| 		"fatal flex scanner internal error--end of buffer missed" );
| 
| 	if ( yy_current_buffer->yy_fill_buffer == 0 )
| 		{ /* Don't try to fill the buffer, so this is an EOF. */
| 		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
| 			{
| 			/* We matched a singled characater, the EOB, so
| 			 * treat this as a final EOF.
| 			 */
| 			return EOB_ACT_END_OF_FILE;
| 			}
| 
| 		else
| 			{
| 			/* We matched some text prior to the EOB, first
| 			 * process it.
| 			 */
| 			return EOB_ACT_LAST_MATCH;
| 			}
| 		}
| 
| 	/* Try to read more data. */
| 
| 	/* First move last chars to start of buffer. */
| 	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
| 
| 	for ( i = 0; i < number_to_move; ++i )
| 		*(dest++) = *(source++);
| 
| 	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
| 		/* don't do the read, it's not guaranteed to return an EOF,
| 		 * just force an EOF
| 		 */
| 		yy_n_chars = 0;
| 
| 	else
| 		{
| 		int num_to_read =
| 			yy_current_buffer->yy_buf_size - number_to_move - 1;
| 
| 		while ( num_to_read <= 0 )
| 			{ /* Not enough room in the buffer - grow it. */
| #ifdef YY_USES_REJECT
| 			YY_FATAL_ERROR(
| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
| #else
| 
| 			/* just a shorter name for the current buffer */
| 			YY_BUFFER_STATE b = yy_current_buffer;
| 
| 			int yy_c_buf_p_offset =
| 				(int) (yy_c_buf_p - b->yy_ch_buf);
| 
| 			if ( b->yy_is_our_buffer )
| 				{
| 				int new_size = b->yy_buf_size * 2;
| 
| 				if ( new_size <= 0 )
| 					b->yy_buf_size += b->yy_buf_size / 8;
| 				else
| 					b->yy_buf_size *= 2;
| 
| 				b->yy_ch_buf = (char *)
| 					/* Include room in for 2 EOB chars. */
| 					yy_flex_realloc( (void *) b->yy_ch_buf,
| 							 b->yy_buf_size + 2 );
| 				}
| 			else
| 				/* Can't grow it, we don't own it. */
| 				b->yy_ch_buf = 0;
| 
| 			if ( ! b->yy_ch_buf )
| 				YY_FATAL_ERROR(
| 				"fatal error - scanner input buffer overflow" );
| 
| 			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
| 
| 			num_to_read = yy_current_buffer->yy_buf_size -
| 						number_to_move - 1;
| #endif
| 			}
| 
| 		if ( num_to_read > YY_READ_BUF_SIZE )
| 			num_to_read = YY_READ_BUF_SIZE;
| 
| 		/* Read in more data. */
| 		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
| 			yy_n_chars, num_to_read );
| 		}
| 
| 	if ( yy_n_chars == 0 )
| 		{
| 		if ( number_to_move == YY_MORE_ADJ )
| 			{
| 			ret_val = EOB_ACT_END_OF_FILE;
| 			yyrestart( yyin );
| 			}
| 
| 		else
| 			{
| 			ret_val = EOB_ACT_LAST_MATCH;
| 			yy_current_buffer->yy_buffer_status =
| 				YY_BUFFER_EOF_PENDING;
| 			}
| 		}
| 
| 	else
| 		ret_val = EOB_ACT_CONTINUE_SCAN;
| 
| 	yy_n_chars += number_to_move;
| 	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
| 	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
| 
| 	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
| 
| 	return ret_val;
| 	}
| 
| 
| /* yy_get_previous_state - get the state just before the EOB char was reached */
| 
| static yy_state_type yy_get_previous_state()
| 	{
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp;
| 
| 	yy_current_state = yy_start;
| 	yy_state_ptr = yy_state_buf;
| 	*yy_state_ptr++ = yy_current_state;
| 
| 	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
| 		{
| 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 			{
| 			yy_current_state = (int) yy_def[yy_current_state];
| 			if ( yy_current_state >= 13 )
| 				yy_c = yy_meta[(unsigned int) yy_c];
| 			}
| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 		*yy_state_ptr++ = yy_current_state;
| 		}
| 
| 	return yy_current_state;
| 	}
| 
| 
| /* yy_try_NUL_trans - try to make a transition on the NUL character
|  *
|  * synopsis
|  *	next_state = yy_try_NUL_trans( current_state );
|  */
| 
| #ifdef YY_USE_PROTOS
| static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
| #else
| static yy_state_type yy_try_NUL_trans( yy_current_state )
| yy_state_type yy_current_state;
| #endif
| 	{
| 	register int yy_is_jam;
| 
| 	register YY_CHAR yy_c = 1;
| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 		{
| 		yy_current_state = (int) yy_def[yy_current_state];
| 		if ( yy_current_state >= 13 )
| 			yy_c = yy_meta[(unsigned int) yy_c];
| 		}
| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 	*yy_state_ptr++ = yy_current_state;
| 	yy_is_jam = (yy_current_state == 12);
| 
| 	return yy_is_jam ? 0 : yy_current_state;
| 	}
| 
| 
| #ifndef YY_NO_UNPUT
| #ifdef YY_USE_PROTOS
| static void yyunput( int c, register char *yy_bp )
| #else
| static void yyunput( c, yy_bp )
| int c;
| register char *yy_bp;
| #endif
| 	{
| 	register char *yy_cp = yy_c_buf_p;
| 
| 	/* undo effects of setting up yytext */
| 	*yy_cp = yy_hold_char;
| 
| 	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
| 		{ /* need to shift things up to make room */
| 		/* +2 for EOB chars. */
| 		register int number_to_move = yy_n_chars + 2;
| 		register char *dest = &yy_current_buffer->yy_ch_buf[
| 					yy_current_buffer->yy_buf_size + 2];
| 		register char *source =
| 				&yy_current_buffer->yy_ch_buf[number_to_move];
| 
| 		while ( source > yy_current_buffer->yy_ch_buf )
| 			*--dest = *--source;
| 
| 		yy_cp += (int) (dest - source);
| 		yy_bp += (int) (dest - source);
| 		yy_n_chars = yy_current_buffer->yy_buf_size;
| 
| 		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
| 		}
| 
| 	*--yy_cp = (char) c;
| 
| 
| 	yytext_ptr = yy_bp;
| 	yy_hold_char = *yy_cp;
| 	yy_c_buf_p = yy_cp;
| 	}
| #endif	/* ifndef YY_NO_UNPUT */
| 
| 
| #ifdef __cplusplus
| static int yyinput()
| #else
| static int input()
| #endif
| 	{
| 	int c;
| 
| 	*yy_c_buf_p = yy_hold_char;
| 
| 	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
| 		{
| 		/* yy_c_buf_p now points to the character we want to return.
| 		 * If this occurs *before* the EOB characters, then it's a
| 		 * valid NUL; if not, then we've hit the end of the buffer.
| 		 */
| 		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
| 			/* This was really a NUL. */
| 			*yy_c_buf_p = '\0';
| 
| 		else
| 			{ /* need more input */
| 			yytext_ptr = yy_c_buf_p;
| 			++yy_c_buf_p;
| 
| 			switch ( yy_get_next_buffer() )
| 				{
| 				case EOB_ACT_END_OF_FILE:
| 					{
| 					if ( yywrap() )
| 						{
| 						yy_c_buf_p =
| 						yytext_ptr + YY_MORE_ADJ;
| 						return EOF;
| 						}
| 
| 					if ( ! yy_did_buffer_switch_on_eof )
| 						YY_NEW_FILE;
| #ifdef __cplusplus
| 					return yyinput();
| #else
| 					return input();
| #endif
| 					}
| 
| 				case EOB_ACT_CONTINUE_SCAN:
| 					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
| 					break;
| 
| 				case EOB_ACT_LAST_MATCH:
| #ifdef __cplusplus
| 					YY_FATAL_ERROR(
| 					"unexpected last match in yyinput()" );
| #else
| 					YY_FATAL_ERROR(
| 					"unexpected last match in input()" );
| #endif
| 				}
| 			}
| 		}
| 
| 	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
| 	*yy_c_buf_p = '\0';	/* preserve yytext */
| 	yy_hold_char = *++yy_c_buf_p;
| 
| 
| 	return c;
| 	}
| 
| 
| #ifdef YY_USE_PROTOS
| void yyrestart( FILE *input_file )
| #else
| void yyrestart( input_file )
| FILE *input_file;
| #endif
| 	{
| 	if ( ! yy_current_buffer )
| 		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
| 
| 	yy_init_buffer( yy_current_buffer, input_file );
| 	yy_load_buffer_state();
| 	}
| 
| 
| #ifdef YY_USE_PROTOS
| void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
| #else
| void yy_switch_to_buffer( new_buffer )
| YY_BUFFER_STATE new_buffer;
| #endif
| 	{
| 	if ( yy_current_buffer == new_buffer )
| 		return;
| 
| 	if ( yy_current_buffer )
| 		{
| 		/* Flush out information for old buffer. */
| 		*yy_c_buf_p = yy_hold_char;
| 		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
| 		yy_current_buffer->yy_n_chars = yy_n_chars;
| 		}
| 
| 	yy_current_buffer = new_buffer;
| 	yy_load_buffer_state();
| 
| 	/* We don't actually know whether we did this switch during
| 	 * EOF (yywrap()) processing, but the only time this flag
| 	 * is looked at is after yywrap() is called, so it's safe
| 	 * to go ahead and always set it.
| 	 */
| 	yy_did_buffer_switch_on_eof = 1;
| 	}
| 
| 
| #ifdef YY_USE_PROTOS
| void yy_load_buffer_state( void )
| #else
| void yy_load_buffer_state()
| #endif
| 	{
| 	yy_n_chars = yy_current_buffer->yy_n_chars;
| 	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
| 	yyin = yy_current_buffer->yy_input_file;
| 	yy_hold_char = *yy_c_buf_p;
| 	}
| 
| 
| #ifdef YY_USE_PROTOS
| YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
| #else
| YY_BUFFER_STATE yy_create_buffer( file, size )
| FILE *file;
| int size;
| #endif
| 	{
| 	YY_BUFFER_STATE b;
| 
| 	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_buf_size = size;
| 
| 	/* yy_ch_buf has to be 2 characters longer than the size given because
| 	 * we need to put in 2 end-of-buffer characters.
| 	 */
| 	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
| 	if ( ! b->yy_ch_buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_is_our_buffer = 1;
| 
| 	yy_init_buffer( b, file );
| 
| 	return b;
| 	}
| 
| 
| #ifdef YY_USE_PROTOS
| void yy_delete_buffer( YY_BUFFER_STATE b )
| #else
| void yy_delete_buffer( b )
| YY_BUFFER_STATE b;
| #endif
| 	{
| 	if ( ! b )
| 		return;
| 
| 	if ( b == yy_current_buffer )
| 		yy_current_buffer = (YY_BUFFER_STATE) 0;
| 
| 	if ( b->yy_is_our_buffer )
| 		yy_flex_free( (void *) b->yy_ch_buf );
| 
| 	yy_flex_free( (void *) b );
| 	}
| 
| 
| #ifndef YY_ALWAYS_INTERACTIVE
| #ifndef YY_NEVER_INTERACTIVE
| extern int isatty YY_PROTO(( int ));
| #endif
| #endif
| 
| #ifdef YY_USE_PROTOS
| void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
| #else
| void yy_init_buffer( b, file )
| YY_BUFFER_STATE b;
| FILE *file;
| #endif
| 
| 
| 	{
| 	yy_flush_buffer( b );
| 
| 	b->yy_input_file = file;
| 	b->yy_fill_buffer = 1;
| 
| #if YY_ALWAYS_INTERACTIVE
| 	b->yy_is_interactive = 1;
| #else
| #if YY_NEVER_INTERACTIVE
| 	b->yy_is_interactive = 0;
| #else
| 	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
| #endif
| #endif
| 	}
| 
| 
| #ifdef YY_USE_PROTOS
| void yy_flush_buffer( YY_BUFFER_STATE b )
| #else
| void yy_flush_buffer( b )
| YY_BUFFER_STATE b;
| #endif
| 
| 	{
| 	b->yy_n_chars = 0;
| 
| 	/* We always need two end-of-buffer characters.  The first causes
| 	 * a transition to the end-of-buffer state.  The second causes
| 	 * a jam in that state.
| 	 */
| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b->yy_buf_pos = &b->yy_ch_buf[0];
| 
| 	b->yy_at_bol = 1;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	if ( b == yy_current_buffer )
| 		yy_load_buffer_state();
| 	}
| 
| 
| #ifndef YY_NO_SCAN_BUFFER
| #ifdef YY_USE_PROTOS
| YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
| #else
| YY_BUFFER_STATE yy_scan_buffer( base, size )
| char *base;
| yy_size_t size;
| #endif
| 	{
| 	YY_BUFFER_STATE b;
| 
| 	if ( size < 2 ||
| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
| 		/* They forgot to leave room for the EOB's. */
| 		return 0;
| 
| 	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
| 
| 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
| 	b->yy_buf_pos = b->yy_ch_buf = base;
| 	b->yy_is_our_buffer = 0;
| 	b->yy_input_file = 0;
| 	b->yy_n_chars = b->yy_buf_size;
| 	b->yy_is_interactive = 0;
| 	b->yy_at_bol = 1;
| 	b->yy_fill_buffer = 0;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	yy_switch_to_buffer( b );
| 
| 	return b;
| 	}
| #endif
| 
| 
| #ifndef YY_NO_SCAN_STRING
| #ifdef YY_USE_PROTOS
| YY_BUFFER_STATE yy_scan_string( yyconst char *str )
| #else
| YY_BUFFER_STATE yy_scan_string( str )
| yyconst char *str;
| #endif
| 	{
| 	int len;
| 	for ( len = 0; str[len]; ++len )
| 		;
| 
| 	return yy_scan_bytes( str, len );
| 	}
| #endif
| 
| 
| #ifndef YY_NO_SCAN_BYTES
| #ifdef YY_USE_PROTOS
| YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
| #else
| YY_BUFFER_STATE yy_scan_bytes( bytes, len )
| yyconst char *bytes;
| int len;
| #endif
| 	{
| 	YY_BUFFER_STATE b;
| 	char *buf;
| 	yy_size_t n;
| 	int i;
| 
| 	/* Get memory for full buffer, including space for trailing EOB's. */
| 	n = len + 2;
| 	buf = (char *) yy_flex_alloc( n );
| 	if ( ! buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
| 
| 	for ( i = 0; i < len; ++i )
| 		buf[i] = bytes[i];
| 
| 	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b = yy_scan_buffer( buf, n );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
| 
| 	/* It's okay to grow etc. this buffer, and we should throw it
| 	 * away when we're done.
| 	 */
| 	b->yy_is_our_buffer = 1;
| 
| 	return b;
| 	}
| #endif
| 
| 
| #ifndef YY_NO_PUSH_STATE
| #ifdef YY_USE_PROTOS
| static void yy_push_state( int new_state )
| #else
| static void yy_push_state( new_state )
| int new_state;
| #endif
| 	{
| 	if ( yy_start_stack_ptr >= yy_start_stack_depth )
| 		{
| 		yy_size_t new_size;
| 
| 		yy_start_stack_depth += YY_START_STACK_INCR;
| 		new_size = yy_start_stack_depth * sizeof( int );
| 
| 		if ( ! yy_start_stack )
| 			yy_start_stack = (int *) yy_flex_alloc( new_size );
| 
| 		else
| 			yy_start_stack = (int *) yy_flex_realloc(
| 					(void *) yy_start_stack, new_size );
| 
| 		if ( ! yy_start_stack )
| 			YY_FATAL_ERROR(
| 			"out of memory expanding start-condition stack" );
| 		}
| 
| 	yy_start_stack[yy_start_stack_ptr++] = YY_START;
| 
| 	BEGIN(new_state);
| 	}
| #endif
| 
| 
| #ifndef YY_NO_POP_STATE
| static void yy_pop_state()
| 	{
| 	if ( --yy_start_stack_ptr < 0 )
| 		YY_FATAL_ERROR( "start-condition stack underflow" );
| 
| 	BEGIN(yy_start_stack[yy_start_stack_ptr]);
| 	}
| #endif
| 
| 
| #ifndef YY_NO_TOP_STATE
| static int yy_top_state()
| 	{
| 	return yy_start_stack[yy_start_stack_ptr - 1];
| 	}
| #endif
| 
| #ifndef YY_EXIT_FAILURE
| #define YY_EXIT_FAILURE 2
| #endif
| 
| #ifdef YY_USE_PROTOS
| static void yy_fatal_error( yyconst char msg[] )
| #else
| static void yy_fatal_error( msg )
| char msg[];
| #endif
| 	{
| 	(void) fprintf( stderr, "%s\n", msg );
| 	exit( YY_EXIT_FAILURE );
| 	}
| 
| 
| 
| /* Redefine yyless() so it works in section 3 code. */
| 
| #undef yyless
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
| 		yytext[yyleng] = yy_hold_char; \
| 		yy_c_buf_p = yytext + n - YY_MORE_ADJ; \
| 		yy_hold_char = *yy_c_buf_p; \
| 		*yy_c_buf_p = '\0'; \
| 		yyleng = n; \
| 		} \
| 	while ( 0 )
| 
| 
| /* Internal utility routines. */
| 
| #ifndef yytext_ptr
| #ifdef YY_USE_PROTOS
| static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
| #else
| static void yy_flex_strncpy( s1, s2, n )
| char *s1;
| yyconst char *s2;
| int n;
| #endif
| 	{
| 	register int i;
| 	for ( i = 0; i < n; ++i )
| 		s1[i] = s2[i];
| 	}
| #endif
| 
| 
| #ifdef YY_USE_PROTOS
| static void *yy_flex_alloc( yy_size_t size )
| #else
| static void *yy_flex_alloc( size )
| yy_size_t size;
| #endif
| 	{
| 	return (void *) malloc( size );
| 	}
| 
| #ifdef YY_USE_PROTOS
| static void *yy_flex_realloc( void *ptr, yy_size_t size )
| #else
| static void *yy_flex_realloc( ptr, size )
| void *ptr;
| yy_size_t size;
| #endif
| 	{
| 	/* The cast to (char *) in the following accommodates both
| 	 * implementations that use char* generic pointers, and those
| 	 * that use void* generic pointers.  It works with the latter
| 	 * because both ANSI C and C++ allow castless assignment from
| 	 * any pointer type to void*, and deal with argument conversions
| 	 * as though doing an assignment.
| 	 */
| 	return (void *) realloc( (char *) ptr, size );
| 	}
| 
| #ifdef YY_USE_PROTOS
| static void yy_flex_free( void *ptr )
| #else
| static void yy_flex_free( ptr )
| void *ptr;
| #endif
| 	{
| 	free( ptr );
| 	}
| 
| #if YY_MAIN
| int main()
| 	{
| 	yylex();
| 	return 0;
| 	}
| #endif
| #line 10 "conftest.l"
| 
| #ifdef YYTEXT_POINTER
| extern char *yytext;
| #endif
| int
| main (void)
| {
|   return ! yylex () + ! yywrap ();
| }
configure:13473: gcc -o conftest.exe -g -O2   conftest.c -lfl  >&5
/usr/lib/gcc/x86_64-pc-cygwin/11/../../../../x86_64-pc-cygwin/bin/ld: cannot find -lfl: No such file or directory
collect2: error: ld returned 1 exit status
configure:13473: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "GNU Bison"
| #define PACKAGE_TARNAME "bison"
| #define PACKAGE_VERSION "3.8"
| #define PACKAGE_STRING "GNU Bison 3.8"
| #define PACKAGE_BUGREPORT "bug-bison@gnu.org"
| #define PACKAGE_URL "https://www.gnu.org/software/bison/"
| #define PACKAGE_COPYRIGHT_YEAR 2021
| #define PACKAGE "bison"
| #define VERSION "3.8"
| #define HAVE_STDIO_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_SOCKET_H 1
| #define HAVE_STDIO_EXT_H 1
| #define HAVE_FEATURES_H 1
| #define HAVE_GETOPT_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_CRTDEFS_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_THREADS_H 1
| #define HAVE_MATH_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_SPAWN_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_TIMES_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_TERMIOS_H 1
| #define HAVE_DIRENT_H 1
| #define STDC_HEADERS 1
| #define _ALL_SOURCE 1
| #define _DARWIN_C_SOURCE 1
| #define _GNU_SOURCE 1
| #define _HPUX_ALT_XOPEN_SOCKET_API 1
| #define _NETBSD_SOURCE 1
| #define _OPENBSD_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define __STDC_WANT_IEC_60559_ATTRIBS_EXT__ 1
| #define __STDC_WANT_IEC_60559_BFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_DFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_FUNCS_EXT__ 1
| #define __STDC_WANT_IEC_60559_TYPES_EXT__ 1
| #define __STDC_WANT_LIB_EXT2__ 1
| #define __STDC_WANT_MATH_SPEC_FUNCS__ 1
| #define _TANDEM_SOURCE 1
| #define __EXTENSIONS__ 1
| #define HAVE_TCDRAIN 1
| #define HAVE_CANONICALIZE_FILE_NAME 1
| #define HAVE_FACCESSAT 1
| #define HAVE_REALPATH 1
| #define HAVE_LSTAT 1
| #define HAVE_READLINKAT 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCNTL 1
| #define HAVE_SYMLINK 1
| #define HAVE_FFSL 1
| #define HAVE_VASNPRINTF 1
| #define HAVE_SNPRINTF 1
| #define HAVE_FSYNC 1
| #define HAVE_GETPROGNAME 1
| #define HAVE_GETRUSAGE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_ISWCNTRL 1
| #define HAVE_ISWBLANK 1
| #define HAVE_MBSINIT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_ISASCII 1
| #define HAVE_MPROTECT 1
| #define HAVE_STRERROR_R 1
| #define HAVE___XPG_STRERROR_R 1
| #define HAVE_PIPE 1
| #define HAVE_PIPE2 1
| #define HAVE_READLINK 1
| #define HAVE_SETENV 1
| #define HAVE_LINK 1
| #define HAVE_SIGACTION 1
| #define HAVE_SIGALTSTACK 1
| #define HAVE_SIGINTERRUPT 1
| #define HAVE_STPNCPY 1
| #define HAVE_STRNDUP 1
| #define HAVE_WCWIDTH 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_MEMPCPY 1
| #define HAVE_FSTATAT 1
| #define HAVE_GETDELIM 1
| #define HAVE_GETDTABLESIZE 1
| #define HAVE_OPENAT 1
| #define HAVE_CATGETS 1
| #define HAVE_SETLOCALE 1
| /* end confdefs.h.  */
| /* A lexical scanner generated by flex */
| 
| /* Scanner skeleton version:
|  * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.85 95/04/24 10:48:47 vern Exp $
|  */
| 
| #define FLEX_SCANNER
| #define YY_FLEX_MAJOR_VERSION 2
| #define YY_FLEX_MINOR_VERSION 5
| 
| #include <stdio.h>
| 
| 
| /* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
| #ifdef c_plusplus
| #ifndef __cplusplus
| #define __cplusplus
| #endif
| #endif
| 
| 
| #ifdef __cplusplus
| 
| #include <stdlib.h>
| #include <unistd.h>
| 
| /* Use prototypes in function declarations. */
| #define YY_USE_PROTOS
| 
| /* The "const" storage-class-modifier is valid. */
| #define YY_USE_CONST
| 
| #else	/* ! __cplusplus */
| 
| #if __STDC__
| 
| #define YY_USE_PROTOS
| #define YY_USE_CONST
| 
| #endif	/* __STDC__ */
| #endif	/* ! __cplusplus */
| 
| #ifdef __TURBOC__
|  #pragma warn -rch
|  #pragma warn -use
| #include <io.h>
| #include <stdlib.h>
| #define YY_USE_CONST
| #define YY_USE_PROTOS
| #endif
| 
| #ifdef YY_USE_CONST
| #define yyconst const
| #else
| #define yyconst
| #endif
| 
| 
| #ifdef YY_USE_PROTOS
| #define YY_PROTO(proto) proto
| #else
| #define YY_PROTO(proto) ()
| #endif
| 
| /* Returned upon end-of-file. */
| #define YY_NULL 0
| 
| /* Promotes a possibly negative, possibly signed char to an unsigned
|  * integer for use as an array index.  If the signed char is negative,
|  * we want to instead treat it as an 8-bit unsigned char, hence the
|  * double cast.
|  */
| #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
| 
| /* Enter a start condition.  This macro really ought to take a parameter,
|  * but we do it the disgusting crufty way forced on us by the ()-less
|  * definition of BEGIN.
|  */
| #define BEGIN yy_start = 1 + 2 *
| 
| /* Translate the current start state into a value that can be later handed
|  * to BEGIN to return to the state.  The YYSTATE alias is for lex
|  * compatibility.
|  */
| #define YY_START ((yy_start - 1) / 2)
| #define YYSTATE YY_START
| 
| /* Action number for EOF rule of a given start state. */
| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
| 
| /* Special action meaning "start processing a new file". */
| #define YY_NEW_FILE yyrestart( yyin )
| 
| #define YY_END_OF_BUFFER_CHAR 0
| 
| /* Size of default input buffer. */
| #define YY_BUF_SIZE 16384
| 
| typedef struct yy_buffer_state *YY_BUFFER_STATE;
| 
| extern int yyleng;
| extern FILE *yyin, *yyout;
| 
| #define EOB_ACT_CONTINUE_SCAN 0
| #define EOB_ACT_END_OF_FILE 1
| #define EOB_ACT_LAST_MATCH 2
| 
| /* The funky do-while in the following #define is used to turn the definition
|  * int a single C statement (which needs a semi-colon terminator).  This
|  * avoids problems with code like:
|  *
|  * 	if ( condition_holds )
|  *		yyless( 5 );
|  *	else
|  *		do_something_else();
|  *
|  * Prior to using the do-while the compiler would get upset at the
|  * "else" because it interpreted the "if" statement as being all
|  * done when it reached the ';' after the yyless() call.
|  */
| 
| /* Return all but the first 'n' matched characters back to the input stream. */
| 
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
| 		*yy_cp = yy_hold_char; \
| 		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
| 		} \
| 	while ( 0 )
| 
| #define unput(c) yyunput( c, yytext_ptr )
| 
| /* The following is because we cannot portably get our hands on size_t
|  * (without autoconf's help, which isn't available because we want
|  * flex-generated scanners to compile on their own).
|  */
| typedef unsigned int yy_size_t;
| 
| 
| struct yy_buffer_state
| 	{
| 	FILE *yy_input_file;
| 
| 	char *yy_ch_buf;		/* input buffer */
| 	char *yy_buf_pos;		/* current position in input buffer */
| 
| 	/* Size of input buffer in bytes, not including room for EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_buf_size;
| 
| 	/* Number of characters read into yy_ch_buf, not including EOB
| 	 * characters.
| 	 */
| 	int yy_n_chars;
| 
| 	/* Whether we "own" the buffer - i.e., we know we created it,
| 	 * and can realloc() it to grow it, and should free() it to
| 	 * delete it.
| 	 */
| 	int yy_is_our_buffer;
| 
| 	/* Whether this is an "interactive" input source; if so, and
| 	 * if we're using stdio for input, then we want to use getc()
| 	 * instead of fread(), to make sure we stop fetching input after
| 	 * each newline.
| 	 */
| 	int yy_is_interactive;
| 
| 	/* Whether we're considered to be at the beginning of a line.
| 	 * If so, '^' rules will be active on the next match, otherwise
| 	 * not.
| 	 */
| 	int yy_at_bol;
| 
| 	/* Whether to try to fill the input buffer when we reach the
| 	 * end of it.
| 	 */
| 	int yy_fill_buffer;
| 
| 	int yy_buffer_status;
| #define YY_BUFFER_NEW 0
| #define YY_BUFFER_NORMAL 1
| 	/* When an EOF's been seen but there's still some text to process
| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
| 	 * shouldn't try reading from the input source any more.  We might
| 	 * still have a bunch of tokens to match, though, because of
| 	 * possible backing-up.
| 	 *
| 	 * When we actually see the EOF, we change the status to "new"
| 	 * (via yyrestart()), so that the user can continue scanning by
| 	 * just pointing yyin at a new input file.
| 	 */
| #define YY_BUFFER_EOF_PENDING 2
| 	};
| 
| static YY_BUFFER_STATE yy_current_buffer = 0;
| 
| /* We provide macros for accessing buffer states in case in the
|  * future we want to put the buffer states in a more general
|  * "scanner state".
|  */
| #define YY_CURRENT_BUFFER yy_current_buffer
| 
| 
| /* yy_hold_char holds the character lost when yytext is formed. */
| static char yy_hold_char;
| 
| static int yy_n_chars;		/* number of characters read into yy_ch_buf */
| 
| 
| int yyleng;
| 
| /* Points to current character in buffer. */
| static char *yy_c_buf_p = (char *) 0;
| static int yy_init = 1;		/* whether we need to initialize */
| static int yy_start = 0;	/* start state number */
| 
| /* Flag which is used to allow yywrap()'s to do buffer switches
|  * instead of setting up a fresh yyin.  A bit of a hack ...
|  */
| static int yy_did_buffer_switch_on_eof;
| 
| void yyrestart YY_PROTO(( FILE *input_file ));
| 
| void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
| void yy_load_buffer_state YY_PROTO(( void ));
| YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
| void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
| void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
| void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
| #define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
| 
| YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
| YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *str ));
| YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
| 
| static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
| static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
| static void yy_flex_free YY_PROTO(( void * ));
| 
| #define yy_new_buffer yy_create_buffer
| 
| #define yy_set_interactive(is_interactive) \
| 	{ \
| 	if ( ! yy_current_buffer ) \
| 		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
| 	yy_current_buffer->yy_is_interactive = is_interactive; \
| 	}
| 
| #define yy_set_bol(at_bol) \
| 	{ \
| 	if ( ! yy_current_buffer ) \
| 		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
| 	yy_current_buffer->yy_at_bol = at_bol; \
| 	}
| 
| #define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
| 
| 
| #define YY_USES_REJECT
| typedef unsigned char YY_CHAR;
| FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
| typedef int yy_state_type;
| extern char *yytext;
| #define yytext_ptr yytext
| 
| static yy_state_type yy_get_previous_state YY_PROTO(( void ));
| static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
| static int yy_get_next_buffer YY_PROTO(( void ));
| static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
| 
| /* Done after the current pattern has been matched and before the
|  * corresponding action - sets up yytext.
|  */
| #define YY_DO_BEFORE_ACTION \
| 	yytext_ptr = yy_bp; \
| 	yytext_ptr -= yy_more_len; \
| 	yyleng = (int) (yy_cp - yytext_ptr); \
| 	yy_hold_char = *yy_cp; \
| 	*yy_cp = '\0'; \
| 	yy_c_buf_p = yy_cp;
| 
| #define YY_NUM_RULES 8
| #define YY_END_OF_BUFFER 9
| static yyconst short int yy_acclist[23] =
|     {   0,
|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,
|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,
|         7,    8
|     } ;
| 
| static yyconst short int yy_accept[14] =
|     {   0,
|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,
|        20,   23,   23
|     } ;
| 
| static yyconst int yy_ec[256] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,
| 
|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| 
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1
|     } ;
| 
| static yyconst int yy_meta[9] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1
|     } ;
| 
| static yyconst short int yy_base[13] =
|     {   0,
|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,
|        10,   10
|     } ;
| 
| static yyconst short int yy_def[13] =
|     {   0,
|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,
|        12,    0
|     } ;
| 
| static yyconst short int yy_nxt[19] =
|     {   0,
|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| static yyconst short int yy_chk[19] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| static yy_state_type yy_state_buf[YY_BUF_SIZE + 2], *yy_state_ptr;
| static char *yy_full_match;
| static int yy_lp;
| #define REJECT \
| { \
| *yy_cp = yy_hold_char; /* undo effects of setting up yytext */ \
| yy_cp = yy_full_match; /* restore poss. backed-over text */ \
| ++yy_lp; \
| goto find_rule; \
| }
| static int yy_more_flag = 0;
| static int yy_more_len = 0;
| #define yymore() (yy_more_flag = 1)
| #define YY_MORE_ADJ yy_more_len
| char *yytext;
| #line 1 "conftest.l"
| #define INITIAL 0
| #line 381 "lex.yy.c"
| 
| /* Macros after this point can all be overridden by user definitions in
|  * section 1.
|  */
| 
| #ifndef YY_SKIP_YYWRAP
| #ifdef __cplusplus
| extern "C" int yywrap YY_PROTO(( void ));
| #else
| extern int yywrap YY_PROTO(( void ));
| #endif
| #endif
| 
| #ifndef YY_NO_UNPUT
| static void yyunput YY_PROTO(( int c, char *buf_ptr ));
| #endif
| 
| #ifndef yytext_ptr
| static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
| #endif
| 
| #ifndef YY_NO_INPUT
| #ifdef __cplusplus
| static int yyinput YY_PROTO(( void ));
| #else
| static int input YY_PROTO(( void ));
| #endif
| #endif
| 
| #if YY_STACK_USED
| static int yy_start_stack_ptr = 0;
| static int yy_start_stack_depth = 0;
| static int *yy_start_stack = 0;
| #ifndef YY_NO_PUSH_STATE
| static void yy_push_state YY_PROTO(( int new_state ));
| #endif
| #ifndef YY_NO_POP_STATE
| static void yy_pop_state YY_PROTO(( void ));
| #endif
| #ifndef YY_NO_TOP_STATE
| static int yy_top_state YY_PROTO(( void ));
| #endif
| 
| #else
| #define YY_NO_PUSH_STATE 1
| #define YY_NO_POP_STATE 1
| #define YY_NO_TOP_STATE 1
| #endif
| 
| #ifdef YY_MALLOC_DECL
| YY_MALLOC_DECL
| #else
| #if __STDC__
| #ifndef __cplusplus
| #include <stdlib.h>
| #endif
| #else
| /* Just try to get by without declaring the routines.  This will fail
|  * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
|  * or sizeof(void*) != sizeof(int).
|  */
| #endif
| #endif
| 
| /* Amount of stuff to slurp up with each read. */
| #ifndef YY_READ_BUF_SIZE
| #define YY_READ_BUF_SIZE 8192
| #endif
| 
| /* Copy whatever the last rule matched to the standard output. */
| 
| #ifndef ECHO
| /* This used to be an fputs(), but since the string might contain NUL's,
|  * we now use fwrite().
|  */
| #define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
| #endif
| 
| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
|  * is returned in "result".
|  */
| #ifndef YY_INPUT
| #define YY_INPUT(buf,result,max_size) \
| 	if ( yy_current_buffer->yy_is_interactive ) \
| 		{ \
| 		int c = '*', n; \
| 		for ( n = 0; n < max_size && \
| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
| 			buf[n] = (char) c; \
| 		if ( c == '\n' ) \
| 			buf[n++] = (char) c; \
| 		if ( c == EOF && ferror( yyin ) ) \
| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 		result = n; \
| 		} \
| 	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
| 		  && ferror( yyin ) ) \
| 		YY_FATAL_ERROR( "input in flex scanner failed" );
| #endif
| 
| /* No semi-colon after return; correct usage is to write "yyterminate();" -
|  * we don't want an extra ';' after the "return" because that will cause
|  * some compilers to complain about unreachable statements.
|  */
| #ifndef yyterminate
| #define yyterminate() return YY_NULL
| #endif
| 
| /* Number of entries by which start-condition stack grows. */
| #ifndef YY_START_STACK_INCR
| #define YY_START_STACK_INCR 25
| #endif
| 
| /* Report a fatal error. */
| #ifndef YY_FATAL_ERROR
| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
| #endif
| 
| /* Default declaration of generated scanner - a define so the user can
|  * easily add parameters.
|  */
| #ifndef YY_DECL
| #define YY_DECL int yylex YY_PROTO(( void ))
| #endif
| 
| /* Code executed at the beginning of each rule, after yytext and yyleng
|  * have been set up.
|  */
| #ifndef YY_USER_ACTION
| #define YY_USER_ACTION
| #endif
| 
| /* Code executed at the end of each rule. */
| #ifndef YY_BREAK
| #define YY_BREAK break;
| #endif
| 
| #define YY_RULE_SETUP \
| 	YY_USER_ACTION
| 
| YY_DECL
| 	{
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp, *yy_bp;
| 	register int yy_act;
| 
| #line 1 "conftest.l"
| 
| #line 530 "lex.yy.c"
| 
| 	if ( yy_init )
| 		{
| 		yy_init = 0;
| 
| #ifdef YY_USER_INIT
| 		YY_USER_INIT;
| #endif
| 
| 		if ( ! yy_start )
| 			yy_start = 1;	/* first start state */
| 
| 		if ( ! yyin )
| 			yyin = stdin;
| 
| 		if ( ! yyout )
| 			yyout = stdout;
| 
| 		if ( ! yy_current_buffer )
| 			yy_current_buffer =
| 				yy_create_buffer( yyin, YY_BUF_SIZE );
| 
| 		yy_load_buffer_state();
| 		}
| 
| 	while ( 1 )		/* loops until end-of-file is reached */
| 		{
| 		yy_more_len = 0;
| 		if ( yy_more_flag )
| 			{
| 			yy_more_len = yyleng;
| 			yy_more_flag = 0;
| 			}
| 		yy_cp = yy_c_buf_p;
| 
| 		/* Support of yytext. */
| 		*yy_cp = yy_hold_char;
| 
| 		/* yy_bp points to the position in yy_ch_buf of the start of
| 		 * the current run.
| 		 */
| 		yy_bp = yy_cp;
| 
| 		yy_current_state = yy_start;
| 		yy_state_ptr = yy_state_buf;
| 		*yy_state_ptr++ = yy_current_state;
| yy_match:
| 		do
| 			{
| 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 				{
| 				yy_current_state = (int) yy_def[yy_current_state];
| 				if ( yy_current_state >= 13 )
| 					yy_c = yy_meta[(unsigned int) yy_c];
| 				}
| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 			*yy_state_ptr++ = yy_current_state;
| 			++yy_cp;
| 			}
| 		while ( yy_base[yy_current_state] != 10 );
| 
| yy_find_action:
| 		yy_current_state = *--yy_state_ptr;
| 		yy_lp = yy_accept[yy_current_state];
| find_rule: /* we branch to this label when backing up */
| 		for ( ; ; ) /* until we find what rule we matched */
| 			{
| 			if ( yy_lp && yy_lp < yy_accept[yy_current_state + 1] )
| 				{
| 				yy_act = yy_acclist[yy_lp];
| 					{
| 					yy_full_match = yy_cp;
| 					break;
| 					}
| 				}
| 			--yy_cp;
| 			yy_current_state = *--yy_state_ptr;
| 			yy_lp = yy_accept[yy_current_state];
| 			}
| 
| 		YY_DO_BEFORE_ACTION;
| 
| 
| do_action:	/* This label is used only to access EOF actions. */
| 
| 
| 		switch ( yy_act )
| 	{ /* beginning of action switch */
| case 1:
| YY_RULE_SETUP
| #line 2 "conftest.l"
| { ECHO; }
| 	YY_BREAK
| case 2:
| YY_RULE_SETUP
| #line 3 "conftest.l"
| { REJECT; }
| 	YY_BREAK
| case 3:
| YY_RULE_SETUP
| #line 4 "conftest.l"
| { yymore (); }
| 	YY_BREAK
| case 4:
| YY_RULE_SETUP
| #line 5 "conftest.l"
| { yyless (1); }
| 	YY_BREAK
| case 5:
| YY_RULE_SETUP
| #line 6 "conftest.l"
| { /* IRIX 6.5 flex 2.5.4 underquotes its yyless argument.  */
|     yyless ((input () != 0)); }
| 	YY_BREAK
| case 6:
| YY_RULE_SETUP
| #line 8 "conftest.l"
| { unput (yytext[0]); }
| 	YY_BREAK
| case 7:
| YY_RULE_SETUP
| #line 9 "conftest.l"
| { BEGIN INITIAL; }
| 	YY_BREAK
| case 8:
| YY_RULE_SETUP
| #line 10 "conftest.l"
| ECHO;
| 	YY_BREAK
| #line 661 "lex.yy.c"
| 			case YY_STATE_EOF(INITIAL):
| 				yyterminate();
| 
| 	case YY_END_OF_BUFFER:
| 		{
| 		/* Amount of text matched not including the EOB char. */
| 		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
| 
| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
| 		*yy_cp = yy_hold_char;
| 
| 		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
| 			{
| 			/* We're scanning a new file or input source.  It's
| 			 * possible that this happened because the user
| 			 * just pointed yyin at a new source and called
| 			 * yylex().  If so, then we have to assure
| 			 * consistency between yy_current_buffer and our
| 			 * globals.  Here is the right place to do so, because
| 			 * this is the first action (other than possibly a
| 			 * back-up) that will match for the new input source.
| 			 */
| 			yy_n_chars = yy_current_buffer->yy_n_chars;
| 			yy_current_buffer->yy_input_file = yyin;
| 			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
| 			}
| 
| 		/* Note that here we test for yy_c_buf_p "<=" to the position
| 		 * of the first EOB in the buffer, since yy_c_buf_p will
| 		 * already have been incremented past the NUL character
| 		 * (since all states make transitions on EOB to the
| 		 * end-of-buffer state).  Contrast this with the test
| 		 * in input().
| 		 */
| 		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
| 			{ /* This was really a NUL. */
| 			yy_state_type yy_next_state;
| 
| 			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
| 
| 			yy_current_state = yy_get_previous_state();
| 
| 			/* Okay, we're now positioned to make the NUL
| 			 * transition.  We couldn't have
| 			 * yy_get_previous_state() go ahead and do it
| 			 * for us because it doesn't know how to deal
| 			 * with the possibility of jamming (and we don't
| 			 * want to build jamming into it because then it
| 			 * will run more slowly).
| 			 */
| 
| 			yy_next_state = yy_try_NUL_trans( yy_current_state );
| 
| 			yy_bp = yytext_ptr + YY_MORE_ADJ;
| 
| 			if ( yy_next_state )
| 				{
| 				/* Consume the NUL. */
| 				yy_cp = ++yy_c_buf_p;
| 				yy_current_state = yy_next_state;
| 				goto yy_match;
| 				}
| 
| 			else
| 				{
| 				yy_cp = yy_c_buf_p;
| 				goto yy_find_action;
| 				}
| 			}
| 
| 		else switch ( yy_get_next_buffer() )
| 			{
| 			case EOB_ACT_END_OF_FILE:
| 				{
| 				yy_did_buffer_switch_on_eof = 0;
| 
| 				if ( yywrap() )
| 					{
| 					/* Note: because we've taken care in
| 					 * yy_get_next_buffer() to have set up
| 					 * yytext, we can now set up
| 					 * yy_c_buf_p so that if some total
| 					 * hoser (like flex itself) wants to
| 					 * call the scanner after we return the
| 					 * YY_NULL, it'll still work - another
| 					 * YY_NULL will get returned.
| 					 */
| 					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
| 
| 					yy_act = YY_STATE_EOF(YY_START);
| 					goto do_action;
| 					}
| 
| 				else
| 					{
| 					if ( ! yy_did_buffer_switch_on_eof )
| 						YY_NEW_FILE;
| 					}
| 				break;
| 				}
| 
| 			case EOB_ACT_CONTINUE_SCAN:
| 				yy_c_buf_p =
| 					yytext_ptr + yy_amount_of_matched_text;
| 
| 				yy_current_state = yy_get_previous_state();
| 
| 				yy_cp = yy_c_buf_p;
| 				yy_bp = yytext_ptr + YY_MORE_ADJ;
| 				goto yy_match;
| 
| 			case EOB_ACT_LAST_MATCH:
| 				yy_c_buf_p =
| 				&yy_current_buffer->yy_ch_buf[yy_n_chars];
| 
| 				yy_current_state = yy_get_previous_state();
| 
| 				yy_cp = yy_c_buf_p;
| 				yy_bp = yytext_ptr + YY_MORE_ADJ;
| 				goto yy_find_action;
| 			}
| 		break;
| 		}
| 
| 	default:
| 		YY_FATAL_ERROR(
| 			"fatal flex scanner internal error--no action found" );
| 	} /* end of action switch */
| 		} /* end of scanning one token */
| 	} /* end of yylex */
| 
| 
| /* yy_get_next_buffer - try to read in a new buffer
|  *
|  * Returns a code representing an action:
|  *	EOB_ACT_LAST_MATCH -
|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
|  *	EOB_ACT_END_OF_FILE - end of file
|  */
| 
| static int yy_get_next_buffer()
| 	{
| 	register char *dest = yy_current_buffer->yy_ch_buf;
| 	register char *source = yytext_ptr;
| 	register int number_to_move, i;
| 	int ret_val;
| 
| 	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
| 		YY_FATAL_ERROR(
| 		"fatal flex scanner internal error--end of buffer missed" );
| 
| 	if ( yy_current_buffer->yy_fill_buffer == 0 )
| 		{ /* Don't try to fill the buffer, so this is an EOF. */
| 		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
| 			{
| 			/* We matched a singled characater, the EOB, so
| 			 * treat this as a final EOF.
| 			 */
| 			return EOB_ACT_END_OF_FILE;
| 			}
| 
| 		else
| 			{
| 			/* We matched some text prior to the EOB, first
| 			 * process it.
| 			 */
| 			return EOB_ACT_LAST_MATCH;
| 			}
| 		}
| 
| 	/* Try to read more data. */
| 
| 	/* First move last chars to start of buffer. */
| 	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
| 
| 	for ( i = 0; i < number_to_move; ++i )
| 		*(dest++) = *(source++);
| 
| 	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
| 		/* don't do the read, it's not guaranteed to return an EOF,
| 		 * just force an EOF
| 		 */
| 		yy_n_chars = 0;
| 
| 	else
| 		{
| 		int num_to_read =
| 			yy_current_buffer->yy_buf_size - number_to_move - 1;
| 
| 		while ( num_to_read <= 0 )
| 			{ /* Not enough room in the buffer - grow it. */
| #ifdef YY_USES_REJECT
| 			YY_FATAL_ERROR(
| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
| #else
| 
| 			/* just a shorter name for the current buffer */
| 			YY_BUFFER_STATE b = yy_current_buffer;
| 
| 			int yy_c_buf_p_offset =
| 				(int) (yy_c_buf_p - b->yy_ch_buf);
| 
| 			if ( b->yy_is_our_buffer )
| 				{
| 				int new_size = b->yy_buf_size * 2;
| 
| 				if ( new_size <= 0 )
| 					b->yy_buf_size += b->yy_buf_size / 8;
| 				else
| 					b->yy_buf_size *= 2;
| 
| 				b->yy_ch_buf = (char *)
| 					/* Include room in for 2 EOB chars. */
| 					yy_flex_realloc( (void *) b->yy_ch_buf,
| 							 b->yy_buf_size + 2 );
| 				}
| 			else
| 				/* Can't grow it, we don't own it. */
| 				b->yy_ch_buf = 0;
| 
| 			if ( ! b->yy_ch_buf )
| 				YY_FATAL_ERROR(
| 				"fatal error - scanner input buffer overflow" );
| 
| 			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
| 
| 			num_to_read = yy_current_buffer->yy_buf_size -
| 						number_to_move - 1;
| #endif
| 			}
| 
| 		if ( num_to_read > YY_READ_BUF_SIZE )
| 			num_to_read = YY_READ_BUF_SIZE;
| 
| 		/* Read in more data. */
| 		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
| 			yy_n_chars, num_to_read );
| 		}
| 
| 	if ( yy_n_chars == 0 )
| 		{
| 		if ( number_to_move == YY_MORE_ADJ )
| 			{
| 			ret_val = EOB_ACT_END_OF_FILE;
| 			yyrestart( yyin );
| 			}
| 
| 		else
| 			{
| 			ret_val = EOB_ACT_LAST_MATCH;
| 			yy_current_buffer->yy_buffer_status =
| 				YY_BUFFER_EOF_PENDING;
| 			}
| 		}
| 
| 	else
| 		ret_val = EOB_ACT_CONTINUE_SCAN;
| 
| 	yy_n_chars += number_to_move;
| 	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
| 	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
| 
| 	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
| 
| 	return ret_val;
| 	}
| 
| 
| /* yy_get_previous_state - get the state just before the EOB char was reached */
| 
| static yy_state_type yy_get_previous_state()
| 	{
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp;
| 
| 	yy_current_state = yy_start;
| 	yy_state_ptr = yy_state_buf;
| 	*yy_state_ptr++ = yy_current_state;
| 
| 	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
| 		{
| 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 			{
| 			yy_current_state = (int) yy_def[yy_current_state];
| 			if ( yy_current_state >= 13 )
| 				yy_c = yy_meta[(unsigned int) yy_c];
| 			}
| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 		*yy_state_ptr++ = yy_current_state;
| 		}
| 
| 	return yy_current_state;
| 	}
| 
| 
| /* yy_try_NUL_trans - try to make a transition on the NUL character
|  *
|  * synopsis
|  *	next_state = yy_try_NUL_trans( current_state );
|  */
| 
| #ifdef YY_USE_PROTOS
| static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
| #else
| static yy_state_type yy_try_NUL_trans( yy_current_state )
| yy_state_type yy_current_state;
| #endif
| 	{
| 	register int yy_is_jam;
| 
| 	register YY_CHAR yy_c = 1;
| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 		{
| 		yy_current_state = (int) yy_def[yy_current_state];
| 		if ( yy_current_state >= 13 )
| 			yy_c = yy_meta[(unsigned int) yy_c];
| 		}
| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 	*yy_state_ptr++ = yy_current_state;
| 	yy_is_jam = (yy_current_state == 12);
| 
| 	return yy_is_jam ? 0 : yy_current_state;
| 	}
| 
| 
| #ifndef YY_NO_UNPUT
| #ifdef YY_USE_PROTOS
| static void yyunput( int c, register char *yy_bp )
| #else
| static void yyunput( c, yy_bp )
| int c;
| register char *yy_bp;
| #endif
| 	{
| 	register char *yy_cp = yy_c_buf_p;
| 
| 	/* undo effects of setting up yytext */
| 	*yy_cp = yy_hold_char;
| 
| 	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
| 		{ /* need to shift things up to make room */
| 		/* +2 for EOB chars. */
| 		register int number_to_move = yy_n_chars + 2;
| 		register char *dest = &yy_current_buffer->yy_ch_buf[
| 					yy_current_buffer->yy_buf_size + 2];
| 		register char *source =
| 				&yy_current_buffer->yy_ch_buf[number_to_move];
| 
| 		while ( source > yy_current_buffer->yy_ch_buf )
| 			*--dest = *--source;
| 
| 		yy_cp += (int) (dest - source);
| 		yy_bp += (int) (dest - source);
| 		yy_n_chars = yy_current_buffer->yy_buf_size;
| 
| 		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
| 		}
| 
| 	*--yy_cp = (char) c;
| 
| 
| 	yytext_ptr = yy_bp;
| 	yy_hold_char = *yy_cp;
| 	yy_c_buf_p = yy_cp;
| 	}
| #endif	/* ifndef YY_NO_UNPUT */
| 
| 
| #ifdef __cplusplus
| static int yyinput()
| #else
| static int input()
| #endif
| 	{
| 	int c;
| 
| 	*yy_c_buf_p = yy_hold_char;
| 
| 	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
| 		{
| 		/* yy_c_buf_p now points to the character we want to return.
| 		 * If this occurs *before* the EOB characters, then it's a
| 		 * valid NUL; if not, then we've hit the end of the buffer.
| 		 */
| 		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
| 			/* This was really a NUL. */
| 			*yy_c_buf_p = '\0';
| 
| 		else
| 			{ /* need more input */
| 			yytext_ptr = yy_c_buf_p;
| 			++yy_c_buf_p;
| 
| 			switch ( yy_get_next_buffer() )
| 				{
| 				case EOB_ACT_END_OF_FILE:
| 					{
| 					if ( yywrap() )
| 						{
| 						yy_c_buf_p =
| 						yytext_ptr + YY_MORE_ADJ;
| 						return EOF;
| 						}
| 
| 					if ( ! yy_did_buffer_switch_on_eof )
| 						YY_NEW_FILE;
| #ifdef __cplusplus
| 					return yyinput();
| #else
| 					return input();
| #endif
| 					}
| 
| 				case EOB_ACT_CONTINUE_SCAN:
| 					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
| 					break;
| 
| 				case EOB_ACT_LAST_MATCH:
| #ifdef __cplusplus
| 					YY_FATAL_ERROR(
| 					"unexpected last match in yyinput()" );
| #else
| 					YY_FATAL_ERROR(
| 					"unexpected last match in input()" );
| #endif
| 				}
| 			}
| 		}
| 
| 	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
| 	*yy_c_buf_p = '\0';	/* preserve yytext */
| 	yy_hold_char = *++yy_c_buf_p;
| 
| 
| 	return c;
| 	}
| 
| 
| #ifdef YY_USE_PROTOS
| void yyrestart( FILE *input_file )
| #else
| void yyrestart( input_file )
| FILE *input_file;
| #endif
| 	{
| 	if ( ! yy_current_buffer )
| 		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
| 
| 	yy_init_buffer( yy_current_buffer, input_file );
| 	yy_load_buffer_state();
| 	}
| 
| 
| #ifdef YY_USE_PROTOS
| void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
| #else
| void yy_switch_to_buffer( new_buffer )
| YY_BUFFER_STATE new_buffer;
| #endif
| 	{
| 	if ( yy_current_buffer == new_buffer )
| 		return;
| 
| 	if ( yy_current_buffer )
| 		{
| 		/* Flush out information for old buffer. */
| 		*yy_c_buf_p = yy_hold_char;
| 		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
| 		yy_current_buffer->yy_n_chars = yy_n_chars;
| 		}
| 
| 	yy_current_buffer = new_buffer;
| 	yy_load_buffer_state();
| 
| 	/* We don't actually know whether we did this switch during
| 	 * EOF (yywrap()) processing, but the only time this flag
| 	 * is looked at is after yywrap() is called, so it's safe
| 	 * to go ahead and always set it.
| 	 */
| 	yy_did_buffer_switch_on_eof = 1;
| 	}
| 
| 
| #ifdef YY_USE_PROTOS
| void yy_load_buffer_state( void )
| #else
| void yy_load_buffer_state()
| #endif
| 	{
| 	yy_n_chars = yy_current_buffer->yy_n_chars;
| 	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
| 	yyin = yy_current_buffer->yy_input_file;
| 	yy_hold_char = *yy_c_buf_p;
| 	}
| 
| 
| #ifdef YY_USE_PROTOS
| YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
| #else
| YY_BUFFER_STATE yy_create_buffer( file, size )
| FILE *file;
| int size;
| #endif
| 	{
| 	YY_BUFFER_STATE b;
| 
| 	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_buf_size = size;
| 
| 	/* yy_ch_buf has to be 2 characters longer than the size given because
| 	 * we need to put in 2 end-of-buffer characters.
| 	 */
| 	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
| 	if ( ! b->yy_ch_buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_is_our_buffer = 1;
| 
| 	yy_init_buffer( b, file );
| 
| 	return b;
| 	}
| 
| 
| #ifdef YY_USE_PROTOS
| void yy_delete_buffer( YY_BUFFER_STATE b )
| #else
| void yy_delete_buffer( b )
| YY_BUFFER_STATE b;
| #endif
| 	{
| 	if ( ! b )
| 		return;
| 
| 	if ( b == yy_current_buffer )
| 		yy_current_buffer = (YY_BUFFER_STATE) 0;
| 
| 	if ( b->yy_is_our_buffer )
| 		yy_flex_free( (void *) b->yy_ch_buf );
| 
| 	yy_flex_free( (void *) b );
| 	}
| 
| 
| #ifndef YY_ALWAYS_INTERACTIVE
| #ifndef YY_NEVER_INTERACTIVE
| extern int isatty YY_PROTO(( int ));
| #endif
| #endif
| 
| #ifdef YY_USE_PROTOS
| void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
| #else
| void yy_init_buffer( b, file )
| YY_BUFFER_STATE b;
| FILE *file;
| #endif
| 
| 
| 	{
| 	yy_flush_buffer( b );
| 
| 	b->yy_input_file = file;
| 	b->yy_fill_buffer = 1;
| 
| #if YY_ALWAYS_INTERACTIVE
| 	b->yy_is_interactive = 1;
| #else
| #if YY_NEVER_INTERACTIVE
| 	b->yy_is_interactive = 0;
| #else
| 	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
| #endif
| #endif
| 	}
| 
| 
| #ifdef YY_USE_PROTOS
| void yy_flush_buffer( YY_BUFFER_STATE b )
| #else
| void yy_flush_buffer( b )
| YY_BUFFER_STATE b;
| #endif
| 
| 	{
| 	b->yy_n_chars = 0;
| 
| 	/* We always need two end-of-buffer characters.  The first causes
| 	 * a transition to the end-of-buffer state.  The second causes
| 	 * a jam in that state.
| 	 */
| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b->yy_buf_pos = &b->yy_ch_buf[0];
| 
| 	b->yy_at_bol = 1;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	if ( b == yy_current_buffer )
| 		yy_load_buffer_state();
| 	}
| 
| 
| #ifndef YY_NO_SCAN_BUFFER
| #ifdef YY_USE_PROTOS
| YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
| #else
| YY_BUFFER_STATE yy_scan_buffer( base, size )
| char *base;
| yy_size_t size;
| #endif
| 	{
| 	YY_BUFFER_STATE b;
| 
| 	if ( size < 2 ||
| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
| 		/* They forgot to leave room for the EOB's. */
| 		return 0;
| 
| 	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
| 
| 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
| 	b->yy_buf_pos = b->yy_ch_buf = base;
| 	b->yy_is_our_buffer = 0;
| 	b->yy_input_file = 0;
| 	b->yy_n_chars = b->yy_buf_size;
| 	b->yy_is_interactive = 0;
| 	b->yy_at_bol = 1;
| 	b->yy_fill_buffer = 0;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	yy_switch_to_buffer( b );
| 
| 	return b;
| 	}
| #endif
| 
| 
| #ifndef YY_NO_SCAN_STRING
| #ifdef YY_USE_PROTOS
| YY_BUFFER_STATE yy_scan_string( yyconst char *str )
| #else
| YY_BUFFER_STATE yy_scan_string( str )
| yyconst char *str;
| #endif
| 	{
| 	int len;
| 	for ( len = 0; str[len]; ++len )
| 		;
| 
| 	return yy_scan_bytes( str, len );
| 	}
| #endif
| 
| 
| #ifndef YY_NO_SCAN_BYTES
| #ifdef YY_USE_PROTOS
| YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
| #else
| YY_BUFFER_STATE yy_scan_bytes( bytes, len )
| yyconst char *bytes;
| int len;
| #endif
| 	{
| 	YY_BUFFER_STATE b;
| 	char *buf;
| 	yy_size_t n;
| 	int i;
| 
| 	/* Get memory for full buffer, including space for trailing EOB's. */
| 	n = len + 2;
| 	buf = (char *) yy_flex_alloc( n );
| 	if ( ! buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
| 
| 	for ( i = 0; i < len; ++i )
| 		buf[i] = bytes[i];
| 
| 	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b = yy_scan_buffer( buf, n );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
| 
| 	/* It's okay to grow etc. this buffer, and we should throw it
| 	 * away when we're done.
| 	 */
| 	b->yy_is_our_buffer = 1;
| 
| 	return b;
| 	}
| #endif
| 
| 
| #ifndef YY_NO_PUSH_STATE
| #ifdef YY_USE_PROTOS
| static void yy_push_state( int new_state )
| #else
| static void yy_push_state( new_state )
| int new_state;
| #endif
| 	{
| 	if ( yy_start_stack_ptr >= yy_start_stack_depth )
| 		{
| 		yy_size_t new_size;
| 
| 		yy_start_stack_depth += YY_START_STACK_INCR;
| 		new_size = yy_start_stack_depth * sizeof( int );
| 
| 		if ( ! yy_start_stack )
| 			yy_start_stack = (int *) yy_flex_alloc( new_size );
| 
| 		else
| 			yy_start_stack = (int *) yy_flex_realloc(
| 					(void *) yy_start_stack, new_size );
| 
| 		if ( ! yy_start_stack )
| 			YY_FATAL_ERROR(
| 			"out of memory expanding start-condition stack" );
| 		}
| 
| 	yy_start_stack[yy_start_stack_ptr++] = YY_START;
| 
| 	BEGIN(new_state);
| 	}
| #endif
| 
| 
| #ifndef YY_NO_POP_STATE
| static void yy_pop_state()
| 	{
| 	if ( --yy_start_stack_ptr < 0 )
| 		YY_FATAL_ERROR( "start-condition stack underflow" );
| 
| 	BEGIN(yy_start_stack[yy_start_stack_ptr]);
| 	}
| #endif
| 
| 
| #ifndef YY_NO_TOP_STATE
| static int yy_top_state()
| 	{
| 	return yy_start_stack[yy_start_stack_ptr - 1];
| 	}
| #endif
| 
| #ifndef YY_EXIT_FAILURE
| #define YY_EXIT_FAILURE 2
| #endif
| 
| #ifdef YY_USE_PROTOS
| static void yy_fatal_error( yyconst char msg[] )
| #else
| static void yy_fatal_error( msg )
| char msg[];
| #endif
| 	{
| 	(void) fprintf( stderr, "%s\n", msg );
| 	exit( YY_EXIT_FAILURE );
| 	}
| 
| 
| 
| /* Redefine yyless() so it works in section 3 code. */
| 
| #undef yyless
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
| 		yytext[yyleng] = yy_hold_char; \
| 		yy_c_buf_p = yytext + n - YY_MORE_ADJ; \
| 		yy_hold_char = *yy_c_buf_p; \
| 		*yy_c_buf_p = '\0'; \
| 		yyleng = n; \
| 		} \
| 	while ( 0 )
| 
| 
| /* Internal utility routines. */
| 
| #ifndef yytext_ptr
| #ifdef YY_USE_PROTOS
| static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
| #else
| static void yy_flex_strncpy( s1, s2, n )
| char *s1;
| yyconst char *s2;
| int n;
| #endif
| 	{
| 	register int i;
| 	for ( i = 0; i < n; ++i )
| 		s1[i] = s2[i];
| 	}
| #endif
| 
| 
| #ifdef YY_USE_PROTOS
| static void *yy_flex_alloc( yy_size_t size )
| #else
| static void *yy_flex_alloc( size )
| yy_size_t size;
| #endif
| 	{
| 	return (void *) malloc( size );
| 	}
| 
| #ifdef YY_USE_PROTOS
| static void *yy_flex_realloc( void *ptr, yy_size_t size )
| #else
| static void *yy_flex_realloc( ptr, size )
| void *ptr;
| yy_size_t size;
| #endif
| 	{
| 	/* The cast to (char *) in the following accommodates both
| 	 * implementations that use char* generic pointers, and those
| 	 * that use void* generic pointers.  It works with the latter
| 	 * because both ANSI C and C++ allow castless assignment from
| 	 * any pointer type to void*, and deal with argument conversions
| 	 * as though doing an assignment.
| 	 */
| 	return (void *) realloc( (char *) ptr, size );
| 	}
| 
| #ifdef YY_USE_PROTOS
| static void yy_flex_free( void *ptr )
| #else
| static void yy_flex_free( ptr )
| void *ptr;
| #endif
| 	{
| 	free( ptr );
| 	}
| 
| #if YY_MAIN
| int main()
| 	{
| 	yylex();
| 	return 0;
| 	}
| #endif
| #line 10 "conftest.l"
| 
| #ifdef YYTEXT_POINTER
| extern char *yytext;
| #endif
| int
| main (void)
| {
|   return ! yylex () + ! yywrap ();
| }
configure:13473: gcc -o conftest.exe -g -O2   conftest.c -ll  >&5
/usr/lib/gcc/x86_64-pc-cygwin/11/../../../../x86_64-pc-cygwin/bin/ld: cannot find -ll: No such file or directory
collect2: error: ld returned 1 exit status
configure:13473: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "GNU Bison"
| #define PACKAGE_TARNAME "bison"
| #define PACKAGE_VERSION "3.8"
| #define PACKAGE_STRING "GNU Bison 3.8"
| #define PACKAGE_BUGREPORT "bug-bison@gnu.org"
| #define PACKAGE_URL "https://www.gnu.org/software/bison/"
| #define PACKAGE_COPYRIGHT_YEAR 2021
| #define PACKAGE "bison"
| #define VERSION "3.8"
| #define HAVE_STDIO_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_SOCKET_H 1
| #define HAVE_STDIO_EXT_H 1
| #define HAVE_FEATURES_H 1
| #define HAVE_GETOPT_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_CRTDEFS_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_THREADS_H 1
| #define HAVE_MATH_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_SPAWN_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_TIMES_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_TERMIOS_H 1
| #define HAVE_DIRENT_H 1
| #define STDC_HEADERS 1
| #define _ALL_SOURCE 1
| #define _DARWIN_C_SOURCE 1
| #define _GNU_SOURCE 1
| #define _HPUX_ALT_XOPEN_SOCKET_API 1
| #define _NETBSD_SOURCE 1
| #define _OPENBSD_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define __STDC_WANT_IEC_60559_ATTRIBS_EXT__ 1
| #define __STDC_WANT_IEC_60559_BFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_DFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_FUNCS_EXT__ 1
| #define __STDC_WANT_IEC_60559_TYPES_EXT__ 1
| #define __STDC_WANT_LIB_EXT2__ 1
| #define __STDC_WANT_MATH_SPEC_FUNCS__ 1
| #define _TANDEM_SOURCE 1
| #define __EXTENSIONS__ 1
| #define HAVE_TCDRAIN 1
| #define HAVE_CANONICALIZE_FILE_NAME 1
| #define HAVE_FACCESSAT 1
| #define HAVE_REALPATH 1
| #define HAVE_LSTAT 1
| #define HAVE_READLINKAT 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCNTL 1
| #define HAVE_SYMLINK 1
| #define HAVE_FFSL 1
| #define HAVE_VASNPRINTF 1
| #define HAVE_SNPRINTF 1
| #define HAVE_FSYNC 1
| #define HAVE_GETPROGNAME 1
| #define HAVE_GETRUSAGE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_ISWCNTRL 1
| #define HAVE_ISWBLANK 1
| #define HAVE_MBSINIT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_ISASCII 1
| #define HAVE_MPROTECT 1
| #define HAVE_STRERROR_R 1
| #define HAVE___XPG_STRERROR_R 1
| #define HAVE_PIPE 1
| #define HAVE_PIPE2 1
| #define HAVE_READLINK 1
| #define HAVE_SETENV 1
| #define HAVE_LINK 1
| #define HAVE_SIGACTION 1
| #define HAVE_SIGALTSTACK 1
| #define HAVE_SIGINTERRUPT 1
| #define HAVE_STPNCPY 1
| #define HAVE_STRNDUP 1
| #define HAVE_WCWIDTH 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_MEMPCPY 1
| #define HAVE_FSTATAT 1
| #define HAVE_GETDELIM 1
| #define HAVE_GETDTABLESIZE 1
| #define HAVE_OPENAT 1
| #define HAVE_CATGETS 1
| #define HAVE_SETLOCALE 1
| /* end confdefs.h.  */
| /* A lexical scanner generated by flex */
| 
| /* Scanner skeleton version:
|  * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.85 95/04/24 10:48:47 vern Exp $
|  */
| 
| #define FLEX_SCANNER
| #define YY_FLEX_MAJOR_VERSION 2
| #define YY_FLEX_MINOR_VERSION 5
| 
| #include <stdio.h>
| 
| 
| /* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
| #ifdef c_plusplus
| #ifndef __cplusplus
| #define __cplusplus
| #endif
| #endif
| 
| 
| #ifdef __cplusplus
| 
| #include <stdlib.h>
| #include <unistd.h>
| 
| /* Use prototypes in function declarations. */
| #define YY_USE_PROTOS
| 
| /* The "const" storage-class-modifier is valid. */
| #define YY_USE_CONST
| 
| #else	/* ! __cplusplus */
| 
| #if __STDC__
| 
| #define YY_USE_PROTOS
| #define YY_USE_CONST
| 
| #endif	/* __STDC__ */
| #endif	/* ! __cplusplus */
| 
| #ifdef __TURBOC__
|  #pragma warn -rch
|  #pragma warn -use
| #include <io.h>
| #include <stdlib.h>
| #define YY_USE_CONST
| #define YY_USE_PROTOS
| #endif
| 
| #ifdef YY_USE_CONST
| #define yyconst const
| #else
| #define yyconst
| #endif
| 
| 
| #ifdef YY_USE_PROTOS
| #define YY_PROTO(proto) proto
| #else
| #define YY_PROTO(proto) ()
| #endif
| 
| /* Returned upon end-of-file. */
| #define YY_NULL 0
| 
| /* Promotes a possibly negative, possibly signed char to an unsigned
|  * integer for use as an array index.  If the signed char is negative,
|  * we want to instead treat it as an 8-bit unsigned char, hence the
|  * double cast.
|  */
| #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
| 
| /* Enter a start condition.  This macro really ought to take a parameter,
|  * but we do it the disgusting crufty way forced on us by the ()-less
|  * definition of BEGIN.
|  */
| #define BEGIN yy_start = 1 + 2 *
| 
| /* Translate the current start state into a value that can be later handed
|  * to BEGIN to return to the state.  The YYSTATE alias is for lex
|  * compatibility.
|  */
| #define YY_START ((yy_start - 1) / 2)
| #define YYSTATE YY_START
| 
| /* Action number for EOF rule of a given start state. */
| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
| 
| /* Special action meaning "start processing a new file". */
| #define YY_NEW_FILE yyrestart( yyin )
| 
| #define YY_END_OF_BUFFER_CHAR 0
| 
| /* Size of default input buffer. */
| #define YY_BUF_SIZE 16384
| 
| typedef struct yy_buffer_state *YY_BUFFER_STATE;
| 
| extern int yyleng;
| extern FILE *yyin, *yyout;
| 
| #define EOB_ACT_CONTINUE_SCAN 0
| #define EOB_ACT_END_OF_FILE 1
| #define EOB_ACT_LAST_MATCH 2
| 
| /* The funky do-while in the following #define is used to turn the definition
|  * int a single C statement (which needs a semi-colon terminator).  This
|  * avoids problems with code like:
|  *
|  * 	if ( condition_holds )
|  *		yyless( 5 );
|  *	else
|  *		do_something_else();
|  *
|  * Prior to using the do-while the compiler would get upset at the
|  * "else" because it interpreted the "if" statement as being all
|  * done when it reached the ';' after the yyless() call.
|  */
| 
| /* Return all but the first 'n' matched characters back to the input stream. */
| 
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
| 		*yy_cp = yy_hold_char; \
| 		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
| 		} \
| 	while ( 0 )
| 
| #define unput(c) yyunput( c, yytext_ptr )
| 
| /* The following is because we cannot portably get our hands on size_t
|  * (without autoconf's help, which isn't available because we want
|  * flex-generated scanners to compile on their own).
|  */
| typedef unsigned int yy_size_t;
| 
| 
| struct yy_buffer_state
| 	{
| 	FILE *yy_input_file;
| 
| 	char *yy_ch_buf;		/* input buffer */
| 	char *yy_buf_pos;		/* current position in input buffer */
| 
| 	/* Size of input buffer in bytes, not including room for EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_buf_size;
| 
| 	/* Number of characters read into yy_ch_buf, not including EOB
| 	 * characters.
| 	 */
| 	int yy_n_chars;
| 
| 	/* Whether we "own" the buffer - i.e., we know we created it,
| 	 * and can realloc() it to grow it, and should free() it to
| 	 * delete it.
| 	 */
| 	int yy_is_our_buffer;
| 
| 	/* Whether this is an "interactive" input source; if so, and
| 	 * if we're using stdio for input, then we want to use getc()
| 	 * instead of fread(), to make sure we stop fetching input after
| 	 * each newline.
| 	 */
| 	int yy_is_interactive;
| 
| 	/* Whether we're considered to be at the beginning of a line.
| 	 * If so, '^' rules will be active on the next match, otherwise
| 	 * not.
| 	 */
| 	int yy_at_bol;
| 
| 	/* Whether to try to fill the input buffer when we reach the
| 	 * end of it.
| 	 */
| 	int yy_fill_buffer;
| 
| 	int yy_buffer_status;
| #define YY_BUFFER_NEW 0
| #define YY_BUFFER_NORMAL 1
| 	/* When an EOF's been seen but there's still some text to process
| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
| 	 * shouldn't try reading from the input source any more.  We might
| 	 * still have a bunch of tokens to match, though, because of
| 	 * possible backing-up.
| 	 *
| 	 * When we actually see the EOF, we change the status to "new"
| 	 * (via yyrestart()), so that the user can continue scanning by
| 	 * just pointing yyin at a new input file.
| 	 */
| #define YY_BUFFER_EOF_PENDING 2
| 	};
| 
| static YY_BUFFER_STATE yy_current_buffer = 0;
| 
| /* We provide macros for accessing buffer states in case in the
|  * future we want to put the buffer states in a more general
|  * "scanner state".
|  */
| #define YY_CURRENT_BUFFER yy_current_buffer
| 
| 
| /* yy_hold_char holds the character lost when yytext is formed. */
| static char yy_hold_char;
| 
| static int yy_n_chars;		/* number of characters read into yy_ch_buf */
| 
| 
| int yyleng;
| 
| /* Points to current character in buffer. */
| static char *yy_c_buf_p = (char *) 0;
| static int yy_init = 1;		/* whether we need to initialize */
| static int yy_start = 0;	/* start state number */
| 
| /* Flag which is used to allow yywrap()'s to do buffer switches
|  * instead of setting up a fresh yyin.  A bit of a hack ...
|  */
| static int yy_did_buffer_switch_on_eof;
| 
| void yyrestart YY_PROTO(( FILE *input_file ));
| 
| void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
| void yy_load_buffer_state YY_PROTO(( void ));
| YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
| void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
| void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
| void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
| #define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
| 
| YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
| YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *str ));
| YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
| 
| static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
| static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
| static void yy_flex_free YY_PROTO(( void * ));
| 
| #define yy_new_buffer yy_create_buffer
| 
| #define yy_set_interactive(is_interactive) \
| 	{ \
| 	if ( ! yy_current_buffer ) \
| 		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
| 	yy_current_buffer->yy_is_interactive = is_interactive; \
| 	}
| 
| #define yy_set_bol(at_bol) \
| 	{ \
| 	if ( ! yy_current_buffer ) \
| 		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
| 	yy_current_buffer->yy_at_bol = at_bol; \
| 	}
| 
| #define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
| 
| 
| #define YY_USES_REJECT
| typedef unsigned char YY_CHAR;
| FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
| typedef int yy_state_type;
| extern char *yytext;
| #define yytext_ptr yytext
| 
| static yy_state_type yy_get_previous_state YY_PROTO(( void ));
| static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
| static int yy_get_next_buffer YY_PROTO(( void ));
| static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
| 
| /* Done after the current pattern has been matched and before the
|  * corresponding action - sets up yytext.
|  */
| #define YY_DO_BEFORE_ACTION \
| 	yytext_ptr = yy_bp; \
| 	yytext_ptr -= yy_more_len; \
| 	yyleng = (int) (yy_cp - yytext_ptr); \
| 	yy_hold_char = *yy_cp; \
| 	*yy_cp = '\0'; \
| 	yy_c_buf_p = yy_cp;
| 
| #define YY_NUM_RULES 8
| #define YY_END_OF_BUFFER 9
| static yyconst short int yy_acclist[23] =
|     {   0,
|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,
|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,
|         7,    8
|     } ;
| 
| static yyconst short int yy_accept[14] =
|     {   0,
|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,
|        20,   23,   23
|     } ;
| 
| static yyconst int yy_ec[256] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,
| 
|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| 
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1
|     } ;
| 
| static yyconst int yy_meta[9] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1
|     } ;
| 
| static yyconst short int yy_base[13] =
|     {   0,
|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,
|        10,   10
|     } ;
| 
| static yyconst short int yy_def[13] =
|     {   0,
|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,
|        12,    0
|     } ;
| 
| static yyconst short int yy_nxt[19] =
|     {   0,
|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| static yyconst short int yy_chk[19] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| static yy_state_type yy_state_buf[YY_BUF_SIZE + 2], *yy_state_ptr;
| static char *yy_full_match;
| static int yy_lp;
| #define REJECT \
| { \
| *yy_cp = yy_hold_char; /* undo effects of setting up yytext */ \
| yy_cp = yy_full_match; /* restore poss. backed-over text */ \
| ++yy_lp; \
| goto find_rule; \
| }
| static int yy_more_flag = 0;
| static int yy_more_len = 0;
| #define yymore() (yy_more_flag = 1)
| #define YY_MORE_ADJ yy_more_len
| char *yytext;
| #line 1 "conftest.l"
| #define INITIAL 0
| #line 381 "lex.yy.c"
| 
| /* Macros after this point can all be overridden by user definitions in
|  * section 1.
|  */
| 
| #ifndef YY_SKIP_YYWRAP
| #ifdef __cplusplus
| extern "C" int yywrap YY_PROTO(( void ));
| #else
| extern int yywrap YY_PROTO(( void ));
| #endif
| #endif
| 
| #ifndef YY_NO_UNPUT
| static void yyunput YY_PROTO(( int c, char *buf_ptr ));
| #endif
| 
| #ifndef yytext_ptr
| static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
| #endif
| 
| #ifndef YY_NO_INPUT
| #ifdef __cplusplus
| static int yyinput YY_PROTO(( void ));
| #else
| static int input YY_PROTO(( void ));
| #endif
| #endif
| 
| #if YY_STACK_USED
| static int yy_start_stack_ptr = 0;
| static int yy_start_stack_depth = 0;
| static int *yy_start_stack = 0;
| #ifndef YY_NO_PUSH_STATE
| static void yy_push_state YY_PROTO(( int new_state ));
| #endif
| #ifndef YY_NO_POP_STATE
| static void yy_pop_state YY_PROTO(( void ));
| #endif
| #ifndef YY_NO_TOP_STATE
| static int yy_top_state YY_PROTO(( void ));
| #endif
| 
| #else
| #define YY_NO_PUSH_STATE 1
| #define YY_NO_POP_STATE 1
| #define YY_NO_TOP_STATE 1
| #endif
| 
| #ifdef YY_MALLOC_DECL
| YY_MALLOC_DECL
| #else
| #if __STDC__
| #ifndef __cplusplus
| #include <stdlib.h>
| #endif
| #else
| /* Just try to get by without declaring the routines.  This will fail
|  * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
|  * or sizeof(void*) != sizeof(int).
|  */
| #endif
| #endif
| 
| /* Amount of stuff to slurp up with each read. */
| #ifndef YY_READ_BUF_SIZE
| #define YY_READ_BUF_SIZE 8192
| #endif
| 
| /* Copy whatever the last rule matched to the standard output. */
| 
| #ifndef ECHO
| /* This used to be an fputs(), but since the string might contain NUL's,
|  * we now use fwrite().
|  */
| #define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
| #endif
| 
| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
|  * is returned in "result".
|  */
| #ifndef YY_INPUT
| #define YY_INPUT(buf,result,max_size) \
| 	if ( yy_current_buffer->yy_is_interactive ) \
| 		{ \
| 		int c = '*', n; \
| 		for ( n = 0; n < max_size && \
| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
| 			buf[n] = (char) c; \
| 		if ( c == '\n' ) \
| 			buf[n++] = (char) c; \
| 		if ( c == EOF && ferror( yyin ) ) \
| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 		result = n; \
| 		} \
| 	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
| 		  && ferror( yyin ) ) \
| 		YY_FATAL_ERROR( "input in flex scanner failed" );
| #endif
| 
| /* No semi-colon after return; correct usage is to write "yyterminate();" -
|  * we don't want an extra ';' after the "return" because that will cause
|  * some compilers to complain about unreachable statements.
|  */
| #ifndef yyterminate
| #define yyterminate() return YY_NULL
| #endif
| 
| /* Number of entries by which start-condition stack grows. */
| #ifndef YY_START_STACK_INCR
| #define YY_START_STACK_INCR 25
| #endif
| 
| /* Report a fatal error. */
| #ifndef YY_FATAL_ERROR
| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
| #endif
| 
| /* Default declaration of generated scanner - a define so the user can
|  * easily add parameters.
|  */
| #ifndef YY_DECL
| #define YY_DECL int yylex YY_PROTO(( void ))
| #endif
| 
| /* Code executed at the beginning of each rule, after yytext and yyleng
|  * have been set up.
|  */
| #ifndef YY_USER_ACTION
| #define YY_USER_ACTION
| #endif
| 
| /* Code executed at the end of each rule. */
| #ifndef YY_BREAK
| #define YY_BREAK break;
| #endif
| 
| #define YY_RULE_SETUP \
| 	YY_USER_ACTION
| 
| YY_DECL
| 	{
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp, *yy_bp;
| 	register int yy_act;
| 
| #line 1 "conftest.l"
| 
| #line 530 "lex.yy.c"
| 
| 	if ( yy_init )
| 		{
| 		yy_init = 0;
| 
| #ifdef YY_USER_INIT
| 		YY_USER_INIT;
| #endif
| 
| 		if ( ! yy_start )
| 			yy_start = 1;	/* first start state */
| 
| 		if ( ! yyin )
| 			yyin = stdin;
| 
| 		if ( ! yyout )
| 			yyout = stdout;
| 
| 		if ( ! yy_current_buffer )
| 			yy_current_buffer =
| 				yy_create_buffer( yyin, YY_BUF_SIZE );
| 
| 		yy_load_buffer_state();
| 		}
| 
| 	while ( 1 )		/* loops until end-of-file is reached */
| 		{
| 		yy_more_len = 0;
| 		if ( yy_more_flag )
| 			{
| 			yy_more_len = yyleng;
| 			yy_more_flag = 0;
| 			}
| 		yy_cp = yy_c_buf_p;
| 
| 		/* Support of yytext. */
| 		*yy_cp = yy_hold_char;
| 
| 		/* yy_bp points to the position in yy_ch_buf of the start of
| 		 * the current run.
| 		 */
| 		yy_bp = yy_cp;
| 
| 		yy_current_state = yy_start;
| 		yy_state_ptr = yy_state_buf;
| 		*yy_state_ptr++ = yy_current_state;
| yy_match:
| 		do
| 			{
| 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 				{
| 				yy_current_state = (int) yy_def[yy_current_state];
| 				if ( yy_current_state >= 13 )
| 					yy_c = yy_meta[(unsigned int) yy_c];
| 				}
| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 			*yy_state_ptr++ = yy_current_state;
| 			++yy_cp;
| 			}
| 		while ( yy_base[yy_current_state] != 10 );
| 
| yy_find_action:
| 		yy_current_state = *--yy_state_ptr;
| 		yy_lp = yy_accept[yy_current_state];
| find_rule: /* we branch to this label when backing up */
| 		for ( ; ; ) /* until we find what rule we matched */
| 			{
| 			if ( yy_lp && yy_lp < yy_accept[yy_current_state + 1] )
| 				{
| 				yy_act = yy_acclist[yy_lp];
| 					{
| 					yy_full_match = yy_cp;
| 					break;
| 					}
| 				}
| 			--yy_cp;
| 			yy_current_state = *--yy_state_ptr;
| 			yy_lp = yy_accept[yy_current_state];
| 			}
| 
| 		YY_DO_BEFORE_ACTION;
| 
| 
| do_action:	/* This label is used only to access EOF actions. */
| 
| 
| 		switch ( yy_act )
| 	{ /* beginning of action switch */
| case 1:
| YY_RULE_SETUP
| #line 2 "conftest.l"
| { ECHO; }
| 	YY_BREAK
| case 2:
| YY_RULE_SETUP
| #line 3 "conftest.l"
| { REJECT; }
| 	YY_BREAK
| case 3:
| YY_RULE_SETUP
| #line 4 "conftest.l"
| { yymore (); }
| 	YY_BREAK
| case 4:
| YY_RULE_SETUP
| #line 5 "conftest.l"
| { yyless (1); }
| 	YY_BREAK
| case 5:
| YY_RULE_SETUP
| #line 6 "conftest.l"
| { /* IRIX 6.5 flex 2.5.4 underquotes its yyless argument.  */
|     yyless ((input () != 0)); }
| 	YY_BREAK
| case 6:
| YY_RULE_SETUP
| #line 8 "conftest.l"
| { unput (yytext[0]); }
| 	YY_BREAK
| case 7:
| YY_RULE_SETUP
| #line 9 "conftest.l"
| { BEGIN INITIAL; }
| 	YY_BREAK
| case 8:
| YY_RULE_SETUP
| #line 10 "conftest.l"
| ECHO;
| 	YY_BREAK
| #line 661 "lex.yy.c"
| 			case YY_STATE_EOF(INITIAL):
| 				yyterminate();
| 
| 	case YY_END_OF_BUFFER:
| 		{
| 		/* Amount of text matched not including the EOB char. */
| 		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
| 
| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
| 		*yy_cp = yy_hold_char;
| 
| 		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
| 			{
| 			/* We're scanning a new file or input source.  It's
| 			 * possible that this happened because the user
| 			 * just pointed yyin at a new source and called
| 			 * yylex().  If so, then we have to assure
| 			 * consistency between yy_current_buffer and our
| 			 * globals.  Here is the right place to do so, because
| 			 * this is the first action (other than possibly a
| 			 * back-up) that will match for the new input source.
| 			 */
| 			yy_n_chars = yy_current_buffer->yy_n_chars;
| 			yy_current_buffer->yy_input_file = yyin;
| 			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
| 			}
| 
| 		/* Note that here we test for yy_c_buf_p "<=" to the position
| 		 * of the first EOB in the buffer, since yy_c_buf_p will
| 		 * already have been incremented past the NUL character
| 		 * (since all states make transitions on EOB to the
| 		 * end-of-buffer state).  Contrast this with the test
| 		 * in input().
| 		 */
| 		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
| 			{ /* This was really a NUL. */
| 			yy_state_type yy_next_state;
| 
| 			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
| 
| 			yy_current_state = yy_get_previous_state();
| 
| 			/* Okay, we're now positioned to make the NUL
| 			 * transition.  We couldn't have
| 			 * yy_get_previous_state() go ahead and do it
| 			 * for us because it doesn't know how to deal
| 			 * with the possibility of jamming (and we don't
| 			 * want to build jamming into it because then it
| 			 * will run more slowly).
| 			 */
| 
| 			yy_next_state = yy_try_NUL_trans( yy_current_state );
| 
| 			yy_bp = yytext_ptr + YY_MORE_ADJ;
| 
| 			if ( yy_next_state )
| 				{
| 				/* Consume the NUL. */
| 				yy_cp = ++yy_c_buf_p;
| 				yy_current_state = yy_next_state;
| 				goto yy_match;
| 				}
| 
| 			else
| 				{
| 				yy_cp = yy_c_buf_p;
| 				goto yy_find_action;
| 				}
| 			}
| 
| 		else switch ( yy_get_next_buffer() )
| 			{
| 			case EOB_ACT_END_OF_FILE:
| 				{
| 				yy_did_buffer_switch_on_eof = 0;
| 
| 				if ( yywrap() )
| 					{
| 					/* Note: because we've taken care in
| 					 * yy_get_next_buffer() to have set up
| 					 * yytext, we can now set up
| 					 * yy_c_buf_p so that if some total
| 					 * hoser (like flex itself) wants to
| 					 * call the scanner after we return the
| 					 * YY_NULL, it'll still work - another
| 					 * YY_NULL will get returned.
| 					 */
| 					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
| 
| 					yy_act = YY_STATE_EOF(YY_START);
| 					goto do_action;
| 					}
| 
| 				else
| 					{
| 					if ( ! yy_did_buffer_switch_on_eof )
| 						YY_NEW_FILE;
| 					}
| 				break;
| 				}
| 
| 			case EOB_ACT_CONTINUE_SCAN:
| 				yy_c_buf_p =
| 					yytext_ptr + yy_amount_of_matched_text;
| 
| 				yy_current_state = yy_get_previous_state();
| 
| 				yy_cp = yy_c_buf_p;
| 				yy_bp = yytext_ptr + YY_MORE_ADJ;
| 				goto yy_match;
| 
| 			case EOB_ACT_LAST_MATCH:
| 				yy_c_buf_p =
| 				&yy_current_buffer->yy_ch_buf[yy_n_chars];
| 
| 				yy_current_state = yy_get_previous_state();
| 
| 				yy_cp = yy_c_buf_p;
| 				yy_bp = yytext_ptr + YY_MORE_ADJ;
| 				goto yy_find_action;
| 			}
| 		break;
| 		}
| 
| 	default:
| 		YY_FATAL_ERROR(
| 			"fatal flex scanner internal error--no action found" );
| 	} /* end of action switch */
| 		} /* end of scanning one token */
| 	} /* end of yylex */
| 
| 
| /* yy_get_next_buffer - try to read in a new buffer
|  *
|  * Returns a code representing an action:
|  *	EOB_ACT_LAST_MATCH -
|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
|  *	EOB_ACT_END_OF_FILE - end of file
|  */
| 
| static int yy_get_next_buffer()
| 	{
| 	register char *dest = yy_current_buffer->yy_ch_buf;
| 	register char *source = yytext_ptr;
| 	register int number_to_move, i;
| 	int ret_val;
| 
| 	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
| 		YY_FATAL_ERROR(
| 		"fatal flex scanner internal error--end of buffer missed" );
| 
| 	if ( yy_current_buffer->yy_fill_buffer == 0 )
| 		{ /* Don't try to fill the buffer, so this is an EOF. */
| 		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
| 			{
| 			/* We matched a singled characater, the EOB, so
| 			 * treat this as a final EOF.
| 			 */
| 			return EOB_ACT_END_OF_FILE;
| 			}
| 
| 		else
| 			{
| 			/* We matched some text prior to the EOB, first
| 			 * process it.
| 			 */
| 			return EOB_ACT_LAST_MATCH;
| 			}
| 		}
| 
| 	/* Try to read more data. */
| 
| 	/* First move last chars to start of buffer. */
| 	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
| 
| 	for ( i = 0; i < number_to_move; ++i )
| 		*(dest++) = *(source++);
| 
| 	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
| 		/* don't do the read, it's not guaranteed to return an EOF,
| 		 * just force an EOF
| 		 */
| 		yy_n_chars = 0;
| 
| 	else
| 		{
| 		int num_to_read =
| 			yy_current_buffer->yy_buf_size - number_to_move - 1;
| 
| 		while ( num_to_read <= 0 )
| 			{ /* Not enough room in the buffer - grow it. */
| #ifdef YY_USES_REJECT
| 			YY_FATAL_ERROR(
| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
| #else
| 
| 			/* just a shorter name for the current buffer */
| 			YY_BUFFER_STATE b = yy_current_buffer;
| 
| 			int yy_c_buf_p_offset =
| 				(int) (yy_c_buf_p - b->yy_ch_buf);
| 
| 			if ( b->yy_is_our_buffer )
| 				{
| 				int new_size = b->yy_buf_size * 2;
| 
| 				if ( new_size <= 0 )
| 					b->yy_buf_size += b->yy_buf_size / 8;
| 				else
| 					b->yy_buf_size *= 2;
| 
| 				b->yy_ch_buf = (char *)
| 					/* Include room in for 2 EOB chars. */
| 					yy_flex_realloc( (void *) b->yy_ch_buf,
| 							 b->yy_buf_size + 2 );
| 				}
| 			else
| 				/* Can't grow it, we don't own it. */
| 				b->yy_ch_buf = 0;
| 
| 			if ( ! b->yy_ch_buf )
| 				YY_FATAL_ERROR(
| 				"fatal error - scanner input buffer overflow" );
| 
| 			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
| 
| 			num_to_read = yy_current_buffer->yy_buf_size -
| 						number_to_move - 1;
| #endif
| 			}
| 
| 		if ( num_to_read > YY_READ_BUF_SIZE )
| 			num_to_read = YY_READ_BUF_SIZE;
| 
| 		/* Read in more data. */
| 		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
| 			yy_n_chars, num_to_read );
| 		}
| 
| 	if ( yy_n_chars == 0 )
| 		{
| 		if ( number_to_move == YY_MORE_ADJ )
| 			{
| 			ret_val = EOB_ACT_END_OF_FILE;
| 			yyrestart( yyin );
| 			}
| 
| 		else
| 			{
| 			ret_val = EOB_ACT_LAST_MATCH;
| 			yy_current_buffer->yy_buffer_status =
| 				YY_BUFFER_EOF_PENDING;
| 			}
| 		}
| 
| 	else
| 		ret_val = EOB_ACT_CONTINUE_SCAN;
| 
| 	yy_n_chars += number_to_move;
| 	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
| 	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
| 
| 	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
| 
| 	return ret_val;
| 	}
| 
| 
| /* yy_get_previous_state - get the state just before the EOB char was reached */
| 
| static yy_state_type yy_get_previous_state()
| 	{
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp;
| 
| 	yy_current_state = yy_start;
| 	yy_state_ptr = yy_state_buf;
| 	*yy_state_ptr++ = yy_current_state;
| 
| 	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
| 		{
| 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 			{
| 			yy_current_state = (int) yy_def[yy_current_state];
| 			if ( yy_current_state >= 13 )
| 				yy_c = yy_meta[(unsigned int) yy_c];
| 			}
| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 		*yy_state_ptr++ = yy_current_state;
| 		}
| 
| 	return yy_current_state;
| 	}
| 
| 
| /* yy_try_NUL_trans - try to make a transition on the NUL character
|  *
|  * synopsis
|  *	next_state = yy_try_NUL_trans( current_state );
|  */
| 
| #ifdef YY_USE_PROTOS
| static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
| #else
| static yy_state_type yy_try_NUL_trans( yy_current_state )
| yy_state_type yy_current_state;
| #endif
| 	{
| 	register int yy_is_jam;
| 
| 	register YY_CHAR yy_c = 1;
| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 		{
| 		yy_current_state = (int) yy_def[yy_current_state];
| 		if ( yy_current_state >= 13 )
| 			yy_c = yy_meta[(unsigned int) yy_c];
| 		}
| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 	*yy_state_ptr++ = yy_current_state;
| 	yy_is_jam = (yy_current_state == 12);
| 
| 	return yy_is_jam ? 0 : yy_current_state;
| 	}
| 
| 
| #ifndef YY_NO_UNPUT
| #ifdef YY_USE_PROTOS
| static void yyunput( int c, register char *yy_bp )
| #else
| static void yyunput( c, yy_bp )
| int c;
| register char *yy_bp;
| #endif
| 	{
| 	register char *yy_cp = yy_c_buf_p;
| 
| 	/* undo effects of setting up yytext */
| 	*yy_cp = yy_hold_char;
| 
| 	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
| 		{ /* need to shift things up to make room */
| 		/* +2 for EOB chars. */
| 		register int number_to_move = yy_n_chars + 2;
| 		register char *dest = &yy_current_buffer->yy_ch_buf[
| 					yy_current_buffer->yy_buf_size + 2];
| 		register char *source =
| 				&yy_current_buffer->yy_ch_buf[number_to_move];
| 
| 		while ( source > yy_current_buffer->yy_ch_buf )
| 			*--dest = *--source;
| 
| 		yy_cp += (int) (dest - source);
| 		yy_bp += (int) (dest - source);
| 		yy_n_chars = yy_current_buffer->yy_buf_size;
| 
| 		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
| 		}
| 
| 	*--yy_cp = (char) c;
| 
| 
| 	yytext_ptr = yy_bp;
| 	yy_hold_char = *yy_cp;
| 	yy_c_buf_p = yy_cp;
| 	}
| #endif	/* ifndef YY_NO_UNPUT */
| 
| 
| #ifdef __cplusplus
| static int yyinput()
| #else
| static int input()
| #endif
| 	{
| 	int c;
| 
| 	*yy_c_buf_p = yy_hold_char;
| 
| 	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
| 		{
| 		/* yy_c_buf_p now points to the character we want to return.
| 		 * If this occurs *before* the EOB characters, then it's a
| 		 * valid NUL; if not, then we've hit the end of the buffer.
| 		 */
| 		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
| 			/* This was really a NUL. */
| 			*yy_c_buf_p = '\0';
| 
| 		else
| 			{ /* need more input */
| 			yytext_ptr = yy_c_buf_p;
| 			++yy_c_buf_p;
| 
| 			switch ( yy_get_next_buffer() )
| 				{
| 				case EOB_ACT_END_OF_FILE:
| 					{
| 					if ( yywrap() )
| 						{
| 						yy_c_buf_p =
| 						yytext_ptr + YY_MORE_ADJ;
| 						return EOF;
| 						}
| 
| 					if ( ! yy_did_buffer_switch_on_eof )
| 						YY_NEW_FILE;
| #ifdef __cplusplus
| 					return yyinput();
| #else
| 					return input();
| #endif
| 					}
| 
| 				case EOB_ACT_CONTINUE_SCAN:
| 					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
| 					break;
| 
| 				case EOB_ACT_LAST_MATCH:
| #ifdef __cplusplus
| 					YY_FATAL_ERROR(
| 					"unexpected last match in yyinput()" );
| #else
| 					YY_FATAL_ERROR(
| 					"unexpected last match in input()" );
| #endif
| 				}
| 			}
| 		}
| 
| 	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
| 	*yy_c_buf_p = '\0';	/* preserve yytext */
| 	yy_hold_char = *++yy_c_buf_p;
| 
| 
| 	return c;
| 	}
| 
| 
| #ifdef YY_USE_PROTOS
| void yyrestart( FILE *input_file )
| #else
| void yyrestart( input_file )
| FILE *input_file;
| #endif
| 	{
| 	if ( ! yy_current_buffer )
| 		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
| 
| 	yy_init_buffer( yy_current_buffer, input_file );
| 	yy_load_buffer_state();
| 	}
| 
| 
| #ifdef YY_USE_PROTOS
| void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
| #else
| void yy_switch_to_buffer( new_buffer )
| YY_BUFFER_STATE new_buffer;
| #endif
| 	{
| 	if ( yy_current_buffer == new_buffer )
| 		return;
| 
| 	if ( yy_current_buffer )
| 		{
| 		/* Flush out information for old buffer. */
| 		*yy_c_buf_p = yy_hold_char;
| 		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
| 		yy_current_buffer->yy_n_chars = yy_n_chars;
| 		}
| 
| 	yy_current_buffer = new_buffer;
| 	yy_load_buffer_state();
| 
| 	/* We don't actually know whether we did this switch during
| 	 * EOF (yywrap()) processing, but the only time this flag
| 	 * is looked at is after yywrap() is called, so it's safe
| 	 * to go ahead and always set it.
| 	 */
| 	yy_did_buffer_switch_on_eof = 1;
| 	}
| 
| 
| #ifdef YY_USE_PROTOS
| void yy_load_buffer_state( void )
| #else
| void yy_load_buffer_state()
| #endif
| 	{
| 	yy_n_chars = yy_current_buffer->yy_n_chars;
| 	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
| 	yyin = yy_current_buffer->yy_input_file;
| 	yy_hold_char = *yy_c_buf_p;
| 	}
| 
| 
| #ifdef YY_USE_PROTOS
| YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
| #else
| YY_BUFFER_STATE yy_create_buffer( file, size )
| FILE *file;
| int size;
| #endif
| 	{
| 	YY_BUFFER_STATE b;
| 
| 	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_buf_size = size;
| 
| 	/* yy_ch_buf has to be 2 characters longer than the size given because
| 	 * we need to put in 2 end-of-buffer characters.
| 	 */
| 	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
| 	if ( ! b->yy_ch_buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_is_our_buffer = 1;
| 
| 	yy_init_buffer( b, file );
| 
| 	return b;
| 	}
| 
| 
| #ifdef YY_USE_PROTOS
| void yy_delete_buffer( YY_BUFFER_STATE b )
| #else
| void yy_delete_buffer( b )
| YY_BUFFER_STATE b;
| #endif
| 	{
| 	if ( ! b )
| 		return;
| 
| 	if ( b == yy_current_buffer )
| 		yy_current_buffer = (YY_BUFFER_STATE) 0;
| 
| 	if ( b->yy_is_our_buffer )
| 		yy_flex_free( (void *) b->yy_ch_buf );
| 
| 	yy_flex_free( (void *) b );
| 	}
| 
| 
| #ifndef YY_ALWAYS_INTERACTIVE
| #ifndef YY_NEVER_INTERACTIVE
| extern int isatty YY_PROTO(( int ));
| #endif
| #endif
| 
| #ifdef YY_USE_PROTOS
| void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
| #else
| void yy_init_buffer( b, file )
| YY_BUFFER_STATE b;
| FILE *file;
| #endif
| 
| 
| 	{
| 	yy_flush_buffer( b );
| 
| 	b->yy_input_file = file;
| 	b->yy_fill_buffer = 1;
| 
| #if YY_ALWAYS_INTERACTIVE
| 	b->yy_is_interactive = 1;
| #else
| #if YY_NEVER_INTERACTIVE
| 	b->yy_is_interactive = 0;
| #else
| 	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
| #endif
| #endif
| 	}
| 
| 
| #ifdef YY_USE_PROTOS
| void yy_flush_buffer( YY_BUFFER_STATE b )
| #else
| void yy_flush_buffer( b )
| YY_BUFFER_STATE b;
| #endif
| 
| 	{
| 	b->yy_n_chars = 0;
| 
| 	/* We always need two end-of-buffer characters.  The first causes
| 	 * a transition to the end-of-buffer state.  The second causes
| 	 * a jam in that state.
| 	 */
| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b->yy_buf_pos = &b->yy_ch_buf[0];
| 
| 	b->yy_at_bol = 1;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	if ( b == yy_current_buffer )
| 		yy_load_buffer_state();
| 	}
| 
| 
| #ifndef YY_NO_SCAN_BUFFER
| #ifdef YY_USE_PROTOS
| YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
| #else
| YY_BUFFER_STATE yy_scan_buffer( base, size )
| char *base;
| yy_size_t size;
| #endif
| 	{
| 	YY_BUFFER_STATE b;
| 
| 	if ( size < 2 ||
| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
| 		/* They forgot to leave room for the EOB's. */
| 		return 0;
| 
| 	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
| 
| 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
| 	b->yy_buf_pos = b->yy_ch_buf = base;
| 	b->yy_is_our_buffer = 0;
| 	b->yy_input_file = 0;
| 	b->yy_n_chars = b->yy_buf_size;
| 	b->yy_is_interactive = 0;
| 	b->yy_at_bol = 1;
| 	b->yy_fill_buffer = 0;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	yy_switch_to_buffer( b );
| 
| 	return b;
| 	}
| #endif
| 
| 
| #ifndef YY_NO_SCAN_STRING
| #ifdef YY_USE_PROTOS
| YY_BUFFER_STATE yy_scan_string( yyconst char *str )
| #else
| YY_BUFFER_STATE yy_scan_string( str )
| yyconst char *str;
| #endif
| 	{
| 	int len;
| 	for ( len = 0; str[len]; ++len )
| 		;
| 
| 	return yy_scan_bytes( str, len );
| 	}
| #endif
| 
| 
| #ifndef YY_NO_SCAN_BYTES
| #ifdef YY_USE_PROTOS
| YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
| #else
| YY_BUFFER_STATE yy_scan_bytes( bytes, len )
| yyconst char *bytes;
| int len;
| #endif
| 	{
| 	YY_BUFFER_STATE b;
| 	char *buf;
| 	yy_size_t n;
| 	int i;
| 
| 	/* Get memory for full buffer, including space for trailing EOB's. */
| 	n = len + 2;
| 	buf = (char *) yy_flex_alloc( n );
| 	if ( ! buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
| 
| 	for ( i = 0; i < len; ++i )
| 		buf[i] = bytes[i];
| 
| 	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b = yy_scan_buffer( buf, n );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
| 
| 	/* It's okay to grow etc. this buffer, and we should throw it
| 	 * away when we're done.
| 	 */
| 	b->yy_is_our_buffer = 1;
| 
| 	return b;
| 	}
| #endif
| 
| 
| #ifndef YY_NO_PUSH_STATE
| #ifdef YY_USE_PROTOS
| static void yy_push_state( int new_state )
| #else
| static void yy_push_state( new_state )
| int new_state;
| #endif
| 	{
| 	if ( yy_start_stack_ptr >= yy_start_stack_depth )
| 		{
| 		yy_size_t new_size;
| 
| 		yy_start_stack_depth += YY_START_STACK_INCR;
| 		new_size = yy_start_stack_depth * sizeof( int );
| 
| 		if ( ! yy_start_stack )
| 			yy_start_stack = (int *) yy_flex_alloc( new_size );
| 
| 		else
| 			yy_start_stack = (int *) yy_flex_realloc(
| 					(void *) yy_start_stack, new_size );
| 
| 		if ( ! yy_start_stack )
| 			YY_FATAL_ERROR(
| 			"out of memory expanding start-condition stack" );
| 		}
| 
| 	yy_start_stack[yy_start_stack_ptr++] = YY_START;
| 
| 	BEGIN(new_state);
| 	}
| #endif
| 
| 
| #ifndef YY_NO_POP_STATE
| static void yy_pop_state()
| 	{
| 	if ( --yy_start_stack_ptr < 0 )
| 		YY_FATAL_ERROR( "start-condition stack underflow" );
| 
| 	BEGIN(yy_start_stack[yy_start_stack_ptr]);
| 	}
| #endif
| 
| 
| #ifndef YY_NO_TOP_STATE
| static int yy_top_state()
| 	{
| 	return yy_start_stack[yy_start_stack_ptr - 1];
| 	}
| #endif
| 
| #ifndef YY_EXIT_FAILURE
| #define YY_EXIT_FAILURE 2
| #endif
| 
| #ifdef YY_USE_PROTOS
| static void yy_fatal_error( yyconst char msg[] )
| #else
| static void yy_fatal_error( msg )
| char msg[];
| #endif
| 	{
| 	(void) fprintf( stderr, "%s\n", msg );
| 	exit( YY_EXIT_FAILURE );
| 	}
| 
| 
| 
| /* Redefine yyless() so it works in section 3 code. */
| 
| #undef yyless
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
| 		yytext[yyleng] = yy_hold_char; \
| 		yy_c_buf_p = yytext + n - YY_MORE_ADJ; \
| 		yy_hold_char = *yy_c_buf_p; \
| 		*yy_c_buf_p = '\0'; \
| 		yyleng = n; \
| 		} \
| 	while ( 0 )
| 
| 
| /* Internal utility routines. */
| 
| #ifndef yytext_ptr
| #ifdef YY_USE_PROTOS
| static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
| #else
| static void yy_flex_strncpy( s1, s2, n )
| char *s1;
| yyconst char *s2;
| int n;
| #endif
| 	{
| 	register int i;
| 	for ( i = 0; i < n; ++i )
| 		s1[i] = s2[i];
| 	}
| #endif
| 
| 
| #ifdef YY_USE_PROTOS
| static void *yy_flex_alloc( yy_size_t size )
| #else
| static void *yy_flex_alloc( size )
| yy_size_t size;
| #endif
| 	{
| 	return (void *) malloc( size );
| 	}
| 
| #ifdef YY_USE_PROTOS
| static void *yy_flex_realloc( void *ptr, yy_size_t size )
| #else
| static void *yy_flex_realloc( ptr, size )
| void *ptr;
| yy_size_t size;
| #endif
| 	{
| 	/* The cast to (char *) in the following accommodates both
| 	 * implementations that use char* generic pointers, and those
| 	 * that use void* generic pointers.  It works with the latter
| 	 * because both ANSI C and C++ allow castless assignment from
| 	 * any pointer type to void*, and deal with argument conversions
| 	 * as though doing an assignment.
| 	 */
| 	return (void *) realloc( (char *) ptr, size );
| 	}
| 
| #ifdef YY_USE_PROTOS
| static void yy_flex_free( void *ptr )
| #else
| static void yy_flex_free( ptr )
| void *ptr;
| #endif
| 	{
| 	free( ptr );
| 	}
| 
| #if YY_MAIN
| int main()
| 	{
| 	yylex();
| 	return 0;
| 	}
| #endif
| #line 10 "conftest.l"
| 
| #ifdef YYTEXT_POINTER
| extern char *yytext;
| #endif
| int
| main (void)
| {
|   return ! yylex () + ! yywrap ();
| }
configure:13484: result: none needed
configure:13490: checking whether yytext is a pointer
configure:13508: gcc -o conftest.exe -g -O2   conftest.c   >&5
/usr/lib/gcc/x86_64-pc-cygwin/11/../../../../x86_64-pc-cygwin/bin/ld: /tmp/ccWjCpSE.o: in function `input':
/cygdrive/c/source/HomeworldSDL/tools/kas2c/bison-3.8/lex.yy.c:1060: undefined reference to `yywrap'
/usr/lib/gcc/x86_64-pc-cygwin/11/../../../../x86_64-pc-cygwin/bin/ld: /tmp/ccWjCpSE.o: in function `yylex':
/cygdrive/c/source/HomeworldSDL/tools/kas2c/bison-3.8/lex.yy.c:737: undefined reference to `yywrap'
/usr/lib/gcc/x86_64-pc-cygwin/11/../../../../x86_64-pc-cygwin/bin/ld: /tmp/ccWjCpSE.o: in function `main':
/cygdrive/c/source/HomeworldSDL/tools/kas2c/bison-3.8/conftest.l:17: undefined reference to `yywrap'
collect2: error: ld returned 1 exit status
configure:13508: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "GNU Bison"
| #define PACKAGE_TARNAME "bison"
| #define PACKAGE_VERSION "3.8"
| #define PACKAGE_STRING "GNU Bison 3.8"
| #define PACKAGE_BUGREPORT "bug-bison@gnu.org"
| #define PACKAGE_URL "https://www.gnu.org/software/bison/"
| #define PACKAGE_COPYRIGHT_YEAR 2021
| #define PACKAGE "bison"
| #define VERSION "3.8"
| #define HAVE_STDIO_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_SOCKET_H 1
| #define HAVE_STDIO_EXT_H 1
| #define HAVE_FEATURES_H 1
| #define HAVE_GETOPT_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_CRTDEFS_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_THREADS_H 1
| #define HAVE_MATH_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_SPAWN_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_TIMES_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_TERMIOS_H 1
| #define HAVE_DIRENT_H 1
| #define STDC_HEADERS 1
| #define _ALL_SOURCE 1
| #define _DARWIN_C_SOURCE 1
| #define _GNU_SOURCE 1
| #define _HPUX_ALT_XOPEN_SOCKET_API 1
| #define _NETBSD_SOURCE 1
| #define _OPENBSD_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define __STDC_WANT_IEC_60559_ATTRIBS_EXT__ 1
| #define __STDC_WANT_IEC_60559_BFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_DFP_EXT__ 1
| #define __STDC_WANT_IEC_60559_FUNCS_EXT__ 1
| #define __STDC_WANT_IEC_60559_TYPES_EXT__ 1
| #define __STDC_WANT_LIB_EXT2__ 1
| #define __STDC_WANT_MATH_SPEC_FUNCS__ 1
| #define _TANDEM_SOURCE 1
| #define __EXTENSIONS__ 1
| #define HAVE_TCDRAIN 1
| #define HAVE_CANONICALIZE_FILE_NAME 1
| #define HAVE_FACCESSAT 1
| #define HAVE_REALPATH 1
| #define HAVE_LSTAT 1
| #define HAVE_READLINKAT 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCNTL 1
| #define HAVE_SYMLINK 1
| #define HAVE_FFSL 1
| #define HAVE_VASNPRINTF 1
| #define HAVE_SNPRINTF 1
| #define HAVE_FSYNC 1
| #define HAVE_GETPROGNAME 1
| #define HAVE_GETRUSAGE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_ISWCNTRL 1
| #define HAVE_ISWBLANK 1
| #define HAVE_MBSINIT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_ISASCII 1
| #define HAVE_MPROTECT 1
| #define HAVE_STRERROR_R 1
| #define HAVE___XPG_STRERROR_R 1
| #define HAVE_PIPE 1
| #define HAVE_PIPE2 1
| #define HAVE_READLINK 1
| #define HAVE_SETENV 1
| #define HAVE_LINK 1
| #define HAVE_SIGACTION 1
| #define HAVE_SIGALTSTACK 1
| #define HAVE_SIGINTERRUPT 1
| #define HAVE_STPNCPY 1
| #define HAVE_STRNDUP 1
| #define HAVE_WCWIDTH 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_MEMPCPY 1
| #define HAVE_FSTATAT 1
| #define HAVE_GETDELIM 1
| #define HAVE_GETDTABLESIZE 1
| #define HAVE_OPENAT 1
| #define HAVE_CATGETS 1
| #define HAVE_SETLOCALE 1
| /* end confdefs.h.  */
| 
|   #define YYTEXT_POINTER 1
| /* A lexical scanner generated by flex */
| 
| /* Scanner skeleton version:
|  * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.85 95/04/24 10:48:47 vern Exp $
|  */
| 
| #define FLEX_SCANNER
| #define YY_FLEX_MAJOR_VERSION 2
| #define YY_FLEX_MINOR_VERSION 5
| 
| #include <stdio.h>
| 
| 
| /* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
| #ifdef c_plusplus
| #ifndef __cplusplus
| #define __cplusplus
| #endif
| #endif
| 
| 
| #ifdef __cplusplus
| 
| #include <stdlib.h>
| #include <unistd.h>
| 
| /* Use prototypes in function declarations. */
| #define YY_USE_PROTOS
| 
| /* The "const" storage-class-modifier is valid. */
| #define YY_USE_CONST
| 
| #else	/* ! __cplusplus */
| 
| #if __STDC__
| 
| #define YY_USE_PROTOS
| #define YY_USE_CONST
| 
| #endif	/* __STDC__ */
| #endif	/* ! __cplusplus */
| 
| #ifdef __TURBOC__
|  #pragma warn -rch
|  #pragma warn -use
| #include <io.h>
| #include <stdlib.h>
| #define YY_USE_CONST
| #define YY_USE_PROTOS
| #endif
| 
| #ifdef YY_USE_CONST
| #define yyconst const
| #else
| #define yyconst
| #endif
| 
| 
| #ifdef YY_USE_PROTOS
| #define YY_PROTO(proto) proto
| #else
| #define YY_PROTO(proto) ()
| #endif
| 
| /* Returned upon end-of-file. */
| #define YY_NULL 0
| 
| /* Promotes a possibly negative, possibly signed char to an unsigned
|  * integer for use as an array index.  If the signed char is negative,
|  * we want to instead treat it as an 8-bit unsigned char, hence the
|  * double cast.
|  */
| #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
| 
| /* Enter a start condition.  This macro really ought to take a parameter,
|  * but we do it the disgusting crufty way forced on us by the ()-less
|  * definition of BEGIN.
|  */
| #define BEGIN yy_start = 1 + 2 *
| 
| /* Translate the current start state into a value that can be later handed
|  * to BEGIN to return to the state.  The YYSTATE alias is for lex
|  * compatibility.
|  */
| #define YY_START ((yy_start - 1) / 2)
| #define YYSTATE YY_START
| 
| /* Action number for EOF rule of a given start state. */
| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
| 
| /* Special action meaning "start processing a new file". */
| #define YY_NEW_FILE yyrestart( yyin )
| 
| #define YY_END_OF_BUFFER_CHAR 0
| 
| /* Size of default input buffer. */
| #define YY_BUF_SIZE 16384
| 
| typedef struct yy_buffer_state *YY_BUFFER_STATE;
| 
| extern int yyleng;
| extern FILE *yyin, *yyout;
| 
| #define EOB_ACT_CONTINUE_SCAN 0
| #define EOB_ACT_END_OF_FILE 1
| #define EOB_ACT_LAST_MATCH 2
| 
| /* The funky do-while in the following #define is used to turn the definition
|  * int a single C statement (which needs a semi-colon terminator).  This
|  * avoids problems with code like:
|  *
|  * 	if ( condition_holds )
|  *		yyless( 5 );
|  *	else
|  *		do_something_else();
|  *
|  * Prior to using the do-while the compiler would get upset at the
|  * "else" because it interpreted the "if" statement as being all
|  * done when it reached the ';' after the yyless() call.
|  */
| 
| /* Return all but the first 'n' matched characters back to the input stream. */
| 
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
| 		*yy_cp = yy_hold_char; \
| 		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
| 		} \
| 	while ( 0 )
| 
| #define unput(c) yyunput( c, yytext_ptr )
| 
| /* The following is because we cannot portably get our hands on size_t
|  * (without autoconf's help, which isn't available because we want
|  * flex-generated scanners to compile on their own).
|  */
| typedef unsigned int yy_size_t;
| 
| 
| struct yy_buffer_state
| 	{
| 	FILE *yy_input_file;
| 
| 	char *yy_ch_buf;		/* input buffer */
| 	char *yy_buf_pos;		/* current position in input buffer */
| 
| 	/* Size of input buffer in bytes, not including room for EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_buf_size;
| 
| 	/* Number of characters read into yy_ch_buf, not including EOB
| 	 * characters.
| 	 */
| 	int yy_n_chars;
| 
| 	/* Whether we "own" the buffer - i.e., we know we created it,
| 	 * and can realloc() it to grow it, and should free() it to
| 	 * delete it.
| 	 */
| 	int yy_is_our_buffer;
| 
| 	/* Whether this is an "interactive" input source; if so, and
| 	 * if we're using stdio for input, then we want to use getc()
| 	 * instead of fread(), to make sure we stop fetching input after
| 	 * each newline.
| 	 */
| 	int yy_is_interactive;
| 
| 	/* Whether we're considered to be at the beginning of a line.
| 	 * If so, '^' rules will be active on the next match, otherwise
| 	 * not.
| 	 */
| 	int yy_at_bol;
| 
| 	/* Whether to try to fill the input buffer when we reach the
| 	 * end of it.
| 	 */
| 	int yy_fill_buffer;
| 
| 	int yy_buffer_status;
| #define YY_BUFFER_NEW 0
| #define YY_BUFFER_NORMAL 1
| 	/* When an EOF's been seen but there's still some text to process
| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
| 	 * shouldn't try reading from the input source any more.  We might
| 	 * still have a bunch of tokens to match, though, because of
| 	 * possible backing-up.
| 	 *
| 	 * When we actually see the EOF, we change the status to "new"
| 	 * (via yyrestart()), so that the user can continue scanning by
| 	 * just pointing yyin at a new input file.
| 	 */
| #define YY_BUFFER_EOF_PENDING 2
| 	};
| 
| static YY_BUFFER_STATE yy_current_buffer = 0;
| 
| /* We provide macros for accessing buffer states in case in the
|  * future we want to put the buffer states in a more general
|  * "scanner state".
|  */
| #define YY_CURRENT_BUFFER yy_current_buffer
| 
| 
| /* yy_hold_char holds the character lost when yytext is formed. */
| static char yy_hold_char;
| 
| static int yy_n_chars;		/* number of characters read into yy_ch_buf */
| 
| 
| int yyleng;
| 
| /* Points to current character in buffer. */
| static char *yy_c_buf_p = (char *) 0;
| static int yy_init = 1;		/* whether we need to initialize */
| static int yy_start = 0;	/* start state number */
| 
| /* Flag which is used to allow yywrap()'s to do buffer switches
|  * instead of setting up a fresh yyin.  A bit of a hack ...
|  */
| static int yy_did_buffer_switch_on_eof;
| 
| void yyrestart YY_PROTO(( FILE *input_file ));
| 
| void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
| void yy_load_buffer_state YY_PROTO(( void ));
| YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
| void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
| void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
| void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
| #define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
| 
| YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
| YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *str ));
| YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
| 
| static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
| static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
| static void yy_flex_free YY_PROTO(( void * ));
| 
| #define yy_new_buffer yy_create_buffer
| 
| #define yy_set_interactive(is_interactive) \
| 	{ \
| 	if ( ! yy_current_buffer ) \
| 		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
| 	yy_current_buffer->yy_is_interactive = is_interactive; \
| 	}
| 
| #define yy_set_bol(at_bol) \
| 	{ \
| 	if ( ! yy_current_buffer ) \
| 		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
| 	yy_current_buffer->yy_at_bol = at_bol; \
| 	}
| 
| #define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
| 
| 
| #define YY_USES_REJECT
| typedef unsigned char YY_CHAR;
| FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
| typedef int yy_state_type;
| extern char *yytext;
| #define yytext_ptr yytext
| 
| static yy_state_type yy_get_previous_state YY_PROTO(( void ));
| static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
| static int yy_get_next_buffer YY_PROTO(( void ));
| static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
| 
| /* Done after the current pattern has been matched and before the
|  * corresponding action - sets up yytext.
|  */
| #define YY_DO_BEFORE_ACTION \
| 	yytext_ptr = yy_bp; \
| 	yytext_ptr -= yy_more_len; \
| 	yyleng = (int) (yy_cp - yytext_ptr); \
| 	yy_hold_char = *yy_cp; \
| 	*yy_cp = '\0'; \
| 	yy_c_buf_p = yy_cp;
| 
| #define YY_NUM_RULES 8
| #define YY_END_OF_BUFFER 9
| static yyconst short int yy_acclist[23] =
|     {   0,
|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,
|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,
|         7,    8
|     } ;
| 
| static yyconst short int yy_accept[14] =
|     {   0,
|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,
|        20,   23,   23
|     } ;
| 
| static yyconst int yy_ec[256] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,
| 
|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| 
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1
|     } ;
| 
| static yyconst int yy_meta[9] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1
|     } ;
| 
| static yyconst short int yy_base[13] =
|     {   0,
|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,
|        10,   10
|     } ;
| 
| static yyconst short int yy_def[13] =
|     {   0,
|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,
|        12,    0
|     } ;
| 
| static yyconst short int yy_nxt[19] =
|     {   0,
|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| static yyconst short int yy_chk[19] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| static yy_state_type yy_state_buf[YY_BUF_SIZE + 2], *yy_state_ptr;
| static char *yy_full_match;
| static int yy_lp;
| #define REJECT \
| { \
| *yy_cp = yy_hold_char; /* undo effects of setting up yytext */ \
| yy_cp = yy_full_match; /* restore poss. backed-over text */ \
| ++yy_lp; \
| goto find_rule; \
| }
| static int yy_more_flag = 0;
| static int yy_more_len = 0;
| #define yymore() (yy_more_flag = 1)
| #define YY_MORE_ADJ yy_more_len
| char *yytext;
| #line 1 "conftest.l"
| #define INITIAL 0
| #line 381 "lex.yy.c"
| 
| /* Macros after this point can all be overridden by user definitions in
|  * section 1.
|  */
| 
| #ifndef YY_SKIP_YYWRAP
| #ifdef __cplusplus
| extern "C" int yywrap YY_PROTO(( void ));
| #else
| extern int yywrap YY_PROTO(( void ));
| #endif
| #endif
| 
| #ifndef YY_NO_UNPUT
| static void yyunput YY_PROTO(( int c, char *buf_ptr ));
| #endif
| 
| #ifndef yytext_ptr
| static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
| #endif
| 
| #ifndef YY_NO_INPUT
| #ifdef __cplusplus
| static int yyinput YY_PROTO(( void ));
| #else
| static int input YY_PROTO(( void ));
| #endif
| #endif
| 
| #if YY_STACK_USED
| static int yy_start_stack_ptr = 0;
| static int yy_start_stack_depth = 0;
| static int *yy_start_stack = 0;
| #ifndef YY_NO_PUSH_STATE
| static void yy_push_state YY_PROTO(( int new_state ));
| #endif
| #ifndef YY_NO_POP_STATE
| static void yy_pop_state YY_PROTO(( void ));
| #endif
| #ifndef YY_NO_TOP_STATE
| static int yy_top_state YY_PROTO(( void ));
| #endif
| 
| #else
| #define YY_NO_PUSH_STATE 1
| #define YY_NO_POP_STATE 1
| #define YY_NO_TOP_STATE 1
| #endif
| 
| #ifdef YY_MALLOC_DECL
| YY_MALLOC_DECL
| #else
| #if __STDC__
| #ifndef __cplusplus
| #include <stdlib.h>
| #endif
| #else
| /* Just try to get by without declaring the routines.  This will fail
|  * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
|  * or sizeof(void*) != sizeof(int).
|  */
| #endif
| #endif
| 
| /* Amount of stuff to slurp up with each read. */
| #ifndef YY_READ_BUF_SIZE
| #define YY_READ_BUF_SIZE 8192
| #endif
| 
| /* Copy whatever the last rule matched to the standard output. */
| 
| #ifndef ECHO
| /* This used to be an fputs(), but since the string might contain NUL's,
|  * we now use fwrite().
|  */
| #define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
| #endif
| 
| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
|  * is returned in "result".
|  */
| #ifndef YY_INPUT
| #define YY_INPUT(buf,result,max_size) \
| 	if ( yy_current_buffer->yy_is_interactive ) \
| 		{ \
| 		int c = '*', n; \
| 		for ( n = 0; n < max_size && \
| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
| 			buf[n] = (char) c; \
| 		if ( c == '\n' ) \
| 			buf[n++] = (char) c; \
| 		if ( c == EOF && ferror( yyin ) ) \
| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 		result = n; \
| 		} \
| 	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
| 		  && ferror( yyin ) ) \
| 		YY_FATAL_ERROR( "input in flex scanner failed" );
| #endif
| 
| /* No semi-colon after return; correct usage is to write "yyterminate();" -
|  * we don't want an extra ';' after the "return" because that will cause
|  * some compilers to complain about unreachable statements.
|  */
| #ifndef yyterminate
| #define yyterminate() return YY_NULL
| #endif
| 
| /* Number of entries by which start-condition stack grows. */
| #ifndef YY_START_STACK_INCR
| #define YY_START_STACK_INCR 25
| #endif
| 
| /* Report a fatal error. */
| #ifndef YY_FATAL_ERROR
| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
| #endif
| 
| /* Default declaration of generated scanner - a define so the user can
|  * easily add parameters.
|  */
| #ifndef YY_DECL
| #define YY_DECL int yylex YY_PROTO(( void ))
| #endif
| 
| /* Code executed at the beginning of each rule, after yytext and yyleng
|  * have been set up.
|  */
| #ifndef YY_USER_ACTION
| #define YY_USER_ACTION
| #endif
| 
| /* Code executed at the end of each rule. */
| #ifndef YY_BREAK
| #define YY_BREAK break;
| #endif
| 
| #define YY_RULE_SETUP \
| 	YY_USER_ACTION
| 
| YY_DECL
| 	{
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp, *yy_bp;
| 	register int yy_act;
| 
| #line 1 "conftest.l"
| 
| #line 530 "lex.yy.c"
| 
| 	if ( yy_init )
| 		{
| 		yy_init = 0;
| 
| #ifdef YY_USER_INIT
| 		YY_USER_INIT;
| #endif
| 
| 		if ( ! yy_start )
| 			yy_start = 1;	/* first start state */
| 
| 		if ( ! yyin )
| 			yyin = stdin;
| 
| 		if ( ! yyout )
| 			yyout = stdout;
| 
| 		if ( ! yy_current_buffer )
| 			yy_current_buffer =
| 				yy_create_buffer( yyin, YY_BUF_SIZE );
| 
| 		yy_load_buffer_state();
| 		}
| 
| 	while ( 1 )		/* loops until end-of-file is reached */
| 		{
| 		yy_more_len = 0;
| 		if ( yy_more_flag )
| 			{
| 			yy_more_len = yyleng;
| 			yy_more_flag = 0;
| 			}
| 		yy_cp = yy_c_buf_p;
| 
| 		/* Support of yytext. */
| 		*yy_cp = yy_hold_char;
| 
| 		/* yy_bp points to the position in yy_ch_buf of the start of
| 		 * the current run.
| 		 */
| 		yy_bp = yy_cp;
| 
| 		yy_current_state = yy_start;
| 		yy_state_ptr = yy_state_buf;
| 		*yy_state_ptr++ = yy_current_state;
| yy_match:
| 		do
| 			{
| 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 				{
| 				yy_current_state = (int) yy_def[yy_current_state];
| 				if ( yy_current_state >= 13 )
| 					yy_c = yy_meta[(unsigned int) yy_c];
| 				}
| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 			*yy_state_ptr++ = yy_current_state;
| 			++yy_cp;
| 			}
| 		while ( yy_base[yy_current_state] != 10 );
| 
| yy_find_action:
| 		yy_current_state = *--yy_state_ptr;
| 		yy_lp = yy_accept[yy_current_state];
| find_rule: /* we branch to this label when backing up */
| 		for ( ; ; ) /* until we find what rule we matched */
| 			{
| 			if ( yy_lp && yy_lp < yy_accept[yy_current_state + 1] )
| 				{
| 				yy_act = yy_acclist[yy_lp];
| 					{
| 					yy_full_match = yy_cp;
| 					break;
| 					}
| 				}
| 			--yy_cp;
| 			yy_current_state = *--yy_state_ptr;
| 			yy_lp = yy_accept[yy_current_state];
| 			}
| 
| 		YY_DO_BEFORE_ACTION;
| 
| 
| do_action:	/* This label is used only to access EOF actions. */
| 
| 
| 		switch ( yy_act )
| 	{ /* beginning of action switch */
| case 1:
| YY_RULE_SETUP
| #line 2 "conftest.l"
| { ECHO; }
| 	YY_BREAK
| case 2:
| YY_RULE_SETUP
| #line 3 "conftest.l"
| { REJECT; }
| 	YY_BREAK
| case 3:
| YY_RULE_SETUP
| #line 4 "conftest.l"
| { yymore (); }
| 	YY_BREAK
| case 4:
| YY_RULE_SETUP
| #line 5 "conftest.l"
| { yyless (1); }
| 	YY_BREAK
| case 5:
| YY_RULE_SETUP
| #line 6 "conftest.l"
| { /* IRIX 6.5 flex 2.5.4 underquotes its yyless argument.  */
|     yyless ((input () != 0)); }
| 	YY_BREAK
| case 6:
| YY_RULE_SETUP
| #line 8 "conftest.l"
| { unput (yytext[0]); }
| 	YY_BREAK
| case 7:
| YY_RULE_SETUP
| #line 9 "conftest.l"
| { BEGIN INITIAL; }
| 	YY_BREAK
| case 8:
| YY_RULE_SETUP
| #line 10 "conftest.l"
| ECHO;
| 	YY_BREAK
| #line 661 "lex.yy.c"
| 			case YY_STATE_EOF(INITIAL):
| 				yyterminate();
| 
| 	case YY_END_OF_BUFFER:
| 		{
| 		/* Amount of text matched not including the EOB char. */
| 		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
| 
| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
| 		*yy_cp = yy_hold_char;
| 
| 		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
| 			{
| 			/* We're scanning a new file or input source.  It's
| 			 * possible that this happened because the user
| 			 * just pointed yyin at a new source and called
| 			 * yylex().  If so, then we have to assure
| 			 * consistency between yy_current_buffer and our
| 			 * globals.  Here is the right place to do so, because
| 			 * this is the first action (other than possibly a
| 			 * back-up) that will match for the new input source.
| 			 */
| 			yy_n_chars = yy_current_buffer->yy_n_chars;
| 			yy_current_buffer->yy_input_file = yyin;
| 			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
| 			}
| 
| 		/* Note that here we test for yy_c_buf_p "<=" to the position
| 		 * of the first EOB in the buffer, since yy_c_buf_p will
| 		 * already have been incremented past the NUL character
| 		 * (since all states make transitions on EOB to the
| 		 * end-of-buffer state).  Contrast this with the test
| 		 * in input().
| 		 */
| 		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
| 			{ /* This was really a NUL. */
| 			yy_state_type yy_next_state;
| 
| 			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
| 
| 			yy_current_state = yy_get_previous_state();
| 
| 			/* Okay, we're now positioned to make the NUL
| 			 * transition.  We couldn't have
| 			 * yy_get_previous_state() go ahead and do it
| 			 * for us because it doesn't know how to deal
| 			 * with the possibility of jamming (and we don't
| 			 * want to build jamming into it because then it
| 			 * will run more slowly).
| 			 */
| 
| 			yy_next_state = yy_try_NUL_trans( yy_current_state );
| 
| 			yy_bp = yytext_ptr + YY_MORE_ADJ;
| 
| 			if ( yy_next_state )
| 				{
| 				/* Consume the NUL. */
| 				yy_cp = ++yy_c_buf_p;
| 				yy_current_state = yy_next_state;
| 				goto yy_match;
| 				}
| 
| 			else
| 				{
| 				yy_cp = yy_c_buf_p;
| 				goto yy_find_action;
| 				}
| 			}
| 
| 		else switch ( yy_get_next_buffer() )
| 			{
| 			case EOB_ACT_END_OF_FILE:
| 				{
| 				yy_did_buffer_switch_on_eof = 0;
| 
| 				if ( yywrap() )
| 					{
| 					/* Note: because we've taken care in
| 					 * yy_get_next_buffer() to have set up
| 					 * yytext, we can now set up
| 					 * yy_c_buf_p so that if some total
| 					 * hoser (like flex itself) wants to
| 					 * call the scanner after we return the
| 					 * YY_NULL, it'll still work - another
| 					 * YY_NULL will get returned.
| 					 */
| 					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
| 
| 					yy_act = YY_STATE_EOF(YY_START);
| 					goto do_action;
| 					}
| 
| 				else
| 					{
| 					if ( ! yy_did_buffer_switch_on_eof )
| 						YY_NEW_FILE;
| 					}
| 				break;
| 				}
| 
| 			case EOB_ACT_CONTINUE_SCAN:
| 				yy_c_buf_p =
| 					yytext_ptr + yy_amount_of_matched_text;
| 
| 				yy_current_state = yy_get_previous_state();
| 
| 				yy_cp = yy_c_buf_p;
| 				yy_bp = yytext_ptr + YY_MORE_ADJ;
| 				goto yy_match;
| 
| 			case EOB_ACT_LAST_MATCH:
| 				yy_c_buf_p =
| 				&yy_current_buffer->yy_ch_buf[yy_n_chars];
| 
| 				yy_current_state = yy_get_previous_state();
| 
| 				yy_cp = yy_c_buf_p;
| 				yy_bp = yytext_ptr + YY_MORE_ADJ;
| 				goto yy_find_action;
| 			}
| 		break;
| 		}
| 
| 	default:
| 		YY_FATAL_ERROR(
| 			"fatal flex scanner internal error--no action found" );
| 	} /* end of action switch */
| 		} /* end of scanning one token */
| 	} /* end of yylex */
| 
| 
| /* yy_get_next_buffer - try to read in a new buffer
|  *
|  * Returns a code representing an action:
|  *	EOB_ACT_LAST_MATCH -
|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
|  *	EOB_ACT_END_OF_FILE - end of file
|  */
| 
| static int yy_get_next_buffer()
| 	{
| 	register char *dest = yy_current_buffer->yy_ch_buf;
| 	register char *source = yytext_ptr;
| 	register int number_to_move, i;
| 	int ret_val;
| 
| 	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
| 		YY_FATAL_ERROR(
| 		"fatal flex scanner internal error--end of buffer missed" );
| 
| 	if ( yy_current_buffer->yy_fill_buffer == 0 )
| 		{ /* Don't try to fill the buffer, so this is an EOF. */
| 		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
| 			{
| 			/* We matched a singled characater, the EOB, so
| 			 * treat this as a final EOF.
| 			 */
| 			return EOB_ACT_END_OF_FILE;
| 			}
| 
| 		else
| 			{
| 			/* We matched some text prior to the EOB, first
| 			 * process it.
| 			 */
| 			return EOB_ACT_LAST_MATCH;
| 			}
| 		}
| 
| 	/* Try to read more data. */
| 
| 	/* First move last chars to start of buffer. */
| 	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
| 
| 	for ( i = 0; i < number_to_move; ++i )
| 		*(dest++) = *(source++);
| 
| 	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
| 		/* don't do the read, it's not guaranteed to return an EOF,
| 		 * just force an EOF
| 		 */
| 		yy_n_chars = 0;
| 
| 	else
| 		{
| 		int num_to_read =
| 			yy_current_buffer->yy_buf_size - number_to_move - 1;
| 
| 		while ( num_to_read <= 0 )
| 			{ /* Not enough room in the buffer - grow it. */
| #ifdef YY_USES_REJECT
| 			YY_FATAL_ERROR(
| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
| #else
| 
| 			/* just a shorter name for the current buffer */
| 			YY_BUFFER_STATE b = yy_current_buffer;
| 
| 			int yy_c_buf_p_offset =
| 				(int) (yy_c_buf_p - b->yy_ch_buf);
| 
| 			if ( b->yy_is_our_buffer )
| 				{
| 				int new_size = b->yy_buf_size * 2;
| 
| 				if ( new_size <= 0 )
| 					b->yy_buf_size += b->yy_buf_size / 8;
| 				else
| 					b->yy_buf_size *= 2;
| 
| 				b->yy_ch_buf = (char *)
| 					/* Include room in for 2 EOB chars. */
| 					yy_flex_realloc( (void *) b->yy_ch_buf,
| 							 b->yy_buf_size + 2 );
| 				}
| 			else
| 				/* Can't grow it, we don't own it. */
| 				b->yy_ch_buf = 0;
| 
| 			if ( ! b->yy_ch_buf )
| 				YY_FATAL_ERROR(
| 				"fatal error - scanner input buffer overflow" );
| 
| 			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
| 
| 			num_to_read = yy_current_buffer->yy_buf_size -
| 						number_to_move - 1;
| #endif
| 			}
| 
| 		if ( num_to_read > YY_READ_BUF_SIZE )
| 			num_to_read = YY_READ_BUF_SIZE;
| 
| 		/* Read in more data. */
| 		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
| 			yy_n_chars, num_to_read );
| 		}
| 
| 	if ( yy_n_chars == 0 )
| 		{
| 		if ( number_to_move == YY_MORE_ADJ )
| 			{
| 			ret_val = EOB_ACT_END_OF_FILE;
| 			yyrestart( yyin );
| 			}
| 
| 		else
| 			{
| 			ret_val = EOB_ACT_LAST_MATCH;
| 			yy_current_buffer->yy_buffer_status =
| 				YY_BUFFER_EOF_PENDING;
| 			}
| 		}
| 
| 	else
| 		ret_val = EOB_ACT_CONTINUE_SCAN;
| 
| 	yy_n_chars += number_to_move;
| 	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
| 	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
| 
| 	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
| 
| 	return ret_val;
| 	}
| 
| 
| /* yy_get_previous_state - get the state just before the EOB char was reached */
| 
| static yy_state_type yy_get_previous_state()
| 	{
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp;
| 
| 	yy_current_state = yy_start;
| 	yy_state_ptr = yy_state_buf;
| 	*yy_state_ptr++ = yy_current_state;
| 
| 	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
| 		{
| 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 			{
| 			yy_current_state = (int) yy_def[yy_current_state];
| 			if ( yy_current_state >= 13 )
| 				yy_c = yy_meta[(unsigned int) yy_c];
| 			}
| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 		*yy_state_ptr++ = yy_current_state;
| 		}
| 
| 	return yy_current_state;
| 	}
| 
| 
| /* yy_try_NUL_trans - try to make a transition on the NUL character
|  *
|  * synopsis
|  *	next_state = yy_try_NUL_trans( current_state );
|  */
| 
| #ifdef YY_USE_PROTOS
| static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
| #else
| static yy_state_type yy_try_NUL_trans( yy_current_state )
| yy_state_type yy_current_state;
| #endif
| 	{
| 	register int yy_is_jam;
| 
| 	register YY_CHAR yy_c = 1;
| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 		{
| 		yy_current_state = (int) yy_def[yy_current_state];
| 		if ( yy_current_state >= 13 )
| 			yy_c = yy_meta[(unsigned int) yy_c];
| 		}
| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 	*yy_state_ptr++ = yy_current_state;
| 	yy_is_jam = (yy_current_state == 12);
| 
| 	return yy_is_jam ? 0 : yy_current_state;
| 	}
| 
| 
| #ifndef YY_NO_UNPUT
| #ifdef YY_USE_PROTOS
| static void yyunput( int c, register char *yy_bp )
| #else
| static void yyunput( c, yy_bp )
| int c;
| register char *yy_bp;
| #endif
| 	{
| 	register char *yy_cp = yy_c_buf_p;
| 
| 	/* undo effects of setting up yytext */
| 	*yy_cp = yy_hold_char;
| 
| 	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
| 		{ /* need to shift things up to make room */
| 		/* +2 for EOB chars. */
| 		register int number_to_move = yy_n_chars + 2;
| 		register char *dest = &yy_current_buffer->yy_ch_buf[
| 					yy_current_buffer->yy_buf_size + 2];
| 		register char *source =
| 				&yy_current_buffer->yy_ch_buf[number_to_move];
| 
| 		while ( source > yy_current_buffer->yy_ch_buf )
| 			*--dest = *--source;
| 
| 		yy_cp += (int) (dest - source);
| 		yy_bp += (int) (dest - source);
| 		yy_n_chars = yy_current_buffer->yy_buf_size;
| 
| 		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
| 		}
| 
| 	*--yy_cp = (char) c;
| 
| 
| 	yytext_ptr = yy_bp;
| 	yy_hold_char = *yy_cp;
| 	yy_c_buf_p = yy_cp;
| 	}
| #endif	/* ifndef YY_NO_UNPUT */
| 
| 
| #ifdef __cplusplus
| static int yyinput()
| #else
| static int input()
| #endif
| 	{
| 	int c;
| 
| 	*yy_c_buf_p = yy_hold_char;
| 
| 	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
| 		{
| 		/* yy_c_buf_p now points to the character we want to return.
| 		 * If this occurs *before* the EOB characters, then it's a
| 		 * valid NUL; if not, then we've hit the end of the buffer.
| 		 */
| 		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
| 			/* This was really a NUL. */
| 			*yy_c_buf_p = '\0';
| 
| 		else
| 			{ /* need more input */
| 			yytext_ptr = yy_c_buf_p;
| 			++yy_c_buf_p;
| 
| 			switch ( yy_get_next_buffer() )
| 				{
| 				case EOB_ACT_END_OF_FILE:
| 					{
| 					if ( yywrap() )
| 						{
| 						yy_c_buf_p =
| 						yytext_ptr + YY_MORE_ADJ;
| 						return EOF;
| 						}
| 
| 					if ( ! yy_did_buffer_switch_on_eof )
| 						YY_NEW_FILE;
| #ifdef __cplusplus
| 					return yyinput();
| #else
| 					return input();
| #endif
| 					}
| 
| 				case EOB_ACT_CONTINUE_SCAN:
| 					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
| 					break;
| 
| 				case EOB_ACT_LAST_MATCH:
| #ifdef __cplusplus
| 					YY_FATAL_ERROR(
| 					"unexpected last match in yyinput()" );
| #else
| 					YY_FATAL_ERROR(
| 					"unexpected last match in input()" );
| #endif
| 				}
| 			}
| 		}
| 
| 	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
| 	*yy_c_buf_p = '\0';	/* preserve yytext */
| 	yy_hold_char = *++yy_c_buf_p;
| 
| 
| 	return c;
| 	}
| 
| 
| #ifdef YY_USE_PROTOS
| void yyrestart( FILE *input_file )
| #else
| void yyrestart( input_file )
| FILE *input_file;
| #endif
| 	{
| 	if ( ! yy_current_buffer )
| 		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
| 
| 	yy_init_buffer( yy_current_buffer, input_file );
| 	yy_load_buffer_state();
| 	}
| 
| 
| #ifdef YY_USE_PROTOS
| void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
| #else
| void yy_switch_to_buffer( new_buffer )
| YY_BUFFER_STATE new_buffer;
| #endif
| 	{
| 	if ( yy_current_buffer == new_buffer )
| 		return;
| 
| 	if ( yy_current_buffer )
| 		{
| 		/* Flush out information for old buffer. */
| 		*yy_c_buf_p = yy_hold_char;
| 		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
| 		yy_current_buffer->yy_n_chars = yy_n_chars;
| 		}
| 
| 	yy_current_buffer = new_buffer;
| 	yy_load_buffer_state();
| 
| 	/* We don't actually know whether we did this switch during
| 	 * EOF (yywrap()) processing, but the only time this flag
| 	 * is looked at is after yywrap() is called, so it's safe
| 	 * to go ahead and always set it.
| 	 */
| 	yy_did_buffer_switch_on_eof = 1;
| 	}
| 
| 
| #ifdef YY_USE_PROTOS
| void yy_load_buffer_state( void )
| #else
| void yy_load_buffer_state()
| #endif
| 	{
| 	yy_n_chars = yy_current_buffer->yy_n_chars;
| 	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
| 	yyin = yy_current_buffer->yy_input_file;
| 	yy_hold_char = *yy_c_buf_p;
| 	}
| 
| 
| #ifdef YY_USE_PROTOS
| YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
| #else
| YY_BUFFER_STATE yy_create_buffer( file, size )
| FILE *file;
| int size;
| #endif
| 	{
| 	YY_BUFFER_STATE b;
| 
| 	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_buf_size = size;
| 
| 	/* yy_ch_buf has to be 2 characters longer than the size given because
| 	 * we need to put in 2 end-of-buffer characters.
| 	 */
| 	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
| 	if ( ! b->yy_ch_buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_is_our_buffer = 1;
| 
| 	yy_init_buffer( b, file );
| 
| 	return b;
| 	}
| 
| 
| #ifdef YY_USE_PROTOS
| void yy_delete_buffer( YY_BUFFER_STATE b )
| #else
| void yy_delete_buffer( b )
| YY_BUFFER_STATE b;
| #endif
| 	{
| 	if ( ! b )
| 		return;
| 
| 	if ( b == yy_current_buffer )
| 		yy_current_buffer = (YY_BUFFER_STATE) 0;
| 
| 	if ( b->yy_is_our_buffer )
| 		yy_flex_free( (void *) b->yy_ch_buf );
| 
| 	yy_flex_free( (void *) b );
| 	}
| 
| 
| #ifndef YY_ALWAYS_INTERACTIVE
| #ifndef YY_NEVER_INTERACTIVE
| extern int isatty YY_PROTO(( int ));
| #endif
| #endif
| 
| #ifdef YY_USE_PROTOS
| void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
| #else
| void yy_init_buffer( b, file )
| YY_BUFFER_STATE b;
| FILE *file;
| #endif
| 
| 
| 	{
| 	yy_flush_buffer( b );
| 
| 	b->yy_input_file = file;
| 	b->yy_fill_buffer = 1;
| 
| #if YY_ALWAYS_INTERACTIVE
| 	b->yy_is_interactive = 1;
| #else
| #if YY_NEVER_INTERACTIVE
| 	b->yy_is_interactive = 0;
| #else
| 	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
| #endif
| #endif
| 	}
| 
| 
| #ifdef YY_USE_PROTOS
| void yy_flush_buffer( YY_BUFFER_STATE b )
| #else
| void yy_flush_buffer( b )
| YY_BUFFER_STATE b;
| #endif
| 
| 	{
| 	b->yy_n_chars = 0;
| 
| 	/* We always need two end-of-buffer characters.  The first causes
| 	 * a transition to the end-of-buffer state.  The second causes
| 	 * a jam in that state.
| 	 */
| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b->yy_buf_pos = &b->yy_ch_buf[0];
| 
| 	b->yy_at_bol = 1;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	if ( b == yy_current_buffer )
| 		yy_load_buffer_state();
| 	}
| 
| 
| #ifndef YY_NO_SCAN_BUFFER
| #ifdef YY_USE_PROTOS
| YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
| #else
| YY_BUFFER_STATE yy_scan_buffer( base, size )
| char *base;
| yy_size_t size;
| #endif
| 	{
| 	YY_BUFFER_STATE b;
| 
| 	if ( size < 2 ||
| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
| 		/* They forgot to leave room for the EOB's. */
| 		return 0;
| 
| 	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
| 
| 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
| 	b->yy_buf_pos = b->yy_ch_buf = base;
| 	b->yy_is_our_buffer = 0;
| 	b->yy_input_file = 0;
| 	b->yy_n_chars = b->yy_buf_size;
| 	b->yy_is_interactive = 0;
| 	b->yy_at_bol = 1;
| 	b->yy_fill_buffer = 0;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	yy_switch_to_buffer( b );
| 
| 	return b;
| 	}
| #endif
| 
| 
| #ifndef YY_NO_SCAN_STRING
| #ifdef YY_USE_PROTOS
| YY_BUFFER_STATE yy_scan_string( yyconst char *str )
| #else
| YY_BUFFER_STATE yy_scan_string( str )
| yyconst char *str;
| #endif
| 	{
| 	int len;
| 	for ( len = 0; str[len]; ++len )
| 		;
| 
| 	return yy_scan_bytes( str, len );
| 	}
| #endif
| 
| 
| #ifndef YY_NO_SCAN_BYTES
| #ifdef YY_USE_PROTOS
| YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
| #else
| YY_BUFFER_STATE yy_scan_bytes( bytes, len )
| yyconst char *bytes;
| int len;
| #endif
| 	{
| 	YY_BUFFER_STATE b;
| 	char *buf;
| 	yy_size_t n;
| 	int i;
| 
| 	/* Get memory for full buffer, including space for trailing EOB's. */
| 	n = len + 2;
| 	buf = (char *) yy_flex_alloc( n );
| 	if ( ! buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
| 
| 	for ( i = 0; i < len; ++i )
| 		buf[i] = bytes[i];
| 
| 	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b = yy_scan_buffer( buf, n );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
| 
| 	/* It's okay to grow etc. this buffer, and we should throw it
| 	 * away when we're done.
| 	 */
| 	b->yy_is_our_buffer = 1;
| 
| 	return b;
| 	}
| #endif
| 
| 
| #ifndef YY_NO_PUSH_STATE
| #ifdef YY_USE_PROTOS
| static void yy_push_state( int new_state )
| #else
| static void yy_push_state( new_state )
| int new_state;
| #endif
| 	{
| 	if ( yy_start_stack_ptr >= yy_start_stack_depth )
| 		{
| 		yy_size_t new_size;
| 
| 		yy_start_stack_depth += YY_START_STACK_INCR;
| 		new_size = yy_start_stack_depth * sizeof( int );
| 
| 		if ( ! yy_start_stack )
| 			yy_start_stack = (int *) yy_flex_alloc( new_size );
| 
| 		else
| 			yy_start_stack = (int *) yy_flex_realloc(
| 					(void *) yy_start_stack, new_size );
| 
| 		if ( ! yy_start_stack )
| 			YY_FATAL_ERROR(
| 			"out of memory expanding start-condition stack" );
| 		}
| 
| 	yy_start_stack[yy_start_stack_ptr++] = YY_START;
| 
| 	BEGIN(new_state);
| 	}
| #endif
| 
| 
| #ifndef YY_NO_POP_STATE
| static void yy_pop_state()
| 	{
| 	if ( --yy_start_stack_ptr < 0 )
| 		YY_FATAL_ERROR( "start-condition stack underflow" );
| 
| 	BEGIN(yy_start_stack[yy_start_stack_ptr]);
| 	}
| #endif
| 
| 
| #ifndef YY_NO_TOP_STATE
| static int yy_top_state()
| 	{
| 	return yy_start_stack[yy_start_stack_ptr - 1];
| 	}
| #endif
| 
| #ifndef YY_EXIT_FAILURE
| #define YY_EXIT_FAILURE 2
| #endif
| 
| #ifdef YY_USE_PROTOS
| static void yy_fatal_error( yyconst char msg[] )
| #else
| static void yy_fatal_error( msg )
| char msg[];
| #endif
| 	{
| 	(void) fprintf( stderr, "%s\n", msg );
| 	exit( YY_EXIT_FAILURE );
| 	}
| 
| 
| 
| /* Redefine yyless() so it works in section 3 code. */
| 
| #undef yyless
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
| 		yytext[yyleng] = yy_hold_char; \
| 		yy_c_buf_p = yytext + n - YY_MORE_ADJ; \
| 		yy_hold_char = *yy_c_buf_p; \
| 		*yy_c_buf_p = '\0'; \
| 		yyleng = n; \
| 		} \
| 	while ( 0 )
| 
| 
| /* Internal utility routines. */
| 
| #ifndef yytext_ptr
| #ifdef YY_USE_PROTOS
| static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
| #else
| static void yy_flex_strncpy( s1, s2, n )
| char *s1;
| yyconst char *s2;
| int n;
| #endif
| 	{
| 	register int i;
| 	for ( i = 0; i < n; ++i )
| 		s1[i] = s2[i];
| 	}
| #endif
| 
| 
| #ifdef YY_USE_PROTOS
| static void *yy_flex_alloc( yy_size_t size )
| #else
| static void *yy_flex_alloc( size )
| yy_size_t size;
| #endif
| 	{
| 	return (void *) malloc( size );
| 	}
| 
| #ifdef YY_USE_PROTOS
| static void *yy_flex_realloc( void *ptr, yy_size_t size )
| #else
| static void *yy_flex_realloc( ptr, size )
| void *ptr;
| yy_size_t size;
| #endif
| 	{
| 	/* The cast to (char *) in the following accommodates both
| 	 * implementations that use char* generic pointers, and those
| 	 * that use void* generic pointers.  It works with the latter
| 	 * because both ANSI C and C++ allow castless assignment from
| 	 * any pointer type to void*, and deal with argument conversions
| 	 * as though doing an assignment.
| 	 */
| 	return (void *) realloc( (char *) ptr, size );
| 	}
| 
| #ifdef YY_USE_PROTOS
| static void yy_flex_free( void *ptr )
| #else
| static void yy_flex_free( ptr )
| void *ptr;
| #endif
| 	{
| 	free( ptr );
| 	}
| 
| #if YY_MAIN
| int main()
| 	{
| 	yylex();
| 	return 0;
| 	}
| #endif
| #line 10 "conftest.l"
| 
| #ifdef YYTEXT_POINTER
| extern char *yytext;
| #endif
| int
| main (void)
| {
|   return ! yylex () + ! yywrap ();
| }
configure:13517: result: no
configure:13554: checking for bison
configure:13575: found /cygdrive/c/source/homeworld/tools/bin/bison
configure:13586: result: bison -y
configure:13646: checking for ranlib
configure:13678: result: ranlib
configure:13701: checking for GNU M4 that supports accurate traces
configure:13746: error: no acceptable m4 could be found in $PATH.
GNU M4 1.4.6 or later is required; 1.4.16 or newer is recommended.
GNU M4 1.4.15 uses a buggy replacement strstr on some systems.
Glibc 2.9 - 2.12 and GNU M4 1.4.11 - 1.4.15 have another strstr bug.

## ---------------- ##
## Cache variables. ##
## ---------------- ##

ac_cv_build=x86_64-pc-cygwin
ac_cv_c_compiler_gnu=yes
ac_cv_c_inline=inline
ac_cv_cxx_compiler_gnu=yes
ac_cv_env_CCC_set=
ac_cv_env_CCC_value=
ac_cv_env_CC_set=
ac_cv_env_CC_value=
ac_cv_env_CFLAGS_set=
ac_cv_env_CFLAGS_value=
ac_cv_env_CPPFLAGS_set=
ac_cv_env_CPPFLAGS_value=
ac_cv_env_CPP_set=
ac_cv_env_CPP_value=
ac_cv_env_CXXFLAGS_set=
ac_cv_env_CXXFLAGS_value=
ac_cv_env_CXX_set=
ac_cv_env_CXX_value=
ac_cv_env_LDFLAGS_set=
ac_cv_env_LDFLAGS_value=
ac_cv_env_LIBS_set=
ac_cv_env_LIBS_value=
ac_cv_env_M4_set=
ac_cv_env_M4_value=
ac_cv_env_YACC_set=
ac_cv_env_YACC_value=
ac_cv_env_YFLAGS_set=
ac_cv_env_YFLAGS_value=
ac_cv_env_build_alias_set=
ac_cv_env_build_alias_value=
ac_cv_env_host_alias_set=
ac_cv_env_host_alias_value=
ac_cv_env_target_alias_set=
ac_cv_env_target_alias_value=
ac_cv_exeext=.exe
ac_cv_func___fseterr=no
ac_cv_func___xpg_strerror_r=yes
ac_cv_func__set_invalid_parameter_handler=no
ac_cv_func_canonicalize_file_name=yes
ac_cv_func_catgets=yes
ac_cv_func_faccessat=yes
ac_cv_func_fchdir=yes
ac_cv_func_fcntl=yes
ac_cv_func_fdopendir=yes
ac_cv_func_ffsl=yes
ac_cv_func_fstatat=yes
ac_cv_func_fsync=yes
ac_cv_func_getdelim=yes
ac_cv_func_getdtablesize=yes
ac_cv_func_getexecname=no
ac_cv_func_getprogname=yes
ac_cv_func_getrusage=yes
ac_cv_func_gettimeofday=yes
ac_cv_func_isascii=yes
ac_cv_func_iswblank=yes
ac_cv_func_iswcntrl=yes
ac_cv_func_link=yes
ac_cv_func_lstat=yes
ac_cv_func_mbrtowc=yes
ac_cv_func_mbsinit=yes
ac_cv_func_mempcpy=yes
ac_cv_func_microuptime=no
ac_cv_func_mprotect=yes
ac_cv_func_nanouptime=no
ac_cv_func_obstack_printf=no
ac_cv_func_openat=yes
ac_cv_func_pipe2=yes
ac_cv_func_pipe=yes
ac_cv_func_posix_spawn_file_actions_addchdir=no
ac_cv_func_posix_spawn_file_actions_addchdir_np=no
ac_cv_func_readlink=yes
ac_cv_func_readlinkat=yes
ac_cv_func_realpath=yes
ac_cv_func_setenv=yes
ac_cv_func_setlocale=yes
ac_cv_func_sigaction=yes
ac_cv_func_sigaltstack=yes
ac_cv_func_siginterrupt=yes
ac_cv_func_snprintf=yes
ac_cv_func_stpncpy=yes
ac_cv_func_strerror_r=yes
ac_cv_func_strndup=yes
ac_cv_func_symlink=yes
ac_cv_func_tcdrain=yes
ac_cv_func_vasnprintf=yes
ac_cv_func_wcwidth=yes
ac_cv_header_crtdefs_h=yes
ac_cv_header_dirent_h=yes
ac_cv_header_features_h=yes
ac_cv_header_getopt_h=yes
ac_cv_header_iconv_h=no
ac_cv_header_inttypes_h=yes
ac_cv_header_limits_h=yes
ac_cv_header_locale_h=yes
ac_cv_header_math_h=yes
ac_cv_header_minix_config_h=no
ac_cv_header_spawn_h=yes
ac_cv_header_stdint_h=yes
ac_cv_header_stdio_ext_h=yes
ac_cv_header_stdio_h=yes
ac_cv_header_stdlib_h=yes
ac_cv_header_string_h=yes
ac_cv_header_strings_h=yes
ac_cv_header_sys_cdefs_h=yes
ac_cv_header_sys_ioctl_h=yes
ac_cv_header_sys_mman_h=yes
ac_cv_header_sys_param_h=yes
ac_cv_header_sys_resource_h=yes
ac_cv_header_sys_socket_h=yes
ac_cv_header_sys_stat_h=yes
ac_cv_header_sys_time_h=yes
ac_cv_header_sys_times_h=yes
ac_cv_header_sys_types_h=yes
ac_cv_header_sys_wait_h=yes
ac_cv_header_termios_h=yes
ac_cv_header_threads_h=yes
ac_cv_header_unistd_h=yes
ac_cv_header_wchar_h=yes
ac_cv_header_wctype_h=yes
ac_cv_header_xlocale_h=no
ac_cv_host=x86_64-pc-cygwin
ac_cv_lib_lex='none needed'
ac_cv_libtextstyle=no
ac_cv_objext=o
ac_cv_path_EGREP='/usr/bin/grep -E'
ac_cv_path_GREP=/usr/bin/grep
ac_cv_path_install='/usr/bin/install -c'
ac_cv_path_mkdir=/usr/bin/mkdir
ac_cv_prog_AWK=gawk
ac_cv_prog_CPP='gcc -E'
ac_cv_prog_HAVE_JAVAC_IN_PATH=yes
ac_cv_prog_HAVE_JAVA_IN_PATH=yes
ac_cv_prog_LEX=flex
ac_cv_prog_YACC='bison -y'
ac_cv_prog_ac_ct_AR=ar
ac_cv_prog_ac_ct_CC=gcc
ac_cv_prog_ac_ct_CXX=g++
ac_cv_prog_ac_ct_RANLIB=ranlib
ac_cv_prog_cc_c11=
ac_cv_prog_cc_g=yes
ac_cv_prog_cc_stdc=
ac_cv_prog_cxx_11=no
ac_cv_prog_cxx_cxx11=
ac_cv_prog_cxx_g=yes
ac_cv_prog_cxx_stdcxx=
ac_cv_prog_lex_is_flex=yes
ac_cv_prog_lex_root=lex.yy
ac_cv_prog_lex_supports_header_opt=no
ac_cv_prog_lex_yytext_pointer=no
ac_cv_prog_make_make_set=yes
ac_cv_safe_to_define___extensions__=yes
ac_cv_should_define__xopen_source=no
ac_cv_sys_file_offset_bits=no
ac_cv_sys_largefile_CC=no
acl_cv_hardcode_direct=no
acl_cv_hardcode_libdir_flag_spec='-L$libdir'
acl_cv_hardcode_libdir_separator=
acl_cv_hardcode_minus_L=no
acl_cv_libdirstems=lib,lib,lib
acl_cv_libext=a
acl_cv_libname_spec='lib$name'
acl_cv_library_names_spec='$libname.dll.a $libname.lib'
acl_cv_path_LD=/usr/x86_64-pc-cygwin/bin/ld.exe
acl_cv_prog_gnu_ld=yes
acl_cv_rpath=done
acl_cv_shlibext=dll
acl_cv_wl=-Wl,
am_cv_CC_dependencies_compiler_type=gcc3
am_cv_CXX_dependencies_compiler_type=gcc3
am_cv_make_support_nested_variables=yes
am_cv_prog_cc_c_o=yes
ax_cv_check_cxxflags___std_cpp03=yes
ax_cv_check_cxxflags___std_cpp11=yes
ax_cv_check_cxxflags___std_cpp14=yes
ax_cv_check_cxxflags___std_cpp17=yes
ax_cv_check_cxxflags___std_cpp20=yes
ax_cv_check_cxxflags___std_cpp2b=yes
ax_cv_check_cxxflags___std_cpp98=yes
bison_cv_c_supports_posixly_correct=yes
bison_cv_cxx_supports_posixly_correct=yes
bison_cv_cxx_works=yes
gl_cv_c_amsterdam_compiler=no
gl_cv_compiler_check_decl_option=none
gl_cv_compiler_clang=no
gl_cv_elf=no
gl_cv_host_cpu_c_abi_32bit=no
gl_cv_warn_cxx__Werror__Wunknown_warning_option=no
gl_cv_warn_cxx__fno_exceptions=yes
lv_cv_gcc_pragma_push_works=yes

## ----------------- ##
## Output variables. ##
## ----------------- ##

ACLOCAL='${SHELL} '\''/cygdrive/c/source/HomeworldSDL/tools/kas2c/bison-3.8/build-aux/missing'\'' aclocal-1.16'
ALLOCA=''
ALLOCA_H=''
AMDEPBACKSLASH='\'
AMDEP_FALSE='#'
AMDEP_TRUE=''
AMTAR='$${TAR-tar}'
AM_BACKSLASH='\'
AM_DEFAULT_V='$(AM_DEFAULT_VERBOSITY)'
AM_DEFAULT_VERBOSITY='0'
AM_V='$(V)'
APPLE_UNIVERSAL_BUILD=''
AR='ar'
ARFLAGS='cr'
ASM_SYMBOL_PREFIX=''
AUTOCONF='${SHELL} '\''/cygdrive/c/source/HomeworldSDL/tools/kas2c/bison-3.8/build-aux/missing'\'' autoconf'
AUTOHEADER='${SHELL} '\''/cygdrive/c/source/HomeworldSDL/tools/kas2c/bison-3.8/build-aux/missing'\'' autoheader'
AUTOM4TE=''
AUTOMAKE='${SHELL} '\''/cygdrive/c/source/HomeworldSDL/tools/kas2c/bison-3.8/build-aux/missing'\'' automake-1.16'
AWK='gawk'
BISON_CXX_WORKS=':'
BISON_C_WORKS=':'
BISON_LOCALEDIR=''
BITSIZEOF_PTRDIFF_T=''
BITSIZEOF_SIG_ATOMIC_T=''
BITSIZEOF_SIZE_T=''
BITSIZEOF_WCHAR_T=''
BITSIZEOF_WINT_T=''
CC='gcc'
CCDEPMODE='depmode=gcc3'
CFLAGS='-g -O2'
CFLAG_VISIBILITY=''
CLASSPATH='.;.;C:\PROGRA~2\JMF21~1.1E\lib\sound.jar;C:\PROGRA~2\JMF21~1.1E\lib\jmf.jar;C:\PROGRA~2\JMF21~1.1E\lib;'
CLASSPATH_SEPARATOR=';'
CONFIG_INCLUDE=''
CONF_JAVA='java'
CONF_JAVAC='javac -target 1.7 -source 1.7'
CPP='gcc -E'
CPPFLAGS=''
CROSS_COMPILING_FALSE=''
CROSS_COMPILING_TRUE=''
CXX03_CXXFLAGS='-std=c++03'
CXX11_CXXFLAGS='-std=c++11'
CXX14_CXXFLAGS='-std=c++14'
CXX17_CXXFLAGS='-std=c++17'
CXX20_CXXFLAGS='-std=c++20'
CXX2B_CXXFLAGS='-std=c++2b'
CXX98_CXXFLAGS='-std=c++98'
CXX='g++'
CXXDEPMODE='depmode=gcc3'
CXXFLAGS='-g -O2'
CXX_COMPILER_POSIXLY_CORRECT='true'
CYGPATH_W='cygpath -w'
C_COMPILER_POSIXLY_CORRECT='true'
DC=''
DCFLAGS=''
DEFS=''
DEPDIR='.deps'
DOT='${SHELL} '\''/cygdrive/c/source/HomeworldSDL/tools/kas2c/bison-3.8/build-aux/missing'\'' dot'
ECHO_C=''
ECHO_N='-n'
ECHO_T=''
EGREP='/usr/bin/grep -E'
EMULTIHOP_HIDDEN=''
EMULTIHOP_VALUE=''
ENABLE_BISTROMATHIC_FALSE=''
ENABLE_BISTROMATHIC_TRUE=''
ENABLE_CXX11_FALSE='#'
ENABLE_CXX11_TRUE=''
ENABLE_CXX14_FALSE='#'
ENABLE_CXX14_TRUE=''
ENABLE_CXX_FALSE='#'
ENABLE_CXX_TRUE=''
ENABLE_D_FALSE=''
ENABLE_D_TRUE='#'
ENABLE_GCC_WARNINGS_FALSE=''
ENABLE_GCC_WARNINGS_TRUE='#'
ENABLE_JAVA_FALSE='#'
ENABLE_JAVA_TRUE=''
ENABLE_YACC_FALSE='#'
ENABLE_YACC_TRUE=''
ENOLINK_HIDDEN=''
ENOLINK_VALUE=''
EOVERFLOW_HIDDEN=''
EOVERFLOW_VALUE=''
ERRNO_H=''
EXEEXT='.exe'
FLEX_CXX_WORKS_FALSE=''
FLEX_CXX_WORKS_TRUE='#'
FLEX_SCANNER_CXXFLAGS=''
FLEX_WORKS_FALSE=''
FLEX_WORKS_TRUE='#'
FLOAT_H=''
GCC='yes'
GETOPT_CDEFS_H=''
GETOPT_H=''
GETTEXT_MACRO_VERSION=''
GL_COND_LIBTOOL_FALSE=''
GL_COND_LIBTOOL_TRUE=''
GL_GENERATE_ALLOCA_H_FALSE=''
GL_GENERATE_ALLOCA_H_TRUE=''
GL_GENERATE_ERRNO_H_FALSE=''
GL_GENERATE_ERRNO_H_TRUE=''
GL_GENERATE_FLOAT_H_FALSE=''
GL_GENERATE_FLOAT_H_TRUE=''
GL_GENERATE_ICONV_H_FALSE=''
GL_GENERATE_ICONV_H_TRUE=''
GL_GENERATE_LIMITS_H_FALSE=''
GL_GENERATE_LIMITS_H_TRUE=''
GL_GENERATE_STDBOOL_H_FALSE=''
GL_GENERATE_STDBOOL_H_TRUE=''
GL_GENERATE_STDDEF_H_FALSE=''
GL_GENERATE_STDDEF_H_TRUE=''
GL_GENERATE_STDINT_H_FALSE=''
GL_GENERATE_STDINT_H_TRUE=''
GL_GENERATE_TEXTSTYLE_H_FALSE='#'
GL_GENERATE_TEXTSTYLE_H_TRUE=''
GL_GNULIB_ACCESS=''
GL_GNULIB_ACOSF=''
GL_GNULIB_ACOSL=''
GL_GNULIB_ALIGNED_ALLOC=''
GL_GNULIB_ALPHASORT=''
GL_GNULIB_ASINF=''
GL_GNULIB_ASINL=''
GL_GNULIB_ATAN2F=''
GL_GNULIB_ATANF=''
GL_GNULIB_ATANL=''
GL_GNULIB_ATOLL=''
GL_GNULIB_BTOWC=''
GL_GNULIB_CALLOC_POSIX=''
GL_GNULIB_CANONICALIZE_FILE_NAME=''
GL_GNULIB_CBRT=''
GL_GNULIB_CBRTF=''
GL_GNULIB_CBRTL=''
GL_GNULIB_CEIL=''
GL_GNULIB_CEILF=''
GL_GNULIB_CEILL=''
GL_GNULIB_CHDIR=''
GL_GNULIB_CHOWN=''
GL_GNULIB_CLOSE=''
GL_GNULIB_CLOSEDIR=''
GL_GNULIB_COPYSIGN=''
GL_GNULIB_COPYSIGNF=''
GL_GNULIB_COPYSIGNL=''
GL_GNULIB_COPY_FILE_RANGE=''
GL_GNULIB_COSF=''
GL_GNULIB_COSHF=''
GL_GNULIB_COSL=''
GL_GNULIB_CREAT=''
GL_GNULIB_CTIME=''
GL_GNULIB_DIRFD=''
GL_GNULIB_DPRINTF=''
GL_GNULIB_DUP2=''
GL_GNULIB_DUP3=''
GL_GNULIB_DUP=''
GL_GNULIB_DUPLOCALE=''
GL_GNULIB_ENVIRON=''
GL_GNULIB_EUIDACCESS=''
GL_GNULIB_EXECL=''
GL_GNULIB_EXECLE=''
GL_GNULIB_EXECLP=''
GL_GNULIB_EXECV=''
GL_GNULIB_EXECVE=''
GL_GNULIB_EXECVP=''
GL_GNULIB_EXECVPE=''
GL_GNULIB_EXP2=''
GL_GNULIB_EXP2F=''
GL_GNULIB_EXP2L=''
GL_GNULIB_EXPF=''
GL_GNULIB_EXPL=''
GL_GNULIB_EXPLICIT_BZERO=''
GL_GNULIB_EXPM1=''
GL_GNULIB_EXPM1F=''
GL_GNULIB_EXPM1L=''
GL_GNULIB_FABSF=''
GL_GNULIB_FABSL=''
GL_GNULIB_FACCESSAT=''
GL_GNULIB_FCHDIR=''
GL_GNULIB_FCHMODAT=''
GL_GNULIB_FCHOWNAT=''
GL_GNULIB_FCLOSE=''
GL_GNULIB_FCNTL=''
GL_GNULIB_FDATASYNC=''
GL_GNULIB_FDOPEN=''
GL_GNULIB_FDOPENDIR=''
GL_GNULIB_FFLUSH=''
GL_GNULIB_FFS=''
GL_GNULIB_FFSL=''
GL_GNULIB_FFSLL=''
GL_GNULIB_FGETC=''
GL_GNULIB_FGETS=''
GL_GNULIB_FLOOR=''
GL_GNULIB_FLOORF=''
GL_GNULIB_FLOORL=''
GL_GNULIB_FMA=''
GL_GNULIB_FMAF=''
GL_GNULIB_FMAL=''
GL_GNULIB_FMOD=''
GL_GNULIB_FMODF=''
GL_GNULIB_FMODL=''
GL_GNULIB_FOPEN=''
GL_GNULIB_FPRINTF=''
GL_GNULIB_FPRINTF_POSIX=''
GL_GNULIB_FPURGE=''
GL_GNULIB_FPUTC=''
GL_GNULIB_FPUTS=''
GL_GNULIB_FREAD=''
GL_GNULIB_FREE_POSIX=''
GL_GNULIB_FREOPEN=''
GL_GNULIB_FREXP=''
GL_GNULIB_FREXPF=''
GL_GNULIB_FREXPL=''
GL_GNULIB_FSCANF=''
GL_GNULIB_FSEEK=''
GL_GNULIB_FSEEKO=''
GL_GNULIB_FSTAT=''
GL_GNULIB_FSTATAT=''
GL_GNULIB_FSYNC=''
GL_GNULIB_FTELL=''
GL_GNULIB_FTELLO=''
GL_GNULIB_FTRUNCATE=''
GL_GNULIB_FUTIMENS=''
GL_GNULIB_FWRITE=''
GL_GNULIB_GETC=''
GL_GNULIB_GETCHAR=''
GL_GNULIB_GETCWD=''
GL_GNULIB_GETDELIM=''
GL_GNULIB_GETDOMAINNAME=''
GL_GNULIB_GETDTABLESIZE=''
GL_GNULIB_GETENTROPY=''
GL_GNULIB_GETGROUPS=''
GL_GNULIB_GETHOSTNAME=''
GL_GNULIB_GETLINE=''
GL_GNULIB_GETLOADAVG=''
GL_GNULIB_GETLOGIN=''
GL_GNULIB_GETLOGIN_R=''
GL_GNULIB_GETOPT_POSIX=''
GL_GNULIB_GETPAGESIZE=''
GL_GNULIB_GETPASS=''
GL_GNULIB_GETRUSAGE=''
GL_GNULIB_GETSUBOPT=''
GL_GNULIB_GETTIMEOFDAY=''
GL_GNULIB_GETUMASK=''
GL_GNULIB_GETUSERSHELL=''
GL_GNULIB_GRANTPT=''
GL_GNULIB_GROUP_MEMBER=''
GL_GNULIB_HYPOT=''
GL_GNULIB_HYPOTF=''
GL_GNULIB_HYPOTL=''
GL_GNULIB_ICONV=''
GL_GNULIB_ILOGB=''
GL_GNULIB_ILOGBF=''
GL_GNULIB_ILOGBL=''
GL_GNULIB_IMAXABS=''
GL_GNULIB_IMAXDIV=''
GL_GNULIB_IOCTL=''
GL_GNULIB_ISATTY=''
GL_GNULIB_ISFINITE=''
GL_GNULIB_ISINF=''
GL_GNULIB_ISNAN=''
GL_GNULIB_ISNAND=''
GL_GNULIB_ISNANF=''
GL_GNULIB_ISNANL=''
GL_GNULIB_ISWBLANK=''
GL_GNULIB_ISWCTYPE=''
GL_GNULIB_ISWDIGIT=''
GL_GNULIB_ISWXDIGIT=''
GL_GNULIB_LCHMOD=''
GL_GNULIB_LCHOWN=''
GL_GNULIB_LDEXPF=''
GL_GNULIB_LDEXPL=''
GL_GNULIB_LINK=''
GL_GNULIB_LINKAT=''
GL_GNULIB_LOCALECONV=''
GL_GNULIB_LOCALENAME=''
GL_GNULIB_LOCALTIME=''
GL_GNULIB_LOG10=''
GL_GNULIB_LOG10F=''
GL_GNULIB_LOG10L=''
GL_GNULIB_LOG1P=''
GL_GNULIB_LOG1PF=''
GL_GNULIB_LOG1PL=''
GL_GNULIB_LOG2=''
GL_GNULIB_LOG2F=''
GL_GNULIB_LOG2L=''
GL_GNULIB_LOG=''
GL_GNULIB_LOGB=''
GL_GNULIB_LOGBF=''
GL_GNULIB_LOGBL=''
GL_GNULIB_LOGF=''
GL_GNULIB_LOGL=''
GL_GNULIB_LSEEK=''
GL_GNULIB_LSTAT=''
GL_GNULIB_MALLOC_POSIX=''
GL_GNULIB_MBRLEN=''
GL_GNULIB_MBRTOWC=''
GL_GNULIB_MBSCASECMP=''
GL_GNULIB_MBSCASESTR=''
GL_GNULIB_MBSCHR=''
GL_GNULIB_MBSCSPN=''
GL_GNULIB_MBSINIT=''
GL_GNULIB_MBSLEN=''
GL_GNULIB_MBSNCASECMP=''
GL_GNULIB_MBSNLEN=''
GL_GNULIB_MBSNRTOWCS=''
GL_GNULIB_MBSPBRK=''
GL_GNULIB_MBSPCASECMP=''
GL_GNULIB_MBSRCHR=''
GL_GNULIB_MBSRTOWCS=''
GL_GNULIB_MBSSEP=''
GL_GNULIB_MBSSPN=''
GL_GNULIB_MBSSTR=''
GL_GNULIB_MBSTOK_R=''
GL_GNULIB_MBTOWC=''
GL_GNULIB_MDA_ACCESS=''
GL_GNULIB_MDA_CHDIR=''
GL_GNULIB_MDA_CHMOD=''
GL_GNULIB_MDA_CLOSE=''
GL_GNULIB_MDA_CREAT=''
GL_GNULIB_MDA_DUP2=''
GL_GNULIB_MDA_DUP=''
GL_GNULIB_MDA_ECVT=''
GL_GNULIB_MDA_EXECL=''
GL_GNULIB_MDA_EXECLE=''
GL_GNULIB_MDA_EXECLP=''
GL_GNULIB_MDA_EXECV=''
GL_GNULIB_MDA_EXECVE=''
GL_GNULIB_MDA_EXECVP=''
GL_GNULIB_MDA_EXECVPE=''
GL_GNULIB_MDA_FCLOSEALL=''
GL_GNULIB_MDA_FCVT=''
GL_GNULIB_MDA_FDOPEN=''
GL_GNULIB_MDA_FILENO=''
GL_GNULIB_MDA_GCVT=''
GL_GNULIB_MDA_GETCWD=''
GL_GNULIB_MDA_GETPID=''
GL_GNULIB_MDA_GETW=''
GL_GNULIB_MDA_ISATTY=''
GL_GNULIB_MDA_J0=''
GL_GNULIB_MDA_J1=''
GL_GNULIB_MDA_JN=''
GL_GNULIB_MDA_LSEEK=''
GL_GNULIB_MDA_MEMCCPY=''
GL_GNULIB_MDA_MKDIR=''
GL_GNULIB_MDA_MKTEMP=''
GL_GNULIB_MDA_OPEN=''
GL_GNULIB_MDA_PUTENV=''
GL_GNULIB_MDA_PUTW=''
GL_GNULIB_MDA_READ=''
GL_GNULIB_MDA_RMDIR=''
GL_GNULIB_MDA_STRDUP=''
GL_GNULIB_MDA_SWAB=''
GL_GNULIB_MDA_TEMPNAM=''
GL_GNULIB_MDA_TZSET=''
GL_GNULIB_MDA_UMASK=''
GL_GNULIB_MDA_UNLINK=''
GL_GNULIB_MDA_WCSDUP=''
GL_GNULIB_MDA_WRITE=''
GL_GNULIB_MDA_Y0=''
GL_GNULIB_MDA_Y1=''
GL_GNULIB_MDA_YN=''
GL_GNULIB_MEMCHR=''
GL_GNULIB_MEMMEM=''
GL_GNULIB_MEMPCPY=''
GL_GNULIB_MEMRCHR=''
GL_GNULIB_MKDIR=''
GL_GNULIB_MKDIRAT=''
GL_GNULIB_MKDTEMP=''
GL_GNULIB_MKFIFO=''
GL_GNULIB_MKFIFOAT=''
GL_GNULIB_MKNOD=''
GL_GNULIB_MKNODAT=''
GL_GNULIB_MKOSTEMP=''
GL_GNULIB_MKOSTEMPS=''
GL_GNULIB_MKSTEMP=''
GL_GNULIB_MKSTEMPS=''
GL_GNULIB_MKTIME=''
GL_GNULIB_MODF=''
GL_GNULIB_MODFF=''
GL_GNULIB_MODFL=''
GL_GNULIB_NANOSLEEP=''
GL_GNULIB_NONBLOCKING=''
GL_GNULIB_OBSTACK_PRINTF=''
GL_GNULIB_OBSTACK_PRINTF_POSIX=''
GL_GNULIB_OPEN=''
GL_GNULIB_OPENAT=''
GL_GNULIB_OPENDIR=''
GL_GNULIB_OVERRIDES_STRUCT_STAT=''
GL_GNULIB_PCLOSE=''
GL_GNULIB_PERROR=''
GL_GNULIB_PIPE2=''
GL_GNULIB_PIPE=''
GL_GNULIB_POPEN=''
GL_GNULIB_POSIX_MEMALIGN=''
GL_GNULIB_POSIX_OPENPT=''
GL_GNULIB_POSIX_SPAWN=''
GL_GNULIB_POSIX_SPAWNATTR_DESTROY=''
GL_GNULIB_POSIX_SPAWNATTR_GETFLAGS=''
GL_GNULIB_POSIX_SPAWNATTR_GETPGROUP=''
GL_GNULIB_POSIX_SPAWNATTR_GETSCHEDPARAM=''
GL_GNULIB_POSIX_SPAWNATTR_GETSCHEDPOLICY=''
GL_GNULIB_POSIX_SPAWNATTR_GETSIGDEFAULT=''
GL_GNULIB_POSIX_SPAWNATTR_GETSIGMASK=''
GL_GNULIB_POSIX_SPAWNATTR_INIT=''
GL_GNULIB_POSIX_SPAWNATTR_SETFLAGS=''
GL_GNULIB_POSIX_SPAWNATTR_SETPGROUP=''
GL_GNULIB_POSIX_SPAWNATTR_SETSCHEDPARAM=''
GL_GNULIB_POSIX_SPAWNATTR_SETSCHEDPOLICY=''
GL_GNULIB_POSIX_SPAWNATTR_SETSIGDEFAULT=''
GL_GNULIB_POSIX_SPAWNATTR_SETSIGMASK=''
GL_GNULIB_POSIX_SPAWNP=''
GL_GNULIB_POSIX_SPAWN_FILE_ACTIONS_ADDCHDIR=''
GL_GNULIB_POSIX_SPAWN_FILE_ACTIONS_ADDCLOSE=''
GL_GNULIB_POSIX_SPAWN_FILE_ACTIONS_ADDDUP2=''
GL_GNULIB_POSIX_SPAWN_FILE_ACTIONS_ADDFCHDIR=''
GL_GNULIB_POSIX_SPAWN_FILE_ACTIONS_ADDOPEN=''
GL_GNULIB_POSIX_SPAWN_FILE_ACTIONS_DESTROY=''
GL_GNULIB_POSIX_SPAWN_FILE_ACTIONS_INIT=''
GL_GNULIB_POWF=''
GL_GNULIB_PREAD=''
GL_GNULIB_PRINTF=''
GL_GNULIB_PRINTF_POSIX=''
GL_GNULIB_PTHREAD_SIGMASK=''
GL_GNULIB_PTSNAME=''
GL_GNULIB_PTSNAME_R=''
GL_GNULIB_PUTC=''
GL_GNULIB_PUTCHAR=''
GL_GNULIB_PUTENV=''
GL_GNULIB_PUTS=''
GL_GNULIB_PWRITE=''
GL_GNULIB_QSORT_R=''
GL_GNULIB_RAISE=''
GL_GNULIB_RANDOM=''
GL_GNULIB_RANDOM_R=''
GL_GNULIB_RAWMEMCHR=''
GL_GNULIB_READ=''
GL_GNULIB_READDIR=''
GL_GNULIB_READLINK=''
GL_GNULIB_READLINKAT=''
GL_GNULIB_REALLOCARRAY=''
GL_GNULIB_REALLOC_POSIX=''
GL_GNULIB_REALPATH=''
GL_GNULIB_REMAINDER=''
GL_GNULIB_REMAINDERF=''
GL_GNULIB_REMAINDERL=''
GL_GNULIB_REMOVE=''
GL_GNULIB_RENAME=''
GL_GNULIB_RENAMEAT=''
GL_GNULIB_REWINDDIR=''
GL_GNULIB_RINT=''
GL_GNULIB_RINTF=''
GL_GNULIB_RINTL=''
GL_GNULIB_RMDIR=''
GL_GNULIB_ROUND=''
GL_GNULIB_ROUNDF=''
GL_GNULIB_ROUNDL=''
GL_GNULIB_RPMATCH=''
GL_GNULIB_SCANDIR=''
GL_GNULIB_SCANF=''
GL_GNULIB_SCHED_YIELD=''
GL_GNULIB_SECURE_GETENV=''
GL_GNULIB_SETENV=''
GL_GNULIB_SETHOSTNAME=''
GL_GNULIB_SETLOCALE=''
GL_GNULIB_SETLOCALE_NULL=''
GL_GNULIB_SIGABBREV_NP=''
GL_GNULIB_SIGACTION=''
GL_GNULIB_SIGDESCR_NP=''
GL_GNULIB_SIGNAL_H_SIGPIPE=''
GL_GNULIB_SIGNBIT=''
GL_GNULIB_SIGPROCMASK=''
GL_GNULIB_SINF=''
GL_GNULIB_SINHF=''
GL_GNULIB_SINL=''
GL_GNULIB_SLEEP=''
GL_GNULIB_SNPRINTF=''
GL_GNULIB_SPRINTF_POSIX=''
GL_GNULIB_SQRTF=''
GL_GNULIB_SQRTL=''
GL_GNULIB_STAT=''
GL_GNULIB_STDIO_H_NONBLOCKING=''
GL_GNULIB_STDIO_H_SIGPIPE=''
GL_GNULIB_STPCPY=''
GL_GNULIB_STPNCPY=''
GL_GNULIB_STRCASESTR=''
GL_GNULIB_STRCHRNUL=''
GL_GNULIB_STRDUP=''
GL_GNULIB_STRERROR=''
GL_GNULIB_STRERRORNAME_NP=''
GL_GNULIB_STRERROR_R=''
GL_GNULIB_STRFTIME=''
GL_GNULIB_STRNCAT=''
GL_GNULIB_STRNDUP=''
GL_GNULIB_STRNLEN=''
GL_GNULIB_STRPBRK=''
GL_GNULIB_STRPTIME=''
GL_GNULIB_STRSEP=''
GL_GNULIB_STRSIGNAL=''
GL_GNULIB_STRSTR=''
GL_GNULIB_STRTOD=''
GL_GNULIB_STRTOIMAX=''
GL_GNULIB_STRTOK_R=''
GL_GNULIB_STRTOL=''
GL_GNULIB_STRTOLD=''
GL_GNULIB_STRTOLL=''
GL_GNULIB_STRTOUL=''
GL_GNULIB_STRTOULL=''
GL_GNULIB_STRTOUMAX=''
GL_GNULIB_STRVERSCMP=''
GL_GNULIB_SYMLINK=''
GL_GNULIB_SYMLINKAT=''
GL_GNULIB_SYSTEM_POSIX=''
GL_GNULIB_TANF=''
GL_GNULIB_TANHF=''
GL_GNULIB_TANL=''
GL_GNULIB_TCGETSID=''
GL_GNULIB_TIMEGM=''
GL_GNULIB_TIMES=''
GL_GNULIB_TIMESPEC_GET=''
GL_GNULIB_TIME_R=''
GL_GNULIB_TIME_RZ=''
GL_GNULIB_TMPFILE=''
GL_GNULIB_TOWCTRANS=''
GL_GNULIB_TRUNC=''
GL_GNULIB_TRUNCATE=''
GL_GNULIB_TRUNCF=''
GL_GNULIB_TRUNCL=''
GL_GNULIB_TTYNAME_R=''
GL_GNULIB_TZSET=''
GL_GNULIB_UNISTD_H_GETOPT=''
GL_GNULIB_UNISTD_H_NONBLOCKING=''
GL_GNULIB_UNISTD_H_SIGPIPE=''
GL_GNULIB_UNLINK=''
GL_GNULIB_UNLINKAT=''
GL_GNULIB_UNLOCKPT=''
GL_GNULIB_UNSETENV=''
GL_GNULIB_USLEEP=''
GL_GNULIB_UTIMENSAT=''
GL_GNULIB_VASPRINTF=''
GL_GNULIB_VDPRINTF=''
GL_GNULIB_VFPRINTF=''
GL_GNULIB_VFPRINTF_POSIX=''
GL_GNULIB_VFSCANF=''
GL_GNULIB_VPRINTF=''
GL_GNULIB_VPRINTF_POSIX=''
GL_GNULIB_VSCANF=''
GL_GNULIB_VSNPRINTF=''
GL_GNULIB_VSPRINTF_POSIX=''
GL_GNULIB_WAITPID=''
GL_GNULIB_WCPCPY=''
GL_GNULIB_WCPNCPY=''
GL_GNULIB_WCRTOMB=''
GL_GNULIB_WCSCASECMP=''
GL_GNULIB_WCSCAT=''
GL_GNULIB_WCSCHR=''
GL_GNULIB_WCSCMP=''
GL_GNULIB_WCSCOLL=''
GL_GNULIB_WCSCPY=''
GL_GNULIB_WCSCSPN=''
GL_GNULIB_WCSDUP=''
GL_GNULIB_WCSFTIME=''
GL_GNULIB_WCSLEN=''
GL_GNULIB_WCSNCASECMP=''
GL_GNULIB_WCSNCAT=''
GL_GNULIB_WCSNCMP=''
GL_GNULIB_WCSNCPY=''
GL_GNULIB_WCSNLEN=''
GL_GNULIB_WCSNRTOMBS=''
GL_GNULIB_WCSPBRK=''
GL_GNULIB_WCSRCHR=''
GL_GNULIB_WCSRTOMBS=''
GL_GNULIB_WCSSPN=''
GL_GNULIB_WCSSTR=''
GL_GNULIB_WCSTOK=''
GL_GNULIB_WCSWIDTH=''
GL_GNULIB_WCSXFRM=''
GL_GNULIB_WCTOB=''
GL_GNULIB_WCTOMB=''
GL_GNULIB_WCTRANS=''
GL_GNULIB_WCTYPE=''
GL_GNULIB_WCWIDTH=''
GL_GNULIB_WMEMCHR=''
GL_GNULIB_WMEMCMP=''
GL_GNULIB_WMEMCPY=''
GL_GNULIB_WMEMMOVE=''
GL_GNULIB_WMEMPCPY=''
GL_GNULIB_WMEMSET=''
GL_GNULIB_WRITE=''
GL_GNULIB__EXIT=''
GMSGFMT=''
GMSGFMT_015=''
GNULIBHEADERS_OVERRIDE_WINT_T=''
GNULIB_GETTIMEOFDAY=''
GREP='/usr/bin/grep'
HAVE_ACOSF=''
HAVE_ACOSL=''
HAVE_ALIGNED_ALLOC=''
HAVE_ALLOCA_H=''
HAVE_ALPHASORT=''
HAVE_ASINF=''
HAVE_ASINL=''
HAVE_ATAN2F=''
HAVE_ATANF=''
HAVE_ATANL=''
HAVE_ATOLL=''
HAVE_BTOWC=''
HAVE_C99_STDINT_H=''
HAVE_CANONICALIZE_FILE_NAME=''
HAVE_CBRT=''
HAVE_CBRTF=''
HAVE_CBRTL=''
HAVE_CHOWN=''
HAVE_CLOSEDIR=''
HAVE_COPYSIGN=''
HAVE_COPYSIGNL=''
HAVE_COPY_FILE_RANGE=''
HAVE_COSF=''
HAVE_COSHF=''
HAVE_COSL=''
HAVE_CRTDEFS_H=''
HAVE_DECL_ACOSL=''
HAVE_DECL_ASINL=''
HAVE_DECL_ATANL=''
HAVE_DECL_CBRTF=''
HAVE_DECL_CBRTL=''
HAVE_DECL_CEILF=''
HAVE_DECL_CEILL=''
HAVE_DECL_COPYSIGNF=''
HAVE_DECL_COSL=''
HAVE_DECL_DIRFD=''
HAVE_DECL_ECVT=''
HAVE_DECL_ENVIRON=''
HAVE_DECL_EXECVPE=''
HAVE_DECL_EXP2=''
HAVE_DECL_EXP2F=''
HAVE_DECL_EXP2L=''
HAVE_DECL_EXPL=''
HAVE_DECL_EXPM1L=''
HAVE_DECL_FCHDIR=''
HAVE_DECL_FCLOSEALL=''
HAVE_DECL_FCVT=''
HAVE_DECL_FDATASYNC=''
HAVE_DECL_FDOPENDIR=''
HAVE_DECL_FLOORF=''
HAVE_DECL_FLOORL=''
HAVE_DECL_FPURGE=''
HAVE_DECL_FREXPL=''
HAVE_DECL_FSEEKO=''
HAVE_DECL_FTELLO=''
HAVE_DECL_GCVT=''
HAVE_DECL_GETDELIM=''
HAVE_DECL_GETDOMAINNAME=''
HAVE_DECL_GETLINE=''
HAVE_DECL_GETLOADAVG=''
HAVE_DECL_GETLOGIN=''
HAVE_DECL_GETLOGIN_R=''
HAVE_DECL_GETPAGESIZE=''
HAVE_DECL_GETUSERSHELL=''
HAVE_DECL_IMAXABS=''
HAVE_DECL_IMAXDIV=''
HAVE_DECL_INITSTATE=''
HAVE_DECL_LDEXPL=''
HAVE_DECL_LOCALTIME_R=''
HAVE_DECL_LOG10L=''
HAVE_DECL_LOG2=''
HAVE_DECL_LOG2F=''
HAVE_DECL_LOG2L=''
HAVE_DECL_LOGB=''
HAVE_DECL_LOGL=''
HAVE_DECL_MEMMEM=''
HAVE_DECL_MEMRCHR=''
HAVE_DECL_OBSTACK_PRINTF=''
HAVE_DECL_REMAINDER=''
HAVE_DECL_REMAINDERL=''
HAVE_DECL_RINTF=''
HAVE_DECL_ROUND=''
HAVE_DECL_ROUNDF=''
HAVE_DECL_ROUNDL=''
HAVE_DECL_SETENV=''
HAVE_DECL_SETHOSTNAME=''
HAVE_DECL_SETSTATE=''
HAVE_DECL_SINL=''
HAVE_DECL_SNPRINTF=''
HAVE_DECL_SQRTL=''
HAVE_DECL_STRDUP=''
HAVE_DECL_STRERROR_R=''
HAVE_DECL_STRNCASECMP=''
HAVE_DECL_STRNDUP=''
HAVE_DECL_STRNLEN=''
HAVE_DECL_STRSIGNAL=''
HAVE_DECL_STRTOIMAX=''
HAVE_DECL_STRTOK_R=''
HAVE_DECL_STRTOUMAX=''
HAVE_DECL_TANL=''
HAVE_DECL_TCGETSID=''
HAVE_DECL_TRUNC=''
HAVE_DECL_TRUNCATE=''
HAVE_DECL_TRUNCF=''
HAVE_DECL_TRUNCL=''
HAVE_DECL_TTYNAME_R=''
HAVE_DECL_UNSETENV=''
HAVE_DECL_VSNPRINTF=''
HAVE_DECL_WCSDUP=''
HAVE_DECL_WCTOB=''
HAVE_DECL_WCWIDTH=''
HAVE_DIRENT_H=''
HAVE_DPRINTF=''
HAVE_DUP3=''
HAVE_DUPLOCALE=''
HAVE_EUIDACCESS=''
HAVE_EXECVPE=''
HAVE_EXPF=''
HAVE_EXPL=''
HAVE_EXPLICIT_BZERO=''
HAVE_EXPM1=''
HAVE_EXPM1F=''
HAVE_FABSF=''
HAVE_FABSL=''
HAVE_FACCESSAT=''
HAVE_FCHDIR=''
HAVE_FCHMODAT=''
HAVE_FCHOWNAT=''
HAVE_FCNTL=''
HAVE_FDATASYNC=''
HAVE_FDOPENDIR=''
HAVE_FEATURES_H=''
HAVE_FFS=''
HAVE_FFSL=''
HAVE_FFSLL=''
HAVE_FMA=''
HAVE_FMAF=''
HAVE_FMAL=''
HAVE_FMODF=''
HAVE_FMODL=''
HAVE_FREELOCALE=''
HAVE_FREXPF=''
HAVE_FSEEKO=''
HAVE_FSTATAT=''
HAVE_FSYNC=''
HAVE_FTELLO=''
HAVE_FTRUNCATE=''
HAVE_FUTIMENS=''
HAVE_GCJ_C=''
HAVE_GCJ_IN_PATH=''
HAVE_GETDTABLESIZE=''
HAVE_GETENTROPY=''
HAVE_GETGROUPS=''
HAVE_GETHOSTNAME=''
HAVE_GETLOGIN=''
HAVE_GETOPT_H=''
HAVE_GETPAGESIZE=''
HAVE_GETPASS=''
HAVE_GETRUSAGE=''
HAVE_GETSUBOPT=''
HAVE_GETTIMEOFDAY=''
HAVE_GETUMASK=''
HAVE_GIJ=''
HAVE_GIJ_IN_PATH=''
HAVE_GRANTPT=''
HAVE_GROUP_MEMBER=''
HAVE_HYPOTF=''
HAVE_HYPOTL=''
HAVE_ILOGB=''
HAVE_ILOGBF=''
HAVE_ILOGBL=''
HAVE_IMAXDIV_T=''
HAVE_INITSTATE=''
HAVE_INTTYPES_H=''
HAVE_ISNAND=''
HAVE_ISNANF=''
HAVE_ISNANL=''
HAVE_ISWBLANK=''
HAVE_ISWCNTRL=''
HAVE_JAVA='1'
HAVE_JAVAC='1'
HAVE_JAVAC_ENVVAR=''
HAVE_JAVAC_IN_PATH='yes'
HAVE_JAVA_ENVVAR=''
HAVE_JAVA_IN_PATH='yes'
HAVE_JIKES=''
HAVE_JIKES_IN_PATH=''
HAVE_JRE=''
HAVE_JRE_IN_PATH=''
HAVE_JVIEW=''
HAVE_JVIEW_IN_PATH=''
HAVE_LCHMOD=''
HAVE_LCHOWN=''
HAVE_LDEXPF=''
HAVE_LIBTEXTSTYLE='no'
HAVE_LINK=''
HAVE_LINKAT=''
HAVE_LOG10F=''
HAVE_LOG10L=''
HAVE_LOG1P=''
HAVE_LOG1PF=''
HAVE_LOG1PL=''
HAVE_LOGBF=''
HAVE_LOGBL=''
HAVE_LOGF=''
HAVE_LOGL=''
HAVE_LSTAT=''
HAVE_MAX_ALIGN_T=''
HAVE_MBRLEN=''
HAVE_MBRTOWC=''
HAVE_MBSINIT=''
HAVE_MBSLEN=''
HAVE_MBSNRTOWCS=''
HAVE_MBSRTOWCS=''
HAVE_MBTOWC=''
HAVE_MEMPCPY=''
HAVE_MKDIRAT=''
HAVE_MKDTEMP=''
HAVE_MKFIFO=''
HAVE_MKFIFOAT=''
HAVE_MKNOD=''
HAVE_MKNODAT=''
HAVE_MKOSTEMP=''
HAVE_MKOSTEMPS=''
HAVE_MKSTEMP=''
HAVE_MKSTEMPS=''
HAVE_MODFF=''
HAVE_MODFL=''
HAVE_MSVC_INVALID_PARAMETER_HANDLER=''
HAVE_NANOSLEEP=''
HAVE_NEWLOCALE=''
HAVE_OPENAT=''
HAVE_OPENDIR=''
HAVE_OS_H=''
HAVE_PCLOSE=''
HAVE_PIPE2=''
HAVE_PIPE=''
HAVE_POPEN=''
HAVE_POSIX_MEMALIGN=''
HAVE_POSIX_OPENPT=''
HAVE_POSIX_SIGNALBLOCKING=''
HAVE_POSIX_SPAWN=''
HAVE_POSIX_SPAWNATTR_T=''
HAVE_POSIX_SPAWN_FILE_ACTIONS_ADDCHDIR=''
HAVE_POSIX_SPAWN_FILE_ACTIONS_ADDFCHDIR=''
HAVE_POSIX_SPAWN_FILE_ACTIONS_T=''
HAVE_POWF=''
HAVE_PREAD=''
HAVE_PTHREAD_SIGMASK=''
HAVE_PTSNAME=''
HAVE_PTSNAME_R=''
HAVE_PWRITE=''
HAVE_QSORT_R=''
HAVE_RAISE=''
HAVE_RANDOM=''
HAVE_RANDOM_H=''
HAVE_RANDOM_R=''
HAVE_RAWMEMCHR=''
HAVE_READDIR=''
HAVE_READLINK=''
HAVE_READLINKAT=''
HAVE_REALLOCARRAY=''
HAVE_REALPATH=''
HAVE_REMAINDER=''
HAVE_REMAINDERF=''
HAVE_RENAMEAT=''
HAVE_REWINDDIR=''
HAVE_RINT=''
HAVE_RINTL=''
HAVE_RPMATCH=''
HAVE_SAME_LONG_DOUBLE_AS_DOUBLE=''
HAVE_SCANDIR=''
HAVE_SCHED_H=''
HAVE_SCHED_YIELD=''
HAVE_SECURE_GETENV=''
HAVE_SETENV=''
HAVE_SETHOSTNAME=''
HAVE_SETSTATE=''
HAVE_SIGABBREV_NP=''
HAVE_SIGACTION=''
HAVE_SIGDESCR_NP=''
HAVE_SIGHANDLER_T=''
HAVE_SIGINFO_T=''
HAVE_SIGNED_SIG_ATOMIC_T=''
HAVE_SIGNED_WCHAR_T=''
HAVE_SIGNED_WINT_T=''
HAVE_SIGSET_T=''
HAVE_SINF=''
HAVE_SINHF=''
HAVE_SINL=''
HAVE_SLEEP=''
HAVE_SPAWN_H=''
HAVE_SQRTF=''
HAVE_SQRTL=''
HAVE_STDINT_H=''
HAVE_STPCPY=''
HAVE_STPNCPY=''
HAVE_STRCASECMP=''
HAVE_STRCASESTR=''
HAVE_STRCHRNUL=''
HAVE_STRERRORNAME_NP=''
HAVE_STRINGS_H=''
HAVE_STRPBRK=''
HAVE_STRPTIME=''
HAVE_STRSEP=''
HAVE_STRTOD=''
HAVE_STRTOL=''
HAVE_STRTOLD=''
HAVE_STRTOLL=''
HAVE_STRTOUL=''
HAVE_STRTOULL=''
HAVE_STRUCT_RANDOM_DATA=''
HAVE_STRUCT_SCHED_PARAM=''
HAVE_STRUCT_SIGACTION_SA_SIGACTION=''
HAVE_STRUCT_TIMEVAL=''
HAVE_STRUCT_TMS=''
HAVE_STRVERSCMP=''
HAVE_SYMLINK=''
HAVE_SYMLINKAT=''
HAVE_SYS_BITYPES_H=''
HAVE_SYS_CDEFS_H=''
HAVE_SYS_INTTYPES_H=''
HAVE_SYS_IOCTL_H=''
HAVE_SYS_LOADAVG_H=''
HAVE_SYS_PARAM_H=''
HAVE_SYS_RESOURCE_H=''
HAVE_SYS_TIMES_H=''
HAVE_SYS_TIME_H=''
HAVE_SYS_TYPES_H=''
HAVE_TANF=''
HAVE_TANHF=''
HAVE_TANL=''
HAVE_TERMIOS_H=''
HAVE_TIMEGM=''
HAVE_TIMES=''
HAVE_TIMESPEC_GET=''
HAVE_TIMEZONE_T=''
HAVE_TYPE_VOLATILE_SIG_ATOMIC_T=''
HAVE_UNISTD_H=''
HAVE_UNLINKAT=''
HAVE_UNLOCKPT=''
HAVE_USLEEP=''
HAVE_UTIMENSAT=''
HAVE_VASPRINTF=''
HAVE_VDPRINTF=''
HAVE_VISIBILITY=''
HAVE_WCHAR_H=''
HAVE_WCHAR_T=''
HAVE_WCPCPY=''
HAVE_WCPNCPY=''
HAVE_WCRTOMB=''
HAVE_WCSCASECMP=''
HAVE_WCSCAT=''
HAVE_WCSCHR=''
HAVE_WCSCMP=''
HAVE_WCSCOLL=''
HAVE_WCSCPY=''
HAVE_WCSCSPN=''
HAVE_WCSDUP=''
HAVE_WCSFTIME=''
HAVE_WCSLEN=''
HAVE_WCSNCASECMP=''
HAVE_WCSNCAT=''
HAVE_WCSNCMP=''
HAVE_WCSNCPY=''
HAVE_WCSNLEN=''
HAVE_WCSNRTOMBS=''
HAVE_WCSPBRK=''
HAVE_WCSRCHR=''
HAVE_WCSRTOMBS=''
HAVE_WCSSPN=''
HAVE_WCSSTR=''
HAVE_WCSTOK=''
HAVE_WCSWIDTH=''
HAVE_WCSXFRM=''
HAVE_WCTRANS_T=''
HAVE_WCTYPE_H=''
HAVE_WCTYPE_T=''
HAVE_WINSOCK2_H=''
HAVE_WINT_T=''
HAVE_WMEMCHR=''
HAVE_WMEMCMP=''
HAVE_WMEMCPY=''
HAVE_WMEMMOVE=''
HAVE_WMEMPCPY=''
HAVE_WMEMSET=''
HAVE_XLOCALE_H=''
HAVE__BOOL=''
HAVE__EXIT=''
HELP2MAN=''
ICONV_CONST=''
ICONV_H=''
INCLUDE_NEXT=''
INCLUDE_NEXT_AS_FIRST_DIRECTIVE=''
INSTALL_DATA='${INSTALL} -m 644'
INSTALL_PROGRAM='${INSTALL}'
INSTALL_PROGRAM_ENV=''
INSTALL_SCRIPT='${INSTALL}'
INSTALL_STRIP_PROGRAM='$(install_sh) -c -s'
INT32_MAX_LT_INTMAX_MAX=''
INT64_MAX_EQ_LONG_MAX=''
INTLLIBS=''
INTL_MACOSX_LIBS=''
ISNAND_LIBM=''
ISNANF_LIBM=''
ISNANL_LIBM=''
ISNAN_LIBM=''
LDEXPL_LIBM=''
LDEXP_LIBM=''
LDFLAGS=''
LEX='flex'
LEXLIB=''
LEX_IS_FLEX='true'
LEX_OUTPUT_ROOT='lex.yy'
LIBBISON_LIBDEPS=''
LIBBISON_LTLIBDEPS=''
LIBICONV=''
LIBINTL=''
LIBMULTITHREAD=''
LIBOBJS=''
LIBPMULTITHREAD=''
LIBPTHREAD=''
LIBREADLINE=''
LIBS=''
LIBSTDTHREAD=''
LIBTEXTSTYLE=''
LIBTEXTSTYLE_PREFIX=''
LIBTHREAD=''
LIBUNISTRING_COMPILE_UNISTR_U8_MBTOUCR_FALSE=''
LIBUNISTRING_COMPILE_UNISTR_U8_MBTOUCR_TRUE=''
LIBUNISTRING_COMPILE_UNISTR_U8_UCTOMB_FALSE=''
LIBUNISTRING_COMPILE_UNISTR_U8_UCTOMB_TRUE=''
LIBUNISTRING_COMPILE_UNIWIDTH_WIDTH_FALSE=''
LIBUNISTRING_COMPILE_UNIWIDTH_WIDTH_TRUE=''
LIBUNISTRING_UNISTR_H=''
LIBUNISTRING_UNITYPES_H=''
LIBUNISTRING_UNIWIDTH_H=''
LIB_CLOCK_GETTIME=''
LIB_GETHRXTIME=''
LIB_HARD_LOCALE=''
LIB_MBRTOWC=''
LIB_POSIX_SPAWN=''
LIB_SCHED_YIELD=''
LIB_SETLOCALE_NULL=''
LIMITS_H=''
LOCALCHARSET_TESTS_ENVIRONMENT=''
LOCALENAME_ENHANCE_LOCALE_FUNCS=''
LOCALE_FR=''
LOCALE_FR_UTF8=''
LOCALE_JA=''
LOCALE_ZH_CN=''
LTLIBICONV=''
LTLIBINTL=''
LTLIBMULTITHREAD=''
LTLIBOBJS=''
LTLIBREADLINE=''
LTLIBTEXTSTYLE=''
LTLIBTHREAD=''
M4=''
M4_DEBUGFILE=''
M4_GNU=''
MAKEINFO='${SHELL} '\''/cygdrive/c/source/HomeworldSDL/tools/kas2c/bison-3.8/build-aux/missing'\'' makeinfo'
MKDIR_P='/usr/bin/mkdir -p'
MSGFMT=''
MSGFMT_015=''
MSGMERGE=''
NEXT_AS_FIRST_DIRECTIVE_DIRENT_H=''
NEXT_AS_FIRST_DIRECTIVE_ERRNO_H=''
NEXT_AS_FIRST_DIRECTIVE_FCNTL_H=''
NEXT_AS_FIRST_DIRECTIVE_FLOAT_H=''
NEXT_AS_FIRST_DIRECTIVE_GETOPT_H=''
NEXT_AS_FIRST_DIRECTIVE_ICONV_H=''
NEXT_AS_FIRST_DIRECTIVE_INTTYPES_H=''
NEXT_AS_FIRST_DIRECTIVE_LIMITS_H=''
NEXT_AS_FIRST_DIRECTIVE_LOCALE_H=''
NEXT_AS_FIRST_DIRECTIVE_MATH_H=''
NEXT_AS_FIRST_DIRECTIVE_SCHED_H=''
NEXT_AS_FIRST_DIRECTIVE_SIGNAL_H=''
NEXT_AS_FIRST_DIRECTIVE_SPAWN_H=''
NEXT_AS_FIRST_DIRECTIVE_STDDEF_H=''
NEXT_AS_FIRST_DIRECTIVE_STDINT_H=''
NEXT_AS_FIRST_DIRECTIVE_STDIO_H=''
NEXT_AS_FIRST_DIRECTIVE_STDLIB_H=''
NEXT_AS_FIRST_DIRECTIVE_STRINGS_H=''
NEXT_AS_FIRST_DIRECTIVE_STRING_H=''
NEXT_AS_FIRST_DIRECTIVE_SYS_IOCTL_H=''
NEXT_AS_FIRST_DIRECTIVE_SYS_RESOURCE_H=''
NEXT_AS_FIRST_DIRECTIVE_SYS_STAT_H=''
NEXT_AS_FIRST_DIRECTIVE_SYS_TIMES_H=''
NEXT_AS_FIRST_DIRECTIVE_SYS_TIME_H=''
NEXT_AS_FIRST_DIRECTIVE_SYS_TYPES_H=''
NEXT_AS_FIRST_DIRECTIVE_SYS_WAIT_H=''
NEXT_AS_FIRST_DIRECTIVE_TERMIOS_H=''
NEXT_AS_FIRST_DIRECTIVE_TIME_H=''
NEXT_AS_FIRST_DIRECTIVE_UNISTD_H=''
NEXT_AS_FIRST_DIRECTIVE_WCHAR_H=''
NEXT_AS_FIRST_DIRECTIVE_WCTYPE_H=''
NEXT_DIRENT_H=''
NEXT_ERRNO_H=''
NEXT_FCNTL_H=''
NEXT_FLOAT_H=''
NEXT_GETOPT_H=''
NEXT_ICONV_H=''
NEXT_INTTYPES_H=''
NEXT_LIMITS_H=''
NEXT_LOCALE_H=''
NEXT_MATH_H=''
NEXT_SCHED_H=''
NEXT_SIGNAL_H=''
NEXT_SPAWN_H=''
NEXT_STDDEF_H=''
NEXT_STDINT_H=''
NEXT_STDIO_H=''
NEXT_STDLIB_H=''
NEXT_STRINGS_H=''
NEXT_STRING_H=''
NEXT_SYS_IOCTL_H=''
NEXT_SYS_RESOURCE_H=''
NEXT_SYS_STAT_H=''
NEXT_SYS_TIMES_H=''
NEXT_SYS_TIME_H=''
NEXT_SYS_TYPES_H=''
NEXT_SYS_WAIT_H=''
NEXT_TERMIOS_H=''
NEXT_TIME_H=''
NEXT_UNISTD_H=''
NEXT_WCHAR_H=''
NEXT_WCTYPE_H=''
NO_EXCEPTIONS_CXXFLAGS=' -fno-exceptions'
OBJEXT='o'
PACKAGE='bison'
PACKAGE_BUGREPORT='bug-bison@gnu.org'
PACKAGE_COPYRIGHT_YEAR='2021'
PACKAGE_NAME='GNU Bison'
PACKAGE_STRING='GNU Bison 3.8'
PACKAGE_TARNAME='bison'
PACKAGE_URL='https://www.gnu.org/software/bison/'
PACKAGE_VERSION='3.8'
PATH_SEPARATOR=':'
PERL=''
POSUB=''
PRAGMA_COLUMNS=''
PRAGMA_SYSTEM_HEADER=''
PRIPTR_PREFIX=''
PTHREAD_H_DEFINES_STRUCT_TIMESPEC=''
PTRDIFF_T_SUFFIX=''
RANLIB='ranlib'
RELOCATABLE=''
RELOCATABLE_BUILD_DIR=''
RELOCATABLE_CONFIG_H_DIR=''
RELOCATABLE_LDFLAGS=''
RELOCATABLE_LIBRARY_PATH=''
RELOCATABLE_SRC_DIR=''
RELOCATABLE_STRIP=''
RELOCATABLE_VIA_LD_FALSE=''
RELOCATABLE_VIA_LD_TRUE=''
RELOCATABLE_VIA_WRAPPER_FALSE=''
RELOCATABLE_VIA_WRAPPER_TRUE=''
REPLACE_ACCESS=''
REPLACE_ACOSF=''
REPLACE_ALIGNED_ALLOC=''
REPLACE_ASINF=''
REPLACE_ATAN2F=''
REPLACE_ATANF=''
REPLACE_BTOWC=''
REPLACE_CALLOC=''
REPLACE_CANONICALIZE_FILE_NAME=''
REPLACE_CBRTF=''
REPLACE_CBRTL=''
REPLACE_CEIL=''
REPLACE_CEILF=''
REPLACE_CEILL=''
REPLACE_CHOWN=''
REPLACE_CLOSE=''
REPLACE_CLOSEDIR=''
REPLACE_COSF=''
REPLACE_COSHF=''
REPLACE_CREAT=''
REPLACE_CTIME=''
REPLACE_DIRFD=''
REPLACE_DPRINTF=''
REPLACE_DUP2=''
REPLACE_DUP=''
REPLACE_DUPLOCALE=''
REPLACE_EXECL=''
REPLACE_EXECLE=''
REPLACE_EXECLP=''
REPLACE_EXECV=''
REPLACE_EXECVE=''
REPLACE_EXECVP=''
REPLACE_EXECVPE=''
REPLACE_EXP2=''
REPLACE_EXP2L=''
REPLACE_EXPF=''
REPLACE_EXPL=''
REPLACE_EXPM1=''
REPLACE_EXPM1F=''
REPLACE_EXPM1L=''
REPLACE_FABSL=''
REPLACE_FACCESSAT=''
REPLACE_FCHMODAT=''
REPLACE_FCHOWNAT=''
REPLACE_FCLOSE=''
REPLACE_FCNTL=''
REPLACE_FDOPEN=''
REPLACE_FDOPENDIR=''
REPLACE_FFLUSH=''
REPLACE_FFSLL=''
REPLACE_FLOOR=''
REPLACE_FLOORF=''
REPLACE_FLOORL=''
REPLACE_FMA=''
REPLACE_FMAF=''
REPLACE_FMAL=''
REPLACE_FMOD=''
REPLACE_FMODF=''
REPLACE_FMODL=''
REPLACE_FOPEN=''
REPLACE_FPRINTF=''
REPLACE_FPURGE=''
REPLACE_FREE=''
REPLACE_FREELOCALE=''
REPLACE_FREOPEN=''
REPLACE_FREXP=''
REPLACE_FREXPF=''
REPLACE_FREXPL=''
REPLACE_FSEEK=''
REPLACE_FSEEKO=''
REPLACE_FSTAT=''
REPLACE_FSTATAT=''
REPLACE_FTELL=''
REPLACE_FTELLO=''
REPLACE_FTRUNCATE=''
REPLACE_FUTIMENS=''
REPLACE_GETCWD=''
REPLACE_GETDELIM=''
REPLACE_GETDOMAINNAME=''
REPLACE_GETDTABLESIZE=''
REPLACE_GETGROUPS=''
REPLACE_GETLINE=''
REPLACE_GETLOGIN_R=''
REPLACE_GETPAGESIZE=''
REPLACE_GETPASS=''
REPLACE_GETTIMEOFDAY=''
REPLACE_GMTIME=''
REPLACE_HUGE_VAL=''
REPLACE_HYPOT=''
REPLACE_HYPOTF=''
REPLACE_HYPOTL=''
REPLACE_ICONV=''
REPLACE_ICONV_OPEN=''
REPLACE_ICONV_UTF=''
REPLACE_ILOGB=''
REPLACE_ILOGBF=''
REPLACE_ILOGBL=''
REPLACE_INITSTATE=''
REPLACE_IOCTL=''
REPLACE_ISATTY=''
REPLACE_ISFINITE=''
REPLACE_ISINF=''
REPLACE_ISNAN=''
REPLACE_ISWBLANK=''
REPLACE_ISWCNTRL=''
REPLACE_ISWDIGIT=''
REPLACE_ISWXDIGIT=''
REPLACE_ITOLD=''
REPLACE_LCHOWN=''
REPLACE_LDEXPL=''
REPLACE_LINK=''
REPLACE_LINKAT=''
REPLACE_LOCALECONV=''
REPLACE_LOCALTIME=''
REPLACE_LOCALTIME_R=''
REPLACE_LOG10=''
REPLACE_LOG10F=''
REPLACE_LOG10L=''
REPLACE_LOG1P=''
REPLACE_LOG1PF=''
REPLACE_LOG1PL=''
REPLACE_LOG2=''
REPLACE_LOG2F=''
REPLACE_LOG2L=''
REPLACE_LOG=''
REPLACE_LOGB=''
REPLACE_LOGBF=''
REPLACE_LOGBL=''
REPLACE_LOGF=''
REPLACE_LOGL=''
REPLACE_LSEEK=''
REPLACE_LSTAT=''
REPLACE_MALLOC=''
REPLACE_MBRLEN=''
REPLACE_MBRTOWC=''
REPLACE_MBSINIT=''
REPLACE_MBSNRTOWCS=''
REPLACE_MBSRTOWCS=''
REPLACE_MBSTATE_T=''
REPLACE_MBTOWC=''
REPLACE_MEMCHR=''
REPLACE_MEMMEM=''
REPLACE_MKDIR=''
REPLACE_MKFIFO=''
REPLACE_MKFIFOAT=''
REPLACE_MKNOD=''
REPLACE_MKNODAT=''
REPLACE_MKSTEMP=''
REPLACE_MKTIME=''
REPLACE_MODF=''
REPLACE_MODFF=''
REPLACE_MODFL=''
REPLACE_NAN=''
REPLACE_NANOSLEEP=''
REPLACE_NEWLOCALE=''
REPLACE_NULL=''
REPLACE_OBSTACK_PRINTF=''
REPLACE_OPEN=''
REPLACE_OPENAT=''
REPLACE_OPENDIR=''
REPLACE_PERROR=''
REPLACE_POPEN=''
REPLACE_POSIX_MEMALIGN=''
REPLACE_POSIX_SPAWN=''
REPLACE_POSIX_SPAWN_FILE_ACTIONS_ADDCHDIR=''
REPLACE_POSIX_SPAWN_FILE_ACTIONS_ADDCLOSE=''
REPLACE_POSIX_SPAWN_FILE_ACTIONS_ADDDUP2=''
REPLACE_POSIX_SPAWN_FILE_ACTIONS_ADDFCHDIR=''
REPLACE_POSIX_SPAWN_FILE_ACTIONS_ADDOPEN=''
REPLACE_PREAD=''
REPLACE_PRINTF=''
REPLACE_PTHREAD_SIGMASK=''
REPLACE_PTSNAME=''
REPLACE_PTSNAME_R=''
REPLACE_PUTENV=''
REPLACE_PWRITE=''
REPLACE_QSORT_R=''
REPLACE_RAISE=''
REPLACE_RANDOM=''
REPLACE_RANDOM_R=''
REPLACE_READ=''
REPLACE_READLINK=''
REPLACE_READLINKAT=''
REPLACE_REALLOC=''
REPLACE_REALLOCARRAY=''
REPLACE_REALPATH=''
REPLACE_REMAINDER=''
REPLACE_REMAINDERF=''
REPLACE_REMAINDERL=''
REPLACE_REMOVE=''
REPLACE_RENAME=''
REPLACE_RENAMEAT=''
REPLACE_RINTL=''
REPLACE_RMDIR=''
REPLACE_ROUND=''
REPLACE_ROUNDF=''
REPLACE_ROUNDL=''
REPLACE_SCHED_YIELD=''
REPLACE_SETENV=''
REPLACE_SETLOCALE=''
REPLACE_SETSTATE=''
REPLACE_SIGNBIT=''
REPLACE_SIGNBIT_USING_BUILTINS=''
REPLACE_SINF=''
REPLACE_SINHF=''
REPLACE_SLEEP=''
REPLACE_SNPRINTF=''
REPLACE_SPRINTF=''
REPLACE_SQRTF=''
REPLACE_SQRTL=''
REPLACE_STAT=''
REPLACE_STDIO_READ_FUNCS=''
REPLACE_STDIO_WRITE_FUNCS=''
REPLACE_STPNCPY=''
REPLACE_STRCASESTR=''
REPLACE_STRCHRNUL=''
REPLACE_STRDUP=''
REPLACE_STRERROR=''
REPLACE_STRERRORNAME_NP=''
REPLACE_STRERROR_R=''
REPLACE_STRFTIME=''
REPLACE_STRNCAT=''
REPLACE_STRNDUP=''
REPLACE_STRNLEN=''
REPLACE_STRSIGNAL=''
REPLACE_STRSTR=''
REPLACE_STRTOD=''
REPLACE_STRTOIMAX=''
REPLACE_STRTOK_R=''
REPLACE_STRTOL=''
REPLACE_STRTOLD=''
REPLACE_STRTOLL=''
REPLACE_STRTOUL=''
REPLACE_STRTOULL=''
REPLACE_STRTOUMAX=''
REPLACE_STRUCT_LCONV=''
REPLACE_STRUCT_TIMEVAL=''
REPLACE_SYMLINK=''
REPLACE_SYMLINKAT=''
REPLACE_TANF=''
REPLACE_TANHF=''
REPLACE_TIMEGM=''
REPLACE_TMPFILE=''
REPLACE_TOWLOWER=''
REPLACE_TRUNC=''
REPLACE_TRUNCATE=''
REPLACE_TRUNCF=''
REPLACE_TRUNCL=''
REPLACE_TTYNAME_R=''
REPLACE_TZSET=''
REPLACE_UNLINK=''
REPLACE_UNLINKAT=''
REPLACE_UNSETENV=''
REPLACE_USLEEP=''
REPLACE_UTIMENSAT=''
REPLACE_VASPRINTF=''
REPLACE_VDPRINTF=''
REPLACE_VFPRINTF=''
REPLACE_VPRINTF=''
REPLACE_VSNPRINTF=''
REPLACE_VSPRINTF=''
REPLACE_WCRTOMB=''
REPLACE_WCSFTIME=''
REPLACE_WCSNRTOMBS=''
REPLACE_WCSRTOMBS=''
REPLACE_WCSTOK=''
REPLACE_WCSWIDTH=''
REPLACE_WCTOB=''
REPLACE_WCTOMB=''
REPLACE_WCWIDTH=''
REPLACE_WRITE=''
SED=''
SET_MAKE=''
SHELL='/bin/sh'
SIG_ATOMIC_T_SUFFIX=''
SIZE_T_SUFFIX=''
STDBOOL_H=''
STDDEF_H=''
STDINT_H=''
STRIP=''
SYS_IOCTL_H_HAVE_WINSOCK2_H=''
SYS_IOCTL_H_HAVE_WINSOCK2_H_AND_USE_SOCKETS=''
SYS_TIME_H_DEFINES_STRUCT_TIMESPEC=''
TEXTSTYLE_H='textstyle.h'
TIME_H_DEFINES_STRUCT_TIMESPEC=''
TIME_H_DEFINES_TIME_UTC=''
UINT32_MAX_LT_UINTMAX_MAX=''
UINT64_MAX_EQ_ULONG_MAX=''
UNDEFINE_STRTOK_R=''
UNISTD_H_DEFINES_STRUCT_TIMESPEC=''
UNISTD_H_HAVE_SYS_RANDOM_H=''
UNISTD_H_HAVE_WINSOCK2_H=''
UNISTD_H_HAVE_WINSOCK2_H_AND_USE_SOCKETS=''
USE_NLS=''
VALGRIND=''
VALGRIND_OPTS_SUPPRESSION=''
VERSION='3.8'
WARN_CFLAGS=''
WARN_CFLAGS_TEST=''
WARN_CXXFLAGS=''
WARN_CXXFLAGS_TEST=''
WCHAR_T_SUFFIX=''
WERROR_CFLAGS=''
WERROR_CXXFLAGS=''
WINDOWS_64_BIT_OFF_T=''
WINDOWS_64_BIT_ST_SIZE=''
WINDOWS_STAT_INODES=''
WINDOWS_STAT_TIMESPEC=''
WINT_T_SUFFIX=''
WNO_DEPRECATED_CXXFLAGS=''
XGETTEXT=''
XGETTEXT_015=''
XGETTEXT_EXTRA_OPTIONS=''
XSLTPROC=''
YACC='bison -y'
YFLAGS=''
ac_ct_CC='gcc'
ac_ct_CXX='g++'
aclocaldir=''
am__EXEEXT_FALSE=''
am__EXEEXT_TRUE=''
am__fastdepCC_FALSE='#'
am__fastdepCC_TRUE=''
am__fastdepCXX_FALSE='#'
am__fastdepCXX_TRUE=''
am__include='include'
am__isrc=''
am__leading_dot='.'
am__nodep='_no'
am__quote=''
am__tar='$${TAR-tar} chof - "$$tardir"'
am__untar='$${TAR-tar} xf -'
bindir='${exec_prefix}/bin'
build='x86_64-pc-cygwin'
build_alias=''
build_cpu='x86_64'
build_os='cygwin'
build_vendor='pc'
datadir='${datarootdir}'
datarootdir='${prefix}/share'
docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
dvidir='${docdir}'
exec_prefix='NONE'
gl_GNULIB_ENABLED_0137e3d3638b33e5819d132d0b23165c_FALSE=''
gl_GNULIB_ENABLED_0137e3d3638b33e5819d132d0b23165c_TRUE=''
gl_GNULIB_ENABLED_03e0aaad4cb89ca757653bd367a6ccb7_FALSE=''
gl_GNULIB_ENABLED_03e0aaad4cb89ca757653bd367a6ccb7_TRUE=''
gl_GNULIB_ENABLED_1840129d490f3a00c8a098316d0fa345_FALSE=''
gl_GNULIB_ENABLED_1840129d490f3a00c8a098316d0fa345_TRUE=''
gl_GNULIB_ENABLED_1f32594a85e6221ba15f884daeee8c2a_FALSE=''
gl_GNULIB_ENABLED_1f32594a85e6221ba15f884daeee8c2a_TRUE=''
gl_GNULIB_ENABLED_260941c0e5dc67ec9e87d1fb321c300b_FALSE=''
gl_GNULIB_ENABLED_260941c0e5dc67ec9e87d1fb321c300b_TRUE=''
gl_GNULIB_ENABLED_30838f5439487421042f2225bed3af76_FALSE=''
gl_GNULIB_ENABLED_30838f5439487421042f2225bed3af76_TRUE=''
gl_GNULIB_ENABLED_332607f759618fb73dfc3076748afea7_FALSE=''
gl_GNULIB_ENABLED_332607f759618fb73dfc3076748afea7_TRUE=''
gl_GNULIB_ENABLED_3d094ef542bfdd238a5194e172bfe5f6_FALSE=''
gl_GNULIB_ENABLED_3d094ef542bfdd238a5194e172bfe5f6_TRUE=''
gl_GNULIB_ENABLED_3f0e593033d1fc2c127581960f641b66_FALSE=''
gl_GNULIB_ENABLED_3f0e593033d1fc2c127581960f641b66_TRUE=''
gl_GNULIB_ENABLED_43fe87a341d9b4b93c47c3ad819a5239_FALSE=''
gl_GNULIB_ENABLED_43fe87a341d9b4b93c47c3ad819a5239_TRUE=''
gl_GNULIB_ENABLED_48b2271240803e4879464b755748a89d_FALSE=''
gl_GNULIB_ENABLED_48b2271240803e4879464b755748a89d_TRUE=''
gl_GNULIB_ENABLED_503a4cb75d69c787103d0aa2ab7d8440_FALSE=''
gl_GNULIB_ENABLED_503a4cb75d69c787103d0aa2ab7d8440_TRUE=''
gl_GNULIB_ENABLED_68a4501daeca58988392c7e60b4917ab_FALSE=''
gl_GNULIB_ENABLED_68a4501daeca58988392c7e60b4917ab_TRUE=''
gl_GNULIB_ENABLED_75c65a2c014cf8235dd95289676302a4_FALSE=''
gl_GNULIB_ENABLED_75c65a2c014cf8235dd95289676302a4_TRUE=''
gl_GNULIB_ENABLED_8198daae261b932d64a998f8586f5005_FALSE=''
gl_GNULIB_ENABLED_8198daae261b932d64a998f8586f5005_TRUE=''
gl_GNULIB_ENABLED_8bb827fe37eaccf1b97feb0c87bc92ef_FALSE=''
gl_GNULIB_ENABLED_8bb827fe37eaccf1b97feb0c87bc92ef_TRUE=''
gl_GNULIB_ENABLED_cdeb0f2aaf9d280baa6526bfa1b07f70_FALSE=''
gl_GNULIB_ENABLED_cdeb0f2aaf9d280baa6526bfa1b07f70_TRUE=''
gl_GNULIB_ENABLED_chdir_FALSE=''
gl_GNULIB_ENABLED_chdir_TRUE=''
gl_GNULIB_ENABLED_closedir_FALSE=''
gl_GNULIB_ENABLED_closedir_TRUE=''
gl_GNULIB_ENABLED_d4850532688ba16d685f036076611f21_FALSE=''
gl_GNULIB_ENABLED_d4850532688ba16d685f036076611f21_TRUE=''
gl_GNULIB_ENABLED_dbb57f49352be8fb86869629a254fb72_FALSE=''
gl_GNULIB_ENABLED_dbb57f49352be8fb86869629a254fb72_TRUE=''
gl_GNULIB_ENABLED_dirent_FALSE=''
gl_GNULIB_ENABLED_dirent_TRUE=''
gl_GNULIB_ENABLED_dirfd_FALSE=''
gl_GNULIB_ENABLED_dirfd_TRUE=''
gl_GNULIB_ENABLED_dup_FALSE=''
gl_GNULIB_ENABLED_dup_TRUE=''
gl_GNULIB_ENABLED_e7e881d32ca02f1c997b13c737c64bbd_FALSE=''
gl_GNULIB_ENABLED_e7e881d32ca02f1c997b13c737c64bbd_TRUE=''
gl_GNULIB_ENABLED_ed5616be3593d355b981ffab56b9f37b_FALSE=''
gl_GNULIB_ENABLED_ed5616be3593d355b981ffab56b9f37b_TRUE=''
gl_GNULIB_ENABLED_f0efff84a70f4afba30902bb8ffe9354_FALSE=''
gl_GNULIB_ENABLED_f0efff84a70f4afba30902bb8ffe9354_TRUE=''
gl_GNULIB_ENABLED_fca9852db2a43bb33f02f0fbdbc174f6_FALSE=''
gl_GNULIB_ENABLED_fca9852db2a43bb33f02f0fbdbc174f6_TRUE=''
gl_GNULIB_ENABLED_fchdir_FALSE=''
gl_GNULIB_ENABLED_fchdir_TRUE=''
gl_GNULIB_ENABLED_fdopendir_FALSE=''
gl_GNULIB_ENABLED_fdopendir_TRUE=''
gl_GNULIB_ENABLED_ffs_FALSE=''
gl_GNULIB_ENABLED_ffs_TRUE=''
gl_GNULIB_ENABLED_fseterr_FALSE=''
gl_GNULIB_ENABLED_fseterr_TRUE=''
gl_GNULIB_ENABLED_fstat_FALSE=''
gl_GNULIB_ENABLED_fstat_TRUE=''
gl_GNULIB_ENABLED_fstatat_FALSE=''
gl_GNULIB_ENABLED_fstatat_TRUE=''
gl_GNULIB_ENABLED_getdelim_FALSE=''
gl_GNULIB_ENABLED_getdelim_TRUE=''
gl_GNULIB_ENABLED_getdtablesize_FALSE=''
gl_GNULIB_ENABLED_getdtablesize_TRUE=''
gl_GNULIB_ENABLED_getline_FALSE=''
gl_GNULIB_ENABLED_getline_TRUE=''
gl_GNULIB_ENABLED_ldexp_FALSE=''
gl_GNULIB_ENABLED_ldexp_TRUE=''
gl_GNULIB_ENABLED_locale_FALSE=''
gl_GNULIB_ENABLED_locale_TRUE=''
gl_GNULIB_ENABLED_lstat_FALSE=''
gl_GNULIB_ENABLED_lstat_TRUE=''
gl_GNULIB_ENABLED_malloca_FALSE=''
gl_GNULIB_ENABLED_malloca_TRUE=''
gl_GNULIB_ENABLED_memrchr_FALSE=''
gl_GNULIB_ENABLED_memrchr_TRUE=''
gl_GNULIB_ENABLED_openat_FALSE=''
gl_GNULIB_ENABLED_openat_TRUE=''
gl_GNULIB_ENABLED_opendir_FALSE=''
gl_GNULIB_ENABLED_opendir_TRUE=''
gl_GNULIB_ENABLED_readdir_FALSE=''
gl_GNULIB_ENABLED_readdir_TRUE=''
gl_GNULIB_ENABLED_rewinddir_FALSE=''
gl_GNULIB_ENABLED_rewinddir_TRUE=''
gl_GNULIB_ENABLED_rmdir_FALSE=''
gl_GNULIB_ENABLED_rmdir_TRUE=''
gl_GNULIB_ENABLED_strchrnul_FALSE=''
gl_GNULIB_ENABLED_strchrnul_TRUE=''
gl_GNULIB_ENABLED_strings_FALSE=''
gl_GNULIB_ENABLED_strings_TRUE=''
gl_GNULIB_ENABLED_strnlen_FALSE=''
gl_GNULIB_ENABLED_strnlen_TRUE=''
gl_LIBOBJS=''
gl_LTLIBOBJS=''
gltests_LIBOBJS=''
gltests_LTLIBOBJS=''
gltests_WITNESS=''
host='x86_64-pc-cygwin'
host_alias=''
host_cpu='x86_64'
host_os='cygwin'
host_vendor='pc'
htmldir='${docdir}'
includedir='${prefix}/include'
infodir='${datarootdir}/info'
install_sh='${SHELL} /cygdrive/c/source/HomeworldSDL/tools/kas2c/bison-3.8/build-aux/install-sh'
libdir='${exec_prefix}/lib'
libexecdir='${exec_prefix}/libexec'
lispdir=''
localedir='${datarootdir}/locale'
localstatedir='${prefix}/var'
mandir='${datarootdir}/man'
mkdir_p='$(MKDIR_P)'
oldincludedir='/usr/include'
pdfdir='${docdir}'
pkglibexecdir=''
prefix='NONE'
program_transform_name='s,x,x,'
psdir='${docdir}'
runstatedir='${localstatedir}/run'
sbindir='${exec_prefix}/sbin'
sharedstatedir='${prefix}/com'
sysconfdir='${prefix}/etc'
target_alias=''

## ------------------- ##
## File substitutions. ##
## ------------------- ##

relocatable_sh=''

## ----------- ##
## confdefs.h. ##
## ----------- ##

/* confdefs.h */
#define PACKAGE_NAME "GNU Bison"
#define PACKAGE_TARNAME "bison"
#define PACKAGE_VERSION "3.8"
#define PACKAGE_STRING "GNU Bison 3.8"
#define PACKAGE_BUGREPORT "bug-bison@gnu.org"
#define PACKAGE_URL "https://www.gnu.org/software/bison/"
#define PACKAGE_COPYRIGHT_YEAR 2021
#define PACKAGE "bison"
#define VERSION "3.8"
#define HAVE_STDIO_H 1
#define HAVE_STDLIB_H 1
#define HAVE_STRING_H 1
#define HAVE_INTTYPES_H 1
#define HAVE_STDINT_H 1
#define HAVE_STRINGS_H 1
#define HAVE_SYS_STAT_H 1
#define HAVE_SYS_TYPES_H 1
#define HAVE_UNISTD_H 1
#define HAVE_WCHAR_H 1
#define HAVE_LOCALE_H 1
#define HAVE_SYS_PARAM_H 1
#define HAVE_SYS_SOCKET_H 1
#define HAVE_STDIO_EXT_H 1
#define HAVE_FEATURES_H 1
#define HAVE_GETOPT_H 1
#define HAVE_SYS_CDEFS_H 1
#define HAVE_SYS_TIME_H 1
#define HAVE_LIMITS_H 1
#define HAVE_CRTDEFS_H 1
#define HAVE_WCTYPE_H 1
#define HAVE_THREADS_H 1
#define HAVE_MATH_H 1
#define HAVE_SYS_MMAN_H 1
#define HAVE_SPAWN_H 1
#define HAVE_SYS_IOCTL_H 1
#define HAVE_SYS_RESOURCE_H 1
#define HAVE_SYS_TIMES_H 1
#define HAVE_SYS_WAIT_H 1
#define HAVE_TERMIOS_H 1
#define HAVE_DIRENT_H 1
#define STDC_HEADERS 1
#define _ALL_SOURCE 1
#define _DARWIN_C_SOURCE 1
#define _GNU_SOURCE 1
#define _HPUX_ALT_XOPEN_SOCKET_API 1
#define _NETBSD_SOURCE 1
#define _OPENBSD_SOURCE 1
#define _POSIX_PTHREAD_SEMANTICS 1
#define __STDC_WANT_IEC_60559_ATTRIBS_EXT__ 1
#define __STDC_WANT_IEC_60559_BFP_EXT__ 1
#define __STDC_WANT_IEC_60559_DFP_EXT__ 1
#define __STDC_WANT_IEC_60559_FUNCS_EXT__ 1
#define __STDC_WANT_IEC_60559_TYPES_EXT__ 1
#define __STDC_WANT_LIB_EXT2__ 1
#define __STDC_WANT_MATH_SPEC_FUNCS__ 1
#define _TANDEM_SOURCE 1
#define __EXTENSIONS__ 1
#define HAVE_TCDRAIN 1
#define HAVE_CANONICALIZE_FILE_NAME 1
#define HAVE_FACCESSAT 1
#define HAVE_REALPATH 1
#define HAVE_LSTAT 1
#define HAVE_READLINKAT 1
#define HAVE_FCHDIR 1
#define HAVE_FCNTL 1
#define HAVE_SYMLINK 1
#define HAVE_FFSL 1
#define HAVE_VASNPRINTF 1
#define HAVE_SNPRINTF 1
#define HAVE_FSYNC 1
#define HAVE_GETPROGNAME 1
#define HAVE_GETRUSAGE 1
#define HAVE_GETTIMEOFDAY 1
#define HAVE_ISWCNTRL 1
#define HAVE_ISWBLANK 1
#define HAVE_MBSINIT 1
#define HAVE_MBRTOWC 1
#define HAVE_ISASCII 1
#define HAVE_MPROTECT 1
#define HAVE_STRERROR_R 1
#define HAVE___XPG_STRERROR_R 1
#define HAVE_PIPE 1
#define HAVE_PIPE2 1
#define HAVE_READLINK 1
#define HAVE_SETENV 1
#define HAVE_LINK 1
#define HAVE_SIGACTION 1
#define HAVE_SIGALTSTACK 1
#define HAVE_SIGINTERRUPT 1
#define HAVE_STPNCPY 1
#define HAVE_STRNDUP 1
#define HAVE_WCWIDTH 1
#define HAVE_FDOPENDIR 1
#define HAVE_MEMPCPY 1
#define HAVE_FSTATAT 1
#define HAVE_GETDELIM 1
#define HAVE_GETDTABLESIZE 1
#define HAVE_OPENAT 1
#define HAVE_CATGETS 1
#define HAVE_SETLOCALE 1

configure: exit 1
